/// <reference types="node" />
import { AccountInfo, Cluster, Connection, FeeCalculator, Keypair, PublicKey, Transaction, TransactionResponse, TransactionSignature } from '@solana/web3.js';
import { RouteInfo } from './routes';
import { createCreateTokenLedgerInstruction, createOpenOrdersInstruction, createRaydiumSwapInstruction, createMercurialExchangeInstruction, createSerumSwapInstruction, createSetTokenLedgerInstruction } from './jupiterInstruction';
import type { SignerWalletAdapter } from '@solana/wallet-adapter-base';
import { TransactionError } from './error';
import { TokenRouteSegments, PlatformFeeAndAccounts, QuoteMintToReferrer } from './types';
import { SerumAmm } from './serum/serumAmm';
import { SaberAmm } from './saber/saberAmm';
import { SplTokenSwapAmm } from './spl-token-swap/splTokenSwapAmm';
import { MercurialAmm } from './mercurial/mercurialAmm';
import { AldrinAmm } from './aldrin/aldrinAmm';
import { RaydiumAmm } from './raydium/raydiumAmm';
import { CropperAmm } from './cropper/cropperAmm';
import { SenchaAmm } from './sencha/senchaAmm';
import { TokenMintAddress } from './types';
export declare type SerumOpenOrdersMap = Map<string, PublicKey>;
export { MarketInfo } from './market';
export { getPlatformFeeAccounts } from './fee';
export * from './types';
export { RouteInfo, TransactionFeeInfo, getRouteInfoUniqueId } from './routes';
export { AldrinAmm, RaydiumAmm, SerumAmm, SaberAmm, SplTokenSwapAmm, MercurialAmm, CropperAmm, SenchaAmm };
export declare type SwapResult = {
    txid: string;
    inputAddress: PublicKey;
    outputAddress: PublicKey;
    inputAmount: number | undefined;
    outputAmount: number | undefined;
} | {
    error?: TransactionError;
};
declare type JupiterLoadArgs = {
    connection: Connection;
    cluster: Cluster;
    user?: PublicKey | Keypair;
    platformFeeAndAccounts?: PlatformFeeAndAccounts;
    quoteMintToReferrer?: Map<TokenMintAddress, PublicKey>;
    routeCacheDuration?: number;
    wrapUnwrapSOL?: boolean;
    marketUrl?: string;
};
export declare class Jupiter {
    private connection;
    private cluster;
    tokenRouteSegments: TokenRouteSegments;
    private feeCalculator;
    private platformFeeAndAccounts;
    /** Referrer account to collect Serum referrer fees for each given quote mint, the referrer fee is 20% of the Serum protocol fee */
    private quoteMintToReferrer;
    /** route cache duration in ms */
    private routeCacheDuration;
    /** When set to true (default) native SOL is wrapped and wSOL unwrapped in each swap, otherwise it assumes wSOL is funded when it exists */
    private wrapUnwrapSOL;
    private serumOpenOrdersPromise;
    private instructionCache;
    private user;
    private routeCache;
    constructor(connection: Connection, cluster: Cluster, tokenRouteSegments: TokenRouteSegments, feeCalculator: FeeCalculator, platformFeeAndAccounts: PlatformFeeAndAccounts, 
    /** Referrer account to collect Serum referrer fees for each given quote mint, the referrer fee is 20% of the Serum protocol fee */
    quoteMintToReferrer: QuoteMintToReferrer, 
    /** route cache duration in ms */
    routeCacheDuration?: number, 
    /** When set to true (default) native SOL is wrapped and wSOL unwrapped in each swap, otherwise it assumes wSOL is funded when it exists */
    wrapUnwrapSOL?: boolean);
    /**
     * load performs the necessary async scaffolding of the Jupiter object
     */
    static load({ connection, cluster, user, platformFeeAndAccounts, quoteMintToReferrer, routeCacheDuration, wrapUnwrapSOL, marketUrl, }: JupiterLoadArgs): Promise<Jupiter>;
    getPublicKeysToUpdate(): string[];
    computeRoutes(inputMint: PublicKey, outputMint: PublicKey, inputAmount: number, slippage: number, shouldFetchRoutes?: boolean, externalAccountInfosMap?: Map<string, AccountInfo<Buffer>>, feeBps?: number): Promise<{
        routesInfos: RouteInfo[];
        cached: boolean;
    }>;
    setUserPublicKey(userPublicKey: Keypair | PublicKey): void;
    /**
     * The token route segments contains all the routes and the market meta information.
     */
    static fetchTokenRouteSegments(connection: Connection, cluster: Cluster, marketUrl?: string): Promise<TokenRouteSegments>;
    /**
     * This generate a routeMap which represents every possible output token mint for a given input token mint.
     * For example, we have SOL to USDC and this pairs have many routings like
     * SOL => USDT
     * USDT => USDC
     * SOL => USDC
     *
     * From here we know that we can have 2 different routing of SOL => USDC.
     * We do single level routing map but for all coins which result in the route map below:
     * SOL => USDT, USDC
     * USDT => SOL
     * USDC => SOL, USDT
     *
     * From this route map we can map out all possible route from one to another by checking the intersection.
     */
    getRouteMap(): Map<string, string[]>;
    /**
     * Query existing open order account, this query is slow.
     * We suggest to fetch this in the background.
     */
    static findSerumOpenOrdersForOwner: ({ userPublicKey, cluster, connection, }: {
        userPublicKey: PublicKey;
        cluster: Cluster;
        connection: Connection;
    }) => Promise<SerumOpenOrdersMap>;
    exchange: (params: {
        route: RouteInfo;
        userPublicKey?: PublicKey;
        feeAccount?: PublicKey;
    }) => Promise<{
        transactions: {
            setupTransaction?: Transaction;
            swapTransaction: Transaction;
            cleanupTransaction?: Transaction;
        };
        execute: (params?: {
            wallet?: Pick<SignerWalletAdapter, 'sendTransaction' | 'signAllTransactions' | 'signTransaction'>;
            confirmationWaiterFactory?: (txid: TransactionSignature, totalTxs: number) => Promise<TransactionResponse | null>;
        }) => Promise<SwapResult>;
    }>;
    static createCreateTokenLedgerInstruction: typeof createCreateTokenLedgerInstruction;
    static createOpenOrdersInstruction: typeof createOpenOrdersInstruction;
    static createRaydiumSwapInstruction: typeof createRaydiumSwapInstruction;
    static createMercurialExchangeInstruction: typeof createMercurialExchangeInstruction;
    static createSerumSwapInstruction: typeof createSerumSwapInstruction;
    static createSetTokenLedgerInstruction: typeof createSetTokenLedgerInstruction;
}
