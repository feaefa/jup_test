import { u64, TOKEN_PROGRAM_ID, AccountLayout, Token, ASSOCIATED_TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { PublicKey, SYSVAR_RENT_PUBKEY, SYSVAR_CLOCK_PUBKEY, SystemProgram, Transaction } from '@solana/web3.js';
import { OpenOrders, Market, Orderbook } from '@project-serum/serum';
import { SWAP_PROGRAM_ID, StableSwap } from '@saberhq/stableswap-sdk';
import JSBI from 'jsbi';
import { Program } from '@project-serum/anchor';
import { findProgramAddressSync, createProgramAddressSync } from '@project-serum/anchor/dist/cjs/utils/pubkey';
import BN$1, { BN } from 'bn.js';
import { Fraction, Stable, ONE, TokenSwapConstantProduct, TokenSwapStable, ZERO as ZERO$1 } from '@jup-ag/math';
import { Layout, blob, struct, u8, nu64, u32 } from '@solana/buffer-layout';
import Decimal from 'decimal.js';
import fetch from 'cross-fetch';
import promiseRetry from 'promise-retry';

var addDecimalsJson = [
	{
		wrapper: "2B5Qedoo95Pjpv9xVPw82bbmcGDGCNHroKpzQE2CNHRZ",
		underlying: "CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "3YCGgStAV9H7TdPYdBnRP8yoH4Zqdmyt7xo6KB4Wa8xt",
		mint: "C9xqJe3gMTUDKidZsZ6jJ7tL9zSLimDUKVpgUbLZnNbi",
		decimals: 9
	},
	{
		wrapper: "2ffwMLE4dxSv59eYXhfhfuS81kz6gzf6DZjdBxRHZz9A",
		underlying: "AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "H5tnZcfHCzHueNnfd6foeBBUUW4g7qXKt6rKzT7wg6oP",
		mint: "FTT9rBBrYwcHam4qLvkzzzhrsihYMbZ3k6wJbdoahxAt",
		decimals: 9
	},
	{
		wrapper: "3A85wiQg2REhBVxVS1CjDaS333TBNM2g37BbdNGSMheg",
		underlying: "CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",
		underlyingDecimals: 8,
		wrapperUnderlyingTokens: "764FaQrrREvNTpaH2yXyrPZgVBaXA7AXM8vyCaevXitD",
		mint: "BtX7AfzEJLnU8KQR1AgHrhGH5s2AHUTbfjhUQP8BhPvi",
		decimals: 10
	},
	{
		wrapper: "7hWjnVC6FNkmmgjq88LEnRycrKvxVB1MsJ6FQcrvxe4n",
		underlying: "9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "B22gDMgN2tNWmvyzhb5tamJKanWcUUUw2zN3h3qjgQg8",
		mint: "9999j2A8sXUtHtDoQdk528oVzhaKBsXyRGZ67FKGoi7H",
		decimals: 9
	},
	{
		wrapper: "93qsLbASEG8DmtSB2MEVaa25KvEm2afh5rzbaAJHLi5A",
		underlying: "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",
		underlyingDecimals: 8,
		wrapperUnderlyingTokens: "4fUL9yLbFZEuG32SaCjWqJXwDTBFNnipteBWxMvvFoC8",
		mint: "KNVfdSJyq1pRQk9AKKv1g5uyGuk6wpm4WG16Bjuwdma",
		decimals: 9
	},
	{
		wrapper: "AnKLLfpMcceM6YXtJ9nGxYekVXqfWy8WNsMZXoQTCVQk",
		underlying: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "77XHXCWYQ76E9Q3uCuz1geTaxsqJZf9RfX5ZY7yyLDYt",
		mint: "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
		decimals: 9
	},
	{
		wrapper: "D231Uoh24bXtUtWN51ZbFAFSBmGT3zuuEAHZNuCmtRjN",
		underlying: "CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",
		underlyingDecimals: 8,
		wrapperUnderlyingTokens: "C39Wq6X98TLcrnYCMkcHQhwUurkQMUdibUCpf2fVBDsm",
		mint: "FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",
		decimals: 9
	},
	{
		wrapper: "F9TsAsh5RirU3LqyTJECLQEGXnF4RQT7ckvexCP1KNTu",
		underlying: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "BSTjdztBrsptuxfz9JHS31Wc9CknpLeL1wqZjeVs1Ths",
		mint: "AEUT5uFm1D575FVCoQd5Yq891FJEqkncZUbBFoFcAhTV",
		decimals: 9
	},
	{
		wrapper: "FCgoT8RpsopdM5QT6AB98NUfUnDnu7y865MFpRx93JrS",
		underlying: "EzfgjvkSwthhgHaceR3LnKXUoRkP6NUhfghdaHAj1tUv",
		underlyingDecimals: 8,
		wrapperUnderlyingTokens: "5yugfArBAUZJJBUCRWPuiLyi6CWp1f67H9xgg3hcgSkx",
		mint: "FTT9GrHBVHvDeUTgLU8FxVJouGqg9uiWGmmjETdm32Sx",
		decimals: 9
	},
	{
		wrapper: "FDGtFWVhEb1zxnaW2FzogeGDxLoAV7Cu9XdNYPEVwqt",
		underlying: "8wv2KAykQstNAj2oW6AHANGBiFKVFhvMiyyzzjhkmGvE",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "4R6PmC8BJcPDBsEMGpXpLCnFFkUZhEgZy6pMNtc2LqA4",
		mint: "KUANeD8EQvwpT1W7QZDtDqctLEh2FfSTy5pThE9CogT",
		decimals: 9
	},
	{
		wrapper: "FPuYMuodknZuQKHA8Wp4PBbp52Qu8nK2oAuwedp2WfM3",
		underlying: "9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "GxpyQZi5VkZDSq5TUycMau11sCkQkVCa8xYhBgiPMsyK",
		mint: "UST98bfV6EASdTFQrRwCBczpehdMFwYCUdLT5tEbhpW",
		decimals: 9
	},
	{
		wrapper: "G4gRGymKo7MGzGZup12JS39YVCvy8YMM6KY9AmcKi5iw",
		underlying: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "AQhP39mE4o6BYNwnwYqnz7ZobkPBSLpCg8WvEESq1viZ",
		mint: "88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",
		decimals: 8
	},
	{
		wrapper: "GiLSv94Wwyd6suH57Fu6HjEKsMxhNGfEwKn9vT22me1p",
		underlying: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "3cjAWoyDcco8UVCN17keNUNHoyz37ctgDa7G6zkeb81Y",
		mint: "T8KdT8hDzNhbGx5sjpEUxepnbDB1TZoCa7vtC5JjsMw",
		decimals: 8
	},
	{
		wrapper: "GpkFF2nPfjUcsavgDGscxaUEQ2hYJ563AXXtU8ohiZ7c",
		underlying: "9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "6hYDFhZ5ddfzoqaAbzRHm8mzG2MQzYQV9295sQHsvNBV",
		mint: "SBTCB6pWqeDo6zGi9WVRMLCsKsN6JiR1RMUqvLtgSRv",
		decimals: 8
	},
	{
		wrapper: "fvSvtHNFuDHrAN82YEyBApRs3U6vUGCLzKGMuPmCaF8",
		underlying: "2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "4JWyJ4ZYsQ8uiYue2tTEqcHcFXrDuaQ1rsyjNFfrZm65",
		mint: "SL819j8K9FuFPL84UepVcFkEZqDUUvVzwDmJjCHySYj",
		decimals: 8
	},
	{
		wrapper: "ACvLVgR3UKdDB3b1QapsbJsPXaUrBPdJGDfiFnMYMXoz",
		underlying: "F6v4wfAdJB8D8p77bMXZgYt8TDKsYxLYxH5AFhUkYx9W",
		underlyingDecimals: 6,
		wrapperUnderlyingTokens: "AvqMJWHsZscPWTAUcj8dZi2ch6XQEHMpiCMprfFovaU",
		mint: "LUNGEjUXyP48nrC1GYY5o4eTAkwm4RdX8BxFUxWJBLB",
		decimals: 9
	}
];

const IDL = {
  version: '0.1.0',
  name: 'jupiter',
  instructions: [{
    name: 'mercurialExchange',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swapState',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'sourceTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'destinationTokenAccount',
      isMut: true,
      isSigner: false
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'saberExchange',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swap',
      isMut: false,
      isSigner: false
    }, {
      name: 'swapAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'userAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'clock',
      isMut: false,
      isSigner: false
    }, {
      name: 'inputUserAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputUserAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'feesTokenAccount',
      isMut: true,
      isSigner: false
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'saberAddDecimalsDeposit',
    accounts: [{
      name: 'addDecimalsProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'wrapper',
      isMut: false,
      isSigner: false
    }, {
      name: 'wrapperMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'wrapperUnderlyingTokens',
      isMut: true,
      isSigner: false
    }, {
      name: 'owner',
      isMut: false,
      isSigner: true
    }, {
      name: 'userUnderlyingTokens',
      isMut: true,
      isSigner: false
    }, {
      name: 'userWrappedTokens',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'saberAddDecimalsWithdraw',
    accounts: [{
      name: 'addDecimalsProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'wrapper',
      isMut: false,
      isSigner: false
    }, {
      name: 'wrapperMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'wrapperUnderlyingTokens',
      isMut: true,
      isSigner: false
    }, {
      name: 'owner',
      isMut: false,
      isSigner: true
    }, {
      name: 'userUnderlyingTokens',
      isMut: true,
      isSigner: false
    }, {
      name: 'userWrappedTokens',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'senchaExchange',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swap',
      isMut: true,
      isSigner: false
    }, {
      name: 'userAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'inputUserAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputFeesAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputUserAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputFeesAccount',
      isMut: true,
      isSigner: false
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'serumSwap',
    accounts: [{
      name: 'market',
      accounts: [{
        name: 'market',
        isMut: true,
        isSigner: false
      }, {
        name: 'openOrders',
        isMut: true,
        isSigner: false
      }, {
        name: 'requestQueue',
        isMut: true,
        isSigner: false
      }, {
        name: 'eventQueue',
        isMut: true,
        isSigner: false
      }, {
        name: 'bids',
        isMut: true,
        isSigner: false
      }, {
        name: 'asks',
        isMut: true,
        isSigner: false
      }, {
        name: 'coinVault',
        isMut: true,
        isSigner: false
      }, {
        name: 'pcVault',
        isMut: true,
        isSigner: false
      }, {
        name: 'vaultSigner',
        isMut: false,
        isSigner: false
      }]
    }, {
      name: 'authority',
      isMut: false,
      isSigner: true
    }, {
      name: 'orderPayerTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'coinWallet',
      isMut: true,
      isSigner: false
    }, {
      name: 'pcWallet',
      isMut: true,
      isSigner: false
    }, {
      name: 'dexProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'side',
      type: {
        defined: 'Side'
      }
    }, {
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'tokenSwap',
    accounts: [{
      name: 'tokenSwapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swap',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'source',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapSource',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'destination',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolFee',
      isMut: true,
      isSigner: false
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'stepTokenSwap',
    accounts: [{
      name: 'tokenSwapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swap',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'source',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapSource',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'destination',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolFee',
      isMut: true,
      isSigner: false
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'cropperTokenSwap',
    accounts: [{
      name: 'tokenSwapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swap',
      isMut: false,
      isSigner: false
    }, {
      name: 'swapState',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'source',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapSource',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'destination',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolFee',
      isMut: true,
      isSigner: false
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'raydiumSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'ammId',
      isMut: true,
      isSigner: false
    }, {
      name: 'ammAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'ammOpenOrders',
      isMut: true,
      isSigner: false
    }, {
      name: 'ammTargetOrders',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolCoinTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolPcTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumProgramId',
      isMut: false,
      isSigner: false
    }, {
      name: 'serumMarket',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumBids',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumAsks',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumEventQueue',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumCoinVaultAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumPcVaultAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumVaultSigner',
      isMut: false,
      isSigner: false
    }, {
      name: 'userSourceTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userDestinationTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userSourceOwner',
      isMut: false,
      isSigner: true
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'raydiumSwapV2',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'ammId',
      isMut: true,
      isSigner: false
    }, {
      name: 'ammAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'ammOpenOrders',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolCoinTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolPcTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumProgramId',
      isMut: false,
      isSigner: false
    }, {
      name: 'serumMarket',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumBids',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumAsks',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumEventQueue',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumCoinVaultAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumPcVaultAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumVaultSigner',
      isMut: false,
      isSigner: false
    }, {
      name: 'userSourceTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userDestinationTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userSourceOwner',
      isMut: false,
      isSigner: true
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'aldrinSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'pool',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolSigner',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'baseTokenVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'quoteTokenVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'feePoolTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'walletAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'userBaseTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userQuoteTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'side',
      type: {
        defined: 'Side'
      }
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'aldrinV2Swap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'pool',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolSigner',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'baseTokenVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'quoteTokenVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'feePoolTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'walletAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'userBaseTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userQuoteTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'curve',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'inAmount',
      type: {
        option: 'u64'
      }
    }, {
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'side',
      type: {
        defined: 'Side'
      }
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'riskCheckAndFee',
    accounts: [{
      name: 'tokenLedger',
      isMut: true,
      isSigner: false
    }, {
      name: 'userDestinationTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'minimumOutAmount',
      type: 'u64'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'initializeTokenLedger',
    accounts: [{
      name: 'tokenLedger',
      isMut: true,
      isSigner: false
    }, {
      name: 'payer',
      isMut: false,
      isSigner: true
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'setTokenLedger',
    accounts: [{
      name: 'tokenLedger',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenAccount',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'createOpenOrders',
    accounts: [{
      name: 'openOrders',
      isMut: true,
      isSigner: false
    }, {
      name: 'payer',
      isMut: true,
      isSigner: true
    }, {
      name: 'dexProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }, {
      name: 'market',
      isMut: false,
      isSigner: false
    }],
    args: []
  }],
  accounts: [{
    name: 'tokenLedger',
    type: {
      kind: 'struct',
      fields: [{
        name: 'tokenAccount',
        type: 'publicKey'
      }, {
        name: 'amount',
        type: 'u64'
      }]
    }
  }],
  types: [{
    name: 'Swap',
    type: {
      kind: 'struct',
      fields: [{
        name: 'tokens',
        type: 'u64'
      }, {
        name: 'minTokens',
        type: 'u64'
      }, {
        name: 'side',
        type: {
          defined: 'Side'
        }
      }]
    }
  }, {
    name: 'Swap',
    type: {
      kind: 'struct',
      fields: [{
        name: 'tokens',
        type: 'u64'
      }, {
        name: 'minTokens',
        type: 'u64'
      }, {
        name: 'side',
        type: {
          defined: 'Side'
        }
      }]
    }
  }, {
    name: 'Deposit',
    type: {
      kind: 'struct',
      fields: [{
        name: 'amount',
        type: 'u64'
      }]
    }
  }, {
    name: 'Withdraw',
    type: {
      kind: 'struct',
      fields: [{
        name: 'maxBurnAmount',
        type: 'u64'
      }]
    }
  }, {
    name: 'Direction',
    type: {
      kind: 'enum',
      variants: [{
        name: 'LeftToRight'
      }, {
        name: 'RightToLeft'
      }]
    }
  }, {
    name: 'Side',
    type: {
      kind: 'enum',
      variants: [{
        name: 'Bid'
      }, {
        name: 'Ask'
      }]
    }
  }],
  errors: [{
    code: 6000,
    name: 'SlippageToleranceExceeded',
    msg: 'Slippage tolerance exceeded'
  }, {
    code: 6001,
    name: 'InvalidTokenLedger',
    msg: 'Invalid token ledger'
  }, {
    code: 6002,
    name: 'MissingTokenLedger',
    msg: 'Missing token ledger'
  }, {
    code: 6003,
    name: 'MissingMercurialExchangeTokenAccount',
    msg: 'Missing mercurial exchange token account'
  }, {
    code: 6004,
    name: 'LedgerTokenAccountDoesNotMatch',
    msg: 'Ledger token account does not match'
  }, {
    code: 6005,
    name: 'MissingPlatformFeeAccount',
    msg: 'Missing platform fee account'
  }, {
    code: 6006,
    name: 'InvalidCalculation',
    msg: 'Invalid calculation'
  }]
};

const WRAPPED_SOL_MINT = /*#__PURE__*/new PublicKey('So11111111111111111111111111111111111111112');
const MAINNET_SERUM_DEX_PROGRAM = /*#__PURE__*/new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin');
const DEVNET_SERUM_DEX_PROGRAM = /*#__PURE__*/new PublicKey('DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY');
const MARKETS_URL = {
  devnet: 'https://api.jup.ag/api/markets/cache/devnet',
  'mainnet-beta': 'https://cache.jup.ag/markets?v=3',
  testnet: 'https://api.jup.ag/api/markets/cache/devnet'
};
const TOKEN_LIST_URL = {
  devnet: 'https://api.jup.ag/api/tokens/devnet',
  testnet: 'https://api.jup.ag/api/markets/devnet',
  'mainnet-beta': 'https://cache.jup.ag/tokens'
};
const RAYDIUM_AMM_V4_PROGRAM_ID = /*#__PURE__*/new PublicKey('675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8');
const ALDRIN_SWAP_PROGRAM_ID = /*#__PURE__*/new PublicKey('AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6'); // https://github.com/aldrin-exchange/aldrin-sdk/blob/f93fe3f2d847d79d8ddff507d8d4f62fd803421b/src/v2.json

const ALDRIN_SWAP_V2_PROGRAM_ID = /*#__PURE__*/new PublicKey('CURVGoZn8zycx6FXwwevgBTB2gVvdbGTEpvMJDbgs2t4');
const SABER_ADD_DECIMALS_PROGRAM_ID = /*#__PURE__*/new PublicKey('DecZY86MU5Gj7kppfUCEmd4LbXXuyZH1yHaP2NTqdiZB');
const CROPPER_PROGRAM_ID = /*#__PURE__*/new PublicKey('CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh');
const SENCHA_PROGRAM_ID = /*#__PURE__*/new PublicKey('SCHAtsf8mbjyjiv4LkhLKutTf6JnZAbdJKFkXQNMFHZ');
const ZERO_FRACTION = /*#__PURE__*/new Fraction( /*#__PURE__*/JSBI.BigInt(0), /*#__PURE__*/JSBI.BigInt(1));
const JUPITER_WALLET = /*#__PURE__*/new PublicKey('BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9');
const MERCURIAL_SWAP_PROGRAM_ID = /*#__PURE__*/new PublicKey('MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky');

class PublicKeyLayout extends Layout {
  constructor(property) {
    const layout = blob(32);
    super(layout.span, property);
    this.layout = void 0;
    this.layout = layout;
  }

  getSpan(b, offset) {
    return this.layout.getSpan(b, offset);
  }

  decode(b, offset) {
    return new PublicKey(this.layout.decode(b, offset));
  }

  encode(src, b, offset) {
    return this.layout.encode(src.toBuffer(), b, offset);
  }

}
/**
 * Layout for a public key
 */


const publicKey = property => new PublicKeyLayout(property);

class U64Layout extends Layout {
  constructor(span = 8, property) {
    const layout = blob(span);
    super(layout.span, property);
    this.layout = void 0;
    this.layout = layout;
  }

  getSpan(b, offset) {
    return this.layout.getSpan(b, offset);
  }

  decode(b, offset) {
    const bn = new u64(this.layout.decode(b, offset), 10, 'le');
    return bn;
  }

  encode(src, b, offset) {
    return this.layout.encode(src.toArrayLike(Buffer, 'le', this.layout.span), b, offset);
  }

}
/**
 * Layout for a 64bit unsigned value
 */


const uint64 = property => new U64Layout(8, property);
const uint128 = property => new U64Layout(16, property);

const CropperTokenSwapLayout = /*#__PURE__*/struct([/*#__PURE__*/u8('version'), /*#__PURE__*/u8('isInitialized'), /*#__PURE__*/u8('nonce'), /*#__PURE__*/publicKey('ammId'), /*#__PURE__*/publicKey('serumProgramId'), /*#__PURE__*/publicKey('serumMarket'), /*#__PURE__*/publicKey('tokenProgramId'), /*#__PURE__*/publicKey('tokenAAccount'), /*#__PURE__*/publicKey('tokenBAccount'), /*#__PURE__*/publicKey('poolMint'), /*#__PURE__*/publicKey('mintA'), /*#__PURE__*/publicKey('mintB')]);
const CropperStateLayout = /*#__PURE__*/struct([/*#__PURE__*/u8('isInitialized'), /*#__PURE__*/publicKey('stateOwner'), /*#__PURE__*/publicKey('feeOwner'), /*#__PURE__*/uint64('initialSupply'), /*#__PURE__*/uint64('returnFeeNumerator'), /*#__PURE__*/uint64('fixedFeeNumerator'), /*#__PURE__*/uint64('feeDenominator'), /*#__PURE__*/u8('curveType'), /*#__PURE__*/blob(32, 'curveParameters')]); // This seems to be hardcoded.

const CROPPER_STATE_ADDRESS = /*#__PURE__*/new PublicKey('3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq');
const accountInfoToCropperPoolState = (address, accountInfo) => {
  const programId = accountInfo.owner;
  const decoded = CropperTokenSwapLayout.decode(accountInfo.data);
  const [authority] = findProgramAddressSync([address.toBuffer()], programId);
  return {
    programId,
    authority,
    version: decoded.version,
    isInitialized: Boolean(decoded.isInitialized),
    nonce: decoded.nonce,
    ammId: decoded.ammId,
    serumProgramId: decoded.serumProgramId,
    tokenProgramId: decoded.tokenProgramId,
    tokenAAccount: decoded.tokenAAccount,
    tokenBAccount: decoded.tokenBAccount,
    serumMarket: decoded.serumMarket,
    poolMint: decoded.poolMint,
    mintA: decoded.mintA,
    mintB: decoded.mintB
  };
};
const stateAccountInfoToCropperState = accountInfo => {
  const decoded = CropperStateLayout.decode(accountInfo.data);
  return {
    isInitialized: Boolean(decoded.isInitialized),
    stateOwner: decoded.stateOwner,
    feeOwner: decoded.feeOwner,
    initialSupply: decoded.initialSupply,
    returnFeeNumerator: decoded.returnFeeNumerator.toNumber(),
    fixedFeeNumerator: decoded.fixedFeeNumerator.toNumber(),
    feeDenominator: decoded.feeDenominator.toNumber(),
    curveType: decoded.curveType,
    curveParameters: decoded.curveParameters
  };
};

const Side = {
  Bid: {
    bid: {}
  },
  Ask: {
    ask: {}
  }
};
const JUPITER_PROGRAM_ID_PRODUCTION = /*#__PURE__*/new PublicKey('JUP2jxvXaqu7NQY1GmNF4m1vodw12LVXYxbFL2uJvfo');
const JUPITER_PROGRAM_ID = JUPITER_PROGRAM_ID_PRODUCTION; // JUPITER_PROGRAM_ID_PRODUCTION;

const JUPITER_PROGRAM = /*#__PURE__*/new Program(IDL, JUPITER_PROGRAM_ID, {});
const [TOKEN_LEDGER] = /*#__PURE__*/findProgramAddressSync([/*#__PURE__*/Buffer.from('token_ledger')], JUPITER_PROGRAM_ID);

function stableSwapNPoolIntoMercurialExchange(swayLayout, sourceTokenAccount, destinationTokenAccount, user) {
  return {
    swapProgram: MERCURIAL_SWAP_PROGRAM_ID,
    swapState: swayLayout.ammId,
    tokenProgram: TOKEN_PROGRAM_ID,
    poolAuthority: swayLayout.authority,
    userTransferAuthority: user,
    sourceTokenAccount,
    destinationTokenAccount
  };
}

function raydiumAmmToRaydiumSwap(raydiumAmm, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user) {
  const [ammAuthority] = findProgramAddressSync([new Uint8Array(Buffer.from('amm authority'.replace('\u00A0', ' '), 'utf-8'))], RAYDIUM_AMM_V4_PROGRAM_ID);

  if (!raydiumAmm.serumMarketKeys) {
    throw Error('RaydiumAmm is missing serumMarketKeys');
  }

  return {
    swapProgram: RAYDIUM_AMM_V4_PROGRAM_ID,
    tokenProgram: TOKEN_PROGRAM_ID,
    ammId: raydiumAmm.ammId,
    ammAuthority,
    ammOpenOrders: raydiumAmm.ammOpenOrders,
    poolCoinTokenAccount: raydiumAmm.poolCoinTokenAccount,
    poolPcTokenAccount: raydiumAmm.poolPcTokenAccount,
    serumProgramId: raydiumAmm.serumProgramId,
    serumMarket: raydiumAmm.serumMarket,
    serumBids: raydiumAmm.serumMarketKeys.serumBids,
    serumAsks: raydiumAmm.serumMarketKeys.serumAsks,
    serumEventQueue: raydiumAmm.serumMarketKeys.serumEventQueue,
    serumCoinVaultAccount: raydiumAmm.serumMarketKeys.serumCoinVaultAccount,
    serumPcVaultAccount: raydiumAmm.serumMarketKeys.serumPcVaultAccount,
    serumVaultSigner: raydiumAmm.serumMarketKeys.serumVaultSigner,
    userSourceTokenAccount: userSourceTokenAccountAddress,
    userDestinationTokenAccount: userDestinationTokenAccountAddress,
    userSourceOwner: user
  };
}

function marketIntoSerumSwap(market, openOrdersAddress, orderPayerTokenAccountAddress, coinWallet, pcWallet, user) {
  const vaultSigner = createProgramAddressSync([market.address.toBuffer(), market.decoded.vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], market.programId);
  return {
    market: {
      market: market.address,
      openOrders: openOrdersAddress,
      requestQueue: market.decoded.requestQueue,
      eventQueue: market.decoded.eventQueue,
      bids: market.bidsAddress,
      asks: market.asksAddress,
      coinVault: market.decoded.baseVault,
      pcVault: market.decoded.quoteVault,
      vaultSigner
    },
    authority: user,
    orderPayerTokenAccount: orderPayerTokenAccountAddress,
    coinWallet,
    pcWallet,
    // Programs.
    dexProgram: market.programId,
    tokenProgram: TOKEN_PROGRAM_ID,
    // Sysvars.
    rent: SYSVAR_RENT_PUBKEY
  };
}

function createMercurialExchangeInstruction(swapLayout, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user, amount, minimumOutAmount, platformFee) {
  var _platformFee$feeBps;

  const remainingAccounts = [];

  for (const swapTokenAccount of swapLayout.tokenAccounts) {
    remainingAccounts.push({
      pubkey: swapTokenAccount,
      isSigner: false,
      isWritable: true
    });
  }

  remainingAccounts.push(...prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount));
  return JUPITER_PROGRAM.instruction.mercurialExchange(amount ? new BN(amount) : amount, new BN(minimumOutAmount), (_platformFee$feeBps = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps !== void 0 ? _platformFee$feeBps : 0, {
    accounts: stableSwapNPoolIntoMercurialExchange(swapLayout, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user),
    remainingAccounts
  });
}
function createSerumSwapInstruction(market, inputMint, openOrdersAddress, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user, amount, minimumOutAmount, platformFee, referrer) {
  var _platformFee$feeBps2;

  const {
    side,
    coinWallet,
    pcWallet
  } = inputMint.equals(market.baseMintAddress) ? {
    side: Side.Ask,
    coinWallet: userSourceTokenAccountAddress,
    pcWallet: userDestinationTokenAccountAddress
  } : {
    side: Side.Bid,
    coinWallet: userDestinationTokenAccountAddress,
    pcWallet: userSourceTokenAccountAddress
  };
  let remainingAccounts = prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount);

  if (referrer) {
    remainingAccounts.push({
      pubkey: referrer,
      isSigner: false,
      isWritable: true
    });
  }

  return JUPITER_PROGRAM.instruction.serumSwap(side, amount ? new BN(amount) : amount, new BN(minimumOutAmount), (_platformFee$feeBps2 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps2 !== void 0 ? _platformFee$feeBps2 : 0, {
    accounts: marketIntoSerumSwap(market, openOrdersAddress, userSourceTokenAccountAddress, coinWallet, pcWallet, user),
    remainingAccounts
  });
}
function createTokenSwapInstruction(tokenSwapState, inputMint, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user, amount, minimumOutAmount, platformFee, isStep) {
  var _platformFee$feeBps3;

  const [swapSource, swapDestination] = inputMint.equals(tokenSwapState.mintA) ? [tokenSwapState.tokenAccountA, tokenSwapState.tokenAccountB] : [tokenSwapState.tokenAccountB, tokenSwapState.tokenAccountA];
  return (isStep ? JUPITER_PROGRAM.instruction.stepTokenSwap : JUPITER_PROGRAM.instruction.tokenSwap)(amount ? new BN(amount) : amount, new BN(minimumOutAmount), (_platformFee$feeBps3 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps3 !== void 0 ? _platformFee$feeBps3 : 0, {
    accounts: {
      tokenSwapProgram: tokenSwapState.programId,
      tokenProgram: TOKEN_PROGRAM_ID,
      swap: tokenSwapState.address,
      authority: tokenSwapState.authority,
      userTransferAuthority: user,
      source: userSourceTokenAccountAddress,
      swapSource,
      swapDestination,
      destination: userDestinationTokenAccountAddress,
      poolMint: tokenSwapState.poolToken,
      poolFee: tokenSwapState.feeAccount
    },
    remainingAccounts: prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount)
  });
}
function createSenchaSwapInstruction(poolState, sourceMint, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user, amount, minimumOutAmount, platformFee) {
  var _platformFee$feeBps4;

  const [swapSource, swapDestination] = sourceMint.equals(poolState.token0Mint) ? [poolState.token0Reserves, poolState.token1Reserves] : [poolState.token1Reserves, poolState.token0Reserves];
  const [feesSource, feesDestination] = sourceMint.equals(poolState.token0Mint) ? [poolState.token0Fees, poolState.token1Fees] : [poolState.token1Fees, poolState.token0Fees];
  return JUPITER_PROGRAM.instruction.senchaExchange(amount ? new BN(amount) : amount, new BN(minimumOutAmount), (_platformFee$feeBps4 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps4 !== void 0 ? _platformFee$feeBps4 : 0, {
    accounts: {
      swapProgram: poolState.programId,
      tokenProgram: TOKEN_PROGRAM_ID,
      swap: poolState.ammId,
      userAuthority: user,
      inputUserAccount: userSourceTokenAccountAddress,
      inputTokenAccount: swapSource,
      inputFeesAccount: feesSource,
      outputUserAccount: userDestinationTokenAccountAddress,
      outputTokenAccount: swapDestination,
      outputFeesAccount: feesDestination
    },
    remainingAccounts: prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount)
  });
}
function createCropperSwapInstruction(poolState, sourceMint, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user, feeAccount, amount, minimumOutAmount, platformFee) {
  var _platformFee$feeBps5;

  const [swapSource, swapDestination] = sourceMint.equals(poolState.mintA) ? [poolState.tokenAAccount, poolState.tokenBAccount] : [poolState.tokenBAccount, poolState.tokenAAccount];
  return JUPITER_PROGRAM.instruction.cropperTokenSwap(amount ? new BN(amount) : amount, new BN(minimumOutAmount), (_platformFee$feeBps5 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps5 !== void 0 ? _platformFee$feeBps5 : 0, {
    accounts: {
      tokenSwapProgram: poolState.programId,
      tokenProgram: TOKEN_PROGRAM_ID,
      swap: poolState.ammId,
      swapState: CROPPER_STATE_ADDRESS,
      authority: poolState.authority,
      userTransferAuthority: user,
      source: userSourceTokenAccountAddress,
      swapSource,
      swapDestination,
      destination: userDestinationTokenAccountAddress,
      poolMint: poolState.poolMint,
      poolFee: feeAccount
    },
    remainingAccounts: prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount)
  });
}
function createRaydiumSwapInstruction(raydiumAmm, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user, amount, minimumOutAmount, platformFee) {
  var _platformFee$feeBps6;

  return JUPITER_PROGRAM.instruction.raydiumSwapV2(amount ? new BN(amount) : amount, new BN(minimumOutAmount), (_platformFee$feeBps6 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps6 !== void 0 ? _platformFee$feeBps6 : 0, {
    accounts: raydiumAmmToRaydiumSwap(raydiumAmm, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user),
    remainingAccounts: prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount)
  });
}
function createAldrinSwapInstruction(poolState, sourceMint, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user, amount, minimumOutAmount, platformFee) {
  var _platformFee$feeBps7;

  const [side, userBaseTokenAccount, userQuoteTokenAccount] = sourceMint.equals(poolState.baseTokenMint) ? [Side.Ask, userSourceTokenAccountAddress, userDestinationTokenAccountAddress] : [Side.Bid, userDestinationTokenAccountAddress, userSourceTokenAccountAddress];
  return JUPITER_PROGRAM.instruction.aldrinSwap(amount ? new BN(amount) : amount, new BN(minimumOutAmount), side, (_platformFee$feeBps7 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps7 !== void 0 ? _platformFee$feeBps7 : 0, {
    accounts: {
      swapProgram: ALDRIN_SWAP_PROGRAM_ID,
      pool: poolState.address,
      poolSigner: poolState.poolSigner,
      poolMint: poolState.poolMint,
      baseTokenVault: poolState.baseTokenVault,
      quoteTokenVault: poolState.quoteTokenVault,
      feePoolTokenAccount: poolState.feePoolTokenAccount,
      walletAuthority: user,
      userBaseTokenAccount,
      userQuoteTokenAccount,
      tokenProgram: TOKEN_PROGRAM_ID
    },
    remainingAccounts: prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount)
  });
}
function createAldrinV2SwapInstruction(poolState, sourceMint, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, curve, user, amount, minimumOutAmount, platformFee) {
  var _platformFee$feeBps8;

  const [side, userBaseTokenAccount, userQuoteTokenAccount] = sourceMint.equals(poolState.baseTokenMint) ? [Side.Ask, userSourceTokenAccountAddress, userDestinationTokenAccountAddress] : [Side.Bid, userDestinationTokenAccountAddress, userSourceTokenAccountAddress];
  return JUPITER_PROGRAM.instruction.aldrinV2Swap(amount ? new BN(amount) : amount, new BN(minimumOutAmount), side, (_platformFee$feeBps8 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps8 !== void 0 ? _platformFee$feeBps8 : 0, {
    accounts: {
      swapProgram: ALDRIN_SWAP_V2_PROGRAM_ID,
      pool: poolState.address,
      poolSigner: poolState.poolSigner,
      poolMint: poolState.poolMint,
      baseTokenVault: poolState.baseTokenVault,
      quoteTokenVault: poolState.quoteTokenVault,
      feePoolTokenAccount: poolState.feePoolTokenAccount,
      walletAuthority: user,
      userBaseTokenAccount,
      userQuoteTokenAccount,
      curve,
      tokenProgram: TOKEN_PROGRAM_ID
    },
    remainingAccounts: prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount)
  });
}
function createRiskCheckAndFeeInstruction(userDestinationTokenAccount, userTransferAuthority, minimumOutAmount, platformFee) {
  var _platformFee$feeBps9;

  const remainingAccounts = [];

  if (platformFee !== null && platformFee !== void 0 && platformFee.feeAccount) {
    remainingAccounts.push({
      pubkey: platformFee.feeAccount,
      isSigner: false,
      isWritable: true
    });
  }

  return JUPITER_PROGRAM.instruction.riskCheckAndFee(new BN(minimumOutAmount), (_platformFee$feeBps9 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps9 !== void 0 ? _platformFee$feeBps9 : 0, {
    accounts: {
      tokenLedger: TOKEN_LEDGER,
      userDestinationTokenAccount,
      userTransferAuthority,
      tokenProgram: TOKEN_PROGRAM_ID
    },
    remainingAccounts
  });
}
function createSetTokenLedgerInstruction(tokenAccountAddress) {
  return JUPITER_PROGRAM.instruction.setTokenLedger({
    accounts: {
      tokenLedger: TOKEN_LEDGER,
      tokenAccount: tokenAccountAddress
    }
  });
}
function createCreateTokenLedgerInstruction(user) {
  return JUPITER_PROGRAM.instruction.initializeTokenLedger({
    accounts: {
      tokenLedger: TOKEN_LEDGER,
      payer: user,
      systemProgram: SystemProgram.programId,
      rent: SYSVAR_RENT_PUBKEY
    }
  });
}
function createOpenOrdersInstruction(market, user) {
  const [openOrders] = findProgramAddressSync([Buffer.from('open_orders'), market.publicKey.toBuffer(), user.toBuffer()], JUPITER_PROGRAM_ID);
  const ix = JUPITER_PROGRAM.instruction.createOpenOrders({
    accounts: {
      openOrders,
      payer: user,
      dexProgram: market.programId,
      systemProgram: SystemProgram.programId,
      rent: SYSVAR_RENT_PUBKEY,
      market: market.publicKey
    }
  });
  return [openOrders, ix];
}

function saberPoolIntoSaberExchange(saberPool, sourceMintAddress, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user) {
  const feesTokenAccount = sourceMintAddress.equals(saberPool.state.tokenA.mint) ? saberPool.state.tokenB.adminFeeAccount : saberPool.state.tokenA.adminFeeAccount;
  const [inputTokenAccount, outputTokenAccount] = sourceMintAddress.equals(saberPool.state.tokenA.mint) ? [saberPool.state.tokenA.reserve, saberPool.state.tokenB.reserve] : [saberPool.state.tokenB.reserve, saberPool.state.tokenA.reserve];
  return {
    swapProgram: saberPool.config.swapProgramID,
    tokenProgram: TOKEN_PROGRAM_ID,
    swap: saberPool.config.swapAccount,
    swapAuthority: saberPool.config.authority,
    userAuthority: user,
    clock: SYSVAR_CLOCK_PUBKEY,
    inputUserAccount: userSourceTokenAccountAddress,
    inputTokenAccount,
    outputUserAccount: userDestinationTokenAccountAddress,
    outputTokenAccount,
    feesTokenAccount
  };
}

function createSaberExchangeInstruction(saberPool, inputMint, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user, amount, minimumOutAmount, platformFee) {
  var _platformFee$feeBps10;

  const remainingAccounts = prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount);
  return JUPITER_PROGRAM.instruction.saberExchange(amount ? new BN(amount) : amount, new BN(minimumOutAmount), (_platformFee$feeBps10 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps10 !== void 0 ? _platformFee$feeBps10 : 0, {
    accounts: saberPoolIntoSaberExchange(saberPool, inputMint, userSourceTokenAccountAddress, userDestinationTokenAccountAddress, user),
    remainingAccounts
  });
}
function createSaberAddDecimalsDepositInstruction(addDecimals, sourceTokenAccountAddress, destinationTokenAccountAddress, userTransferAuthority, amount, minimumOutAmount, platformFee) {
  var _platformFee$feeBps11;

  const remainingAccounts = prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount);
  return JUPITER_PROGRAM.instruction.saberAddDecimalsDeposit(amount ? new BN(amount) : amount, new BN(minimumOutAmount), (_platformFee$feeBps11 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps11 !== void 0 ? _platformFee$feeBps11 : 0, {
    accounts: {
      addDecimalsProgram: SABER_ADD_DECIMALS_PROGRAM_ID,
      wrapper: addDecimals.wrapper,
      wrapperMint: addDecimals.mint,
      wrapperUnderlyingTokens: addDecimals.wrapperUnderlyingTokens,
      owner: userTransferAuthority,
      userUnderlyingTokens: sourceTokenAccountAddress,
      userWrappedTokens: destinationTokenAccountAddress,
      tokenProgram: TOKEN_PROGRAM_ID
    },
    remainingAccounts
  });
}
function createSaberAddDecimalsWithdrawInstruction(addDecimals, sourceTokenAccountAddress, destinationTokenAccountAddress, userTransferAuthority, amount, minimumOutAmount, platformFee) {
  var _platformFee$feeBps12;

  const remainingAccounts = prepareRemainingAccounts(amount, platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeAccount);
  return JUPITER_PROGRAM.instruction.saberAddDecimalsWithdraw(amount ? new BN(amount) : amount, new BN(minimumOutAmount), (_platformFee$feeBps12 = platformFee === null || platformFee === void 0 ? void 0 : platformFee.feeBps) !== null && _platformFee$feeBps12 !== void 0 ? _platformFee$feeBps12 : 0, {
    accounts: {
      addDecimalsProgram: SABER_ADD_DECIMALS_PROGRAM_ID,
      wrapper: addDecimals.wrapper,
      wrapperMint: addDecimals.mint,
      wrapperUnderlyingTokens: addDecimals.wrapperUnderlyingTokens,
      owner: userTransferAuthority,
      userUnderlyingTokens: destinationTokenAccountAddress,
      userWrappedTokens: sourceTokenAccountAddress,
      tokenProgram: TOKEN_PROGRAM_ID
    },
    remainingAccounts
  });
}

function prepareRemainingAccounts(amount, feeAccount) {
  const remainingAccounts = [];

  if (amount === null) {
    remainingAccounts.push({
      pubkey: TOKEN_LEDGER,
      isSigner: false,
      isWritable: true
    });
  }

  if (feeAccount) {
    remainingAccounts.push({
      pubkey: feeAccount,
      isSigner: false,
      isWritable: true
    });
  }

  return remainingAccounts;
}

function getSaberWrappedDecimalsAmms() {
  return addDecimalsJson.map(addDecimalJson => {
    const addDecimals = {
      wrapper: new PublicKey(addDecimalJson.wrapper),
      underlying: new PublicKey(addDecimalJson.underlying),
      underlyingDecimals: addDecimalJson.underlyingDecimals,
      wrapperUnderlyingTokens: new PublicKey(addDecimalJson.wrapperUnderlyingTokens),
      mint: new PublicKey(addDecimalJson.mint),
      decimals: addDecimalJson.decimals
    };
    return new SaberAddDecimalsAmm(new WrappedToken(addDecimals));
  });
}
class WrappedToken {
  constructor(addDecimals) {
    this.addDecimals = void 0;
    this.addDecimals = addDecimals;
  }

  get multiplier() {
    return 10 ** (this.addDecimals.decimals - this.addDecimals.underlyingDecimals);
  }

  getOutputAmount(inputAmount, inputMint) {
    if (this.addDecimals.mint.equals(inputMint)) {
      // withdraw, so divide
      return this.calculateWithdrawOutputAmount(inputAmount);
    } else if (this.addDecimals.underlying.equals(inputMint)) {
      // deposit, so multiply
      return this.calculateDepositOutputAmount(inputAmount);
    }

    throw new Error(`unknown input token: ${inputMint.toString()}`);
  }

  calculateDepositOutputAmount(inputAmount) {
    return JSBI.multiply(JSBI.BigInt(inputAmount), JSBI.BigInt(this.multiplier));
  }

  calculateWithdrawOutputAmount(inputAmount) {
    return JSBI.divide(JSBI.BigInt(inputAmount), JSBI.BigInt(this.multiplier));
  }

} // This isn't technically an Amm but this the smoothest solution to allow its usage without a major refactor of the abstractions for now

class SaberAddDecimalsAmm {
  constructor(wrappedToken) {
    this.wrappedToken = void 0;
    this.label = 'Saber (Decimals)';
    this.wrappedToken = wrappedToken;
  }

  get id() {
    return this.wrappedToken.addDecimals.wrapper.toBase58();
  }

  getAccountsForUpdate() {
    return new Array();
  }

  update(_accountInfoMap) {}

  getQuote({
    sourceMint,
    amount
  }) {
    const outAmount = JSBI.toNumber(this.wrappedToken.getOutputAmount(amount, sourceMint));
    return {
      notEnoughLiquidity: false,
      inAmount: amount,
      outAmount,
      feeAmount: 0,
      feeMint: sourceMint.toBase58(),
      feePct: 0,
      priceImpactPct: 0
    };
  }

  createSwapInstructions({
    sourceMint,
    sourceTokenAccount,
    destinationTokenAccount,
    userTransferAuthority,
    amount,
    minimumOutAmount,
    platformFee
  }) {
    if (this.wrappedToken.addDecimals.underlying.equals(sourceMint)) {
      return [createSaberAddDecimalsDepositInstruction(this.wrappedToken.addDecimals, sourceTokenAccount, destinationTokenAccount, userTransferAuthority, amount, minimumOutAmount, platformFee)];
    } else {
      return [createSaberAddDecimalsWithdrawInstruction(this.wrappedToken.addDecimals, sourceTokenAccount, destinationTokenAccount, userTransferAuthority, amount, minimumOutAmount, platformFee)];
    }
  }

  get reserveTokenMints() {
    return [this.wrappedToken.addDecimals.underlying, this.wrappedToken.addDecimals.mint];
  }

}

function getTwoPermutations(array) {
  return array.reduce((acc, item) => {
    array.forEach(otherItem => {
      if (item !== otherItem) {
        acc.push([item, otherItem]);
      }
    });
    return acc;
  }, new Array());
}

const mapAddressToAccountInfos = (accountInfoMap, addresses) => {
  const accountInfos = addresses.map(address => {
    const accountInfo = accountInfoMap.get(address.toString());

    if (!accountInfo) {
      throw new Error(`Account info ${address.toBase58()} missing`);
    }

    return accountInfo;
  });
  return accountInfos;
};

// Only a few hardcoded pools for now, until we query the whole lot through api
const AMM_INFO_LAYOUT_V4 = /*#__PURE__*/struct([/*#__PURE__*/nu64('status'), /*#__PURE__*/nu64('nonce'), /*#__PURE__*/nu64('orderNum'), /*#__PURE__*/nu64('depth'), /*#__PURE__*/nu64('coinDecimals'), /*#__PURE__*/nu64('pcDecimals'), /*#__PURE__*/nu64('state'), /*#__PURE__*/nu64('resetFlag'), /*#__PURE__*/nu64('minSize'), /*#__PURE__*/nu64('volMaxCutRatio'), /*#__PURE__*/nu64('amountWaveRatio'), /*#__PURE__*/nu64('coinLotSize'), /*#__PURE__*/nu64('pcLotSize'), /*#__PURE__*/nu64('minPriceMultiplier'), /*#__PURE__*/nu64('maxPriceMultiplier'), /*#__PURE__*/nu64('systemDecimalsValue'),
/*#__PURE__*/
// Fees
nu64('minSeparateNumerator'), /*#__PURE__*/nu64('minSeparateDenominator'), /*#__PURE__*/nu64('tradeFeeNumerator'), /*#__PURE__*/nu64('tradeFeeDenominator'), /*#__PURE__*/nu64('pnlNumerator'), /*#__PURE__*/nu64('pnlDenominator'), /*#__PURE__*/nu64('swapFeeNumerator'), /*#__PURE__*/nu64('swapFeeDenominator'),
/*#__PURE__*/
// OutPutData
nu64('needTakePnlCoin'), /*#__PURE__*/nu64('needTakePnlPc'), /*#__PURE__*/nu64('totalPnlPc'), /*#__PURE__*/nu64('totalPnlCoin'), /*#__PURE__*/uint128('poolTotalDepositPc'), /*#__PURE__*/uint128('poolTotalDepositCoin'), /*#__PURE__*/uint128('swapCoinInAmount'), /*#__PURE__*/uint128('swapPcOutAmount'), /*#__PURE__*/nu64('swapCoin2PcFee'), /*#__PURE__*/uint128('swapPcInAmount'), /*#__PURE__*/uint128('swapCoinOutAmount'), /*#__PURE__*/nu64('swapPc2CoinFee'), /*#__PURE__*/publicKey('poolCoinTokenAccount'), /*#__PURE__*/publicKey('poolPcTokenAccount'), /*#__PURE__*/publicKey('coinMintAddress'), /*#__PURE__*/publicKey('pcMintAddress'), /*#__PURE__*/publicKey('lpMintAddress'), /*#__PURE__*/publicKey('ammOpenOrders'), /*#__PURE__*/publicKey('serumMarket'), /*#__PURE__*/publicKey('serumProgramId'), /*#__PURE__*/publicKey('ammTargetOrders'), /*#__PURE__*/publicKey('poolWithdrawQueue'), /*#__PURE__*/publicKey('poolTempLpTokenAccount'), /*#__PURE__*/publicKey('ammOwner'), /*#__PURE__*/publicKey('pnlOwner')]);

// https://github.com/raydium-io/raydium-ui/blob/4048286f79fc4b71c3ffbfd9095470ab0c7d3862/src/utils/liquidity.ts#L30-L82
class RaydiumAmm {
  constructor(ammId, ammAccountInfo) {
    this.ammId = void 0;
    this.ammAccountInfo = void 0;
    this.label = 'Raydium';
    this.coinMint = void 0;
    this.pcMint = void 0;
    this.status = void 0;
    this.serumProgramId = void 0;
    this.serumMarket = void 0;
    this.ammOpenOrders = void 0;
    this.ammTargetOrders = void 0;
    this.poolCoinTokenAccount = void 0;
    this.poolPcTokenAccount = void 0;
    this.serumMarketKeys = void 0;
    this.coinReserve = void 0;
    this.pcReserve = void 0;
    this.swapFeeNumerator = void 0;
    this.swapFeeDenominator = void 0;
    this.ammId = ammId;
    this.ammAccountInfo = ammAccountInfo;
    const decoded = AMM_INFO_LAYOUT_V4.decode(ammAccountInfo.data);
    this.status = decoded.status;
    this.coinMint = new PublicKey(decoded.coinMintAddress);
    this.pcMint = new PublicKey(decoded.pcMintAddress);
    this.poolCoinTokenAccount = new PublicKey(decoded.poolCoinTokenAccount);
    this.poolPcTokenAccount = new PublicKey(decoded.poolPcTokenAccount);
    this.swapFeeNumerator = new u64(decoded.swapFeeNumerator);
    this.swapFeeDenominator = new u64(decoded.swapFeeDenominator);
    this.serumProgramId = new PublicKey(decoded.serumProgramId);
    this.serumMarket = new PublicKey(decoded.serumMarket);
    this.ammOpenOrders = new PublicKey(decoded.ammOpenOrders);
    this.ammTargetOrders = new PublicKey(decoded.ammTargetOrders);
  }

  get id() {
    return this.ammId.toBase58();
  }

  getAccountsForUpdate() {
    return [this.ammId, this.poolCoinTokenAccount, this.poolPcTokenAccount, this.ammOpenOrders, this.serumMarket];
  }

  update(accountInfoMap) {
    const [ammAccountInfo, poolCoinTokenAccountInfo, poolPcTokenAccountInfo, ammOpenOrdersAccountInfo, serumMarketMarketInfo] = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());
    this.ammAccountInfo = ammAccountInfo;
    const [coinAmount, pcAmount] = [RaydiumAmm.tokenAmountAccessor(poolCoinTokenAccountInfo), RaydiumAmm.tokenAmountAccessor(poolPcTokenAccountInfo)];
    const openOrders = OpenOrders.fromAccountInfo(this.ammOpenOrders, ammOpenOrdersAccountInfo, ammOpenOrdersAccountInfo.owner); // TODO: Possibly better design is to have this passed to the ctor, so it isn't an independant instruction

    const decodedMarket = Market.getLayout(this.serumProgramId).decode(serumMarketMarketInfo.data);
    const serumVaultSigner = createProgramAddressSync([this.serumMarket.toBuffer(), decodedMarket.vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], this.serumProgramId);
    this.serumMarketKeys = {
      serumBids: decodedMarket.bids,
      serumAsks: decodedMarket.asks,
      serumEventQueue: decodedMarket.eventQueue,
      serumCoinVaultAccount: decodedMarket.baseVault,
      serumPcVaultAccount: decodedMarket.quoteVault,
      serumVaultSigner: serumVaultSigner
    };
    const decoded = AMM_INFO_LAYOUT_V4.decode(this.ammAccountInfo.data);
    this.coinReserve = coinAmount.add(openOrders.baseTokenTotal).sub(new u64(String(decoded.needTakePnlCoin)));
    this.pcReserve = pcAmount.add(openOrders.quoteTokenTotal).sub(new u64(String(decoded.needTakePnlPc)));
  }

  static tokenAmountAccessor(tokenAccountInfo) {
    return u64.fromBuffer(tokenAccountInfo.data.slice(64, 64 + 8));
  }

  getQuote({
    sourceMint,
    amount
  }) {
    if (!this.coinReserve || !this.pcReserve) {
      throw new Error('Pool token accounts balances not refreshed or empty');
    }

    const {
      coinReserve,
      pcReserve
    } = this;
    const [inputReserve, outputReserve] = this.coinMint.equals(sourceMint) ? [coinReserve, pcReserve] : [pcReserve, coinReserve];
    const inAmountBN = new BN$1(String(amount));
    const feeAmount = inAmountBN.mul(this.swapFeeNumerator).div(this.swapFeeDenominator);
    const inAmountAfterFee = inAmountBN.sub(feeAmount);
    const numerator = inAmountAfterFee.mul(outputReserve);
    const denominator = inputReserve.add(inAmountAfterFee);
    const outAmountWithoutPriceImpact = inAmountAfterFee.mul(outputReserve).div(inputReserve);
    const outAmountBN = numerator.div(denominator);
    const outAmount = Number(outAmountBN.toString());
    return {
      notEnoughLiquidity: false,
      inAmount: amount,
      outAmount,
      feeAmount: Number(feeAmount.toString()),
      feeMint: sourceMint.toBase58(),
      feePct: Number(new Decimal(this.swapFeeNumerator.toString()).div(this.swapFeeDenominator.toString()).toString()),
      priceImpactPct: Number(new Decimal(outAmountWithoutPriceImpact.sub(outAmountBN).toString()).div(outAmountWithoutPriceImpact.toString()).toString())
    };
  }

  createSwapInstructions({
    sourceTokenAccount,
    destinationTokenAccount,
    userTransferAuthority,
    amount,
    minimumOutAmount,
    platformFee
  }) {
    return [createRaydiumSwapInstruction(this, sourceTokenAccount, destinationTokenAccount, userTransferAuthority, amount, minimumOutAmount, platformFee)];
  }

  get reserveTokenMints() {
    return [this.coinMint, this.pcMint];
  }

}

const TAKER_FEE_PCT = 0.0004;
const STABLE_TAKER_FEE_PCT = 0.0001; // Stable markets are hardcoded in the program

const STABLE_MARKET_ADDRESSES = ['77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS', '5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z' // mSOL/SOL
]; // Provides swap like out amount, with slippage and corresponding minimum amount out

function getOutAmountMeta({
  market,
  asks,
  bids,
  fromAmount,
  fromMint,
  toMint
}) {
  const takerFeePct = STABLE_MARKET_ADDRESSES.includes(market.address.toBase58()) ? STABLE_TAKER_FEE_PCT : TAKER_FEE_PCT;

  if (fromMint.equals(market.quoteMintAddress) && toMint.equals(market.baseMintAddress)) {
    // buy
    return forecastBuy(market, asks, fromAmount, takerFeePct);
  } else {
    return forecastSell(market, bids, fromAmount, takerFeePct);
  }
}
function forecastBuy(market, orderBook, pcIn, takerFeePct) {
  let coinOut = 0;
  let bestPrice = 0;
  let worstPrice = 0; // total base price

  let totalCost = 0;
  let totalCoins = 0; // Serum buy order take fee in quote tokens

  let availablePc = pcIn / (1 + takerFeePct);
  const baseSizeLots = market.baseSizeLotsToNumber(new BN$1(1));
  const quoteSizeLots = market.quoteSizeLotsToNumber(new BN$1(1));

  for (const order of orderBook.items(false)) {
    const price = market.priceLotsToNumber(order.priceLots);
    const size = market.baseSizeLotsToNumber(order.sizeLots);
    totalCoins += size;

    if (!bestPrice && price !== 0) {
      bestPrice = price;
    }

    worstPrice = price;
    const orderCoinAmount = order.sizeLots.toNumber() * baseSizeLots;
    const orderPcAmount = order.sizeLots.toNumber() * order.priceLots.toNumber() * quoteSizeLots;
    const lotPrice = order.priceLots.toNumber() * quoteSizeLots;

    if (orderPcAmount >= availablePc) {
      const numberLotsCanBuy = Math.floor(availablePc / lotPrice);
      totalCost += numberLotsCanBuy * lotPrice;
      coinOut += numberLotsCanBuy * baseSizeLots;
      availablePc -= numberLotsCanBuy * lotPrice;
      break;
    } else {
      totalCost += order.sizeLots.toNumber() * lotPrice;
      coinOut += orderCoinAmount;
      availablePc -= orderPcAmount;
    }
  }

  const priceImpactPct = bestPrice ? (worstPrice - bestPrice) / bestPrice : 0;
  return {
    side: 'buy',
    notEnoughLiquidity: totalCoins <= coinOut,
    minimum: {
      in: Math.ceil(baseSizeLots * bestPrice * (1 + takerFeePct)),
      out: baseSizeLots
    },
    inAmount: Math.ceil(totalCost * (1 + takerFeePct)),
    outAmount: coinOut,
    feeAmount: Math.round(totalCost * takerFeePct),
    priceImpactPct,
    feePct: takerFeePct
  };
}
function forecastSell(market, orderBook, coinIn, takerFeePct) {
  let pcOut = 0;
  let bestPrice = 0;
  let worstPrice = 0;
  let availableCoin = coinIn;
  let inAmount = 0;
  const baseSizeLots = market.baseSizeLotsToNumber(new BN$1(1));
  const quoteSizeLots = market.quoteSizeLotsToNumber(new BN$1(1));

  for (const order of orderBook.items(true)) {
    const price = market.priceLotsToNumber(order.priceLots);

    if (!bestPrice && price !== 0) {
      bestPrice = price;
    }

    worstPrice = price;
    const orderCoinAmount = order.sizeLots.toNumber() * baseSizeLots;
    const orderPcAmount = order.sizeLots.toNumber() * order.priceLots.toNumber() * quoteSizeLots;

    if (availableCoin <= orderCoinAmount) {
      const numberLotsCanSell = Math.floor(availableCoin / baseSizeLots);
      pcOut += numberLotsCanSell * order.priceLots.toNumber() * quoteSizeLots;
      availableCoin = 0;
      inAmount += numberLotsCanSell * baseSizeLots;
      break;
    } else {
      pcOut += orderPcAmount;
      availableCoin -= orderCoinAmount;
      inAmount += orderCoinAmount;
    }
  }

  pcOut = Math.floor(pcOut * (1 - takerFeePct));
  const priceImpactPct = bestPrice ? (bestPrice - worstPrice) / bestPrice : 0;
  return {
    side: 'sell',
    notEnoughLiquidity: availableCoin > 0,
    minimum: {
      in: baseSizeLots,
      out: Math.ceil(baseSizeLots * bestPrice * (1 - takerFeePct))
    },
    inAmount: inAmount,
    outAmount: pcOut,
    feeAmount: Math.round(pcOut * takerFeePct),
    priceImpactPct,
    feePct: takerFeePct
  };
}

class SerumAmm {
  constructor(market) {
    this.market = void 0;
    this.label = 'Serum';
    this.orderbooks = void 0;
    this.market = market;
  }

  get id() {
    return this.market.address.toBase58();
  }

  getAccountsForUpdate() {
    return [this.market.asksAddress, this.market.bidsAddress];
  }

  update(accountInfoMap) {
    const [asksAccountInfo, bidsAccountInfo] = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());
    const asks = Orderbook.decode(this.market, asksAccountInfo.data);
    const bids = Orderbook.decode(this.market, bidsAccountInfo.data);
    this.orderbooks = {
      asks,
      bids
    };
  }

  getQuote({
    sourceMint,
    destinationMint,
    amount
  }) {
    if (!this.orderbooks) {
      throw new Error('Failed to find orderbooks');
    }

    const outAmountMeta = getOutAmountMeta({
      market: this.market,
      asks: this.orderbooks.asks,
      bids: this.orderbooks.bids,
      fromMint: sourceMint,
      toMint: destinationMint,
      fromAmount: amount
    });
    return {
      notEnoughLiquidity: outAmountMeta.notEnoughLiquidity,
      minInAmount: outAmountMeta.minimum.in,
      minOutAmount: outAmountMeta.minimum.out,
      inAmount: outAmountMeta.inAmount,
      outAmount: outAmountMeta.outAmount,
      feeAmount: outAmountMeta.feeAmount,
      feeMint: this.market.quoteMintAddress.toBase58(),
      feePct: outAmountMeta.feePct,
      priceImpactPct: outAmountMeta.priceImpactPct
    };
  }

  createSwapInstructions({
    sourceMint,
    sourceTokenAccount,
    destinationTokenAccount,
    userTransferAuthority,
    amount,
    minimumOutAmount,
    openOrdersAddress,
    platformFee,
    quoteMintToReferrer
  }) {
    if (!openOrdersAddress) {
      throw new Error('Missing open orders');
    }

    return [createSerumSwapInstruction(this.market, sourceMint, openOrdersAddress, sourceTokenAccount, destinationTokenAccount, userTransferAuthority, amount, minimumOutAmount, platformFee, quoteMintToReferrer === null || quoteMintToReferrer === void 0 ? void 0 : quoteMintToReferrer.get(this.market.quoteMintAddress.toBase58()))];
  }

  get reserveTokenMints() {
    return [this.market.baseMintAddress, this.market.quoteMintAddress];
  }

}

function isSplitSupported(firstAmm, secondAmm) {
  if (firstAmm instanceof SerumAmm && secondAmm instanceof RaydiumAmm || firstAmm instanceof RaydiumAmm && secondAmm instanceof SerumAmm || firstAmm instanceof SerumAmm && secondAmm instanceof SerumAmm) {
    return false;
  }

  return true;
}

function requiresSplitSetup(firstAmm, secondAmm) {
  if (firstAmm instanceof RaydiumAmm || secondAmm instanceof RaydiumAmm) {
    return true;
  } else if (firstAmm instanceof SerumAmm && secondAmm instanceof SerumAmm) {
    return true;
  }

  return false;
} // Create an iteration to quote with a stepped split


class SplitTradeAmm {
  constructor(firstAmm, secondAmm, reserveTokenMints) {
    this.firstAmm = void 0;
    this.secondAmm = void 0;
    this.reserveTokenMints = void 0;
    this.shouldSplitSetup = void 0;
    this.market = void 0;
    this.portion1 = 0;
    this.portion2 = 0;
    this.firstAmm = firstAmm;
    this.secondAmm = secondAmm;
    this.reserveTokenMints = reserveTokenMints;
    this.shouldSplitSetup = requiresSplitSetup(firstAmm, secondAmm);
    this.market = firstAmm instanceof SerumAmm ? firstAmm.market : secondAmm instanceof SerumAmm ? secondAmm.market : null;
  }

  static create(firstAmm, secondAmm) {
    if (!isSplitSupported(firstAmm, secondAmm)) return;
    const firstAmmTwoPermutations = getTwoPermutations(firstAmm.reserveTokenMints);
    const secondAmmTwoPermutations = getTwoPermutations(secondAmm.reserveTokenMints);

    for (const firstAmmTwoPermutation of firstAmmTwoPermutations) {
      for (const secondAmmTwoPermutation of secondAmmTwoPermutations) {
        if (firstAmmTwoPermutation.every((value, index) => value.equals(secondAmmTwoPermutation[index]))) {
          return new SplitTradeAmm(firstAmm, secondAmm, firstAmmTwoPermutation);
        }
      }
    }
  }

  get id() {
    return `${this.firstAmm.id}-${this.secondAmm.id}`;
  }

  get label() {
    const labelWithPortions = [{
      label: this.firstAmm.label,
      portion: this.portion1
    }, {
      label: this.secondAmm.label,
      portion: this.portion2
    }].sort((a, b) => b.portion - a.portion);
    return labelWithPortions.map(({
      label,
      portion
    }) => `${label} (${portion}%)`).join(' + ');
  }

  getAccountsForUpdate() {
    return [];
  }

  update(_accountInfoMap) {// Underlying amms are updated
  }

  getQuote(quoteParams) {
    var _firstQuote$minInAmou, _secondQuote$minInAmo, _firstQuote$minOutAmo, _secondQuote$minOutAm;

    const sourceMintString = quoteParams.sourceMint.toBase58();
    const amount = quoteParams.amount; // Portion in % directly to please the UI

    let bestSolution = {
      outAmount: 0,
      portion: 0,
      firstQuote: undefined,
      secondQuote: undefined
    }; // Increase portion until 100

    for (let p = 100; p -= 5; p > 0) {
      const firstAmount = Math.floor(amount * p / 100);
      const secondAmount = amount - firstAmount;
      const firstQuote = this.firstAmm.getQuote({ ...quoteParams,
        amount: firstAmount
      });
      const secondQuote = this.secondAmm.getQuote({ ...quoteParams,
        amount: secondAmount
      });
      const outAmount = firstQuote.outAmount + secondQuote.outAmount;

      if (outAmount < bestSolution.outAmount) {
        break;
      }

      bestSolution = {
        outAmount,
        portion: p,
        firstQuote,
        secondQuote
      };
    }

    if (!bestSolution.firstQuote || !bestSolution.secondQuote) {
      throw new Error('Unreachable: There was no better solution than getting 0 outAmount');
    }

    const {
      outAmount,
      portion,
      firstQuote,
      secondQuote
    } = bestSolution;
    const portion1 = portion;
    const portion2 = 100 - portion1; // For UI display

    this.portion1 = portion1;
    this.portion2 = portion2;
    let firstAmmFee = {
      amount: firstQuote.feeAmount,
      mint: firstQuote.feeMint
    };
    let secondAmmFee = {
      amount: secondQuote.feeAmount,
      mint: secondQuote.feeMint
    };

    if (firstAmmFee.mint !== secondAmmFee.mint) {
      // Then we convert destinationMint fee into a sourceMint, to please the current data structure
      // This will lead to inexact fees but this doesn't affect the user minimum out amount
      if (firstAmmFee.mint !== sourceMintString) {
        firstAmmFee = {
          amount: Math.floor(firstAmmFee.amount * amount * portion1 / 100 / bestSolution.outAmount),
          mint: sourceMintString
        };
      }

      if (secondAmmFee.mint !== sourceMintString) {
        secondAmmFee = {
          amount: Math.floor(secondAmmFee.amount * amount * portion2 / 100 / bestSolution.outAmount),
          mint: sourceMintString
        };
      }
    }

    const feePct = (portion1 * firstQuote.feePct + portion2 * secondQuote.feePct) / 100;
    const priceImpactPct = (portion1 * firstQuote.priceImpactPct + portion2 * secondQuote.priceImpactPct) / 100; // Not sure about the relevance on minInAmount and minOutAmount in this case

    const minInAmount = firstQuote.minInAmount || secondQuote.minInAmount ? ((_firstQuote$minInAmou = firstQuote.minInAmount) !== null && _firstQuote$minInAmou !== void 0 ? _firstQuote$minInAmou : 0) + ((_secondQuote$minInAmo = secondQuote.minInAmount) !== null && _secondQuote$minInAmo !== void 0 ? _secondQuote$minInAmo : 0) : undefined;
    const minOutAmount = firstQuote.minOutAmount || secondQuote.minOutAmount ? ((_firstQuote$minOutAmo = firstQuote.minOutAmount) !== null && _firstQuote$minOutAmo !== void 0 ? _firstQuote$minOutAmo : 0) + ((_secondQuote$minOutAm = secondQuote.minOutAmount) !== null && _secondQuote$minOutAm !== void 0 ? _secondQuote$minOutAm : 0) : undefined;
    return {
      notEnoughLiquidity: false,
      inAmount: quoteParams.amount,
      outAmount: outAmount,
      minInAmount,
      minOutAmount,
      feeAmount: firstAmmFee.amount + secondAmmFee.amount,
      feeMint: firstAmmFee.mint,
      feePct,
      priceImpactPct
    };
  }

  createSwapInstructions(swapParams) {
    const amount = swapParams.amount; // Cannot be null!
    // We rely on the fact that this.portion1 is set, what if it isn't?

    const firstAmount = Math.floor(amount * this.portion1 / 100);
    const secondAmount = amount - firstAmount;
    return [createSetTokenLedgerInstruction(swapParams.destinationTokenAccount), ...this.firstAmm.createSwapInstructions({ ...swapParams,
      amount: firstAmount,
      minimumOutAmount: 0,
      platformFee: undefined
    }), ...this.secondAmm.createSwapInstructions({ ...swapParams,
      amount: secondAmount,
      minimumOutAmount: 0,
      platformFee: undefined
    }), createRiskCheckAndFeeInstruction(swapParams.destinationTokenAccount, swapParams.userTransferAuthority, swapParams.minimumOutAmount, swapParams.platformFee)];
  }

}

const isValidRoute = (ammA, ammB) => {
  // don't show decimal as input or output
  if (ammA instanceof SaberAddDecimalsAmm && ammB instanceof SaberAddDecimalsAmm) {
    return false;
  } else if (ammA instanceof SplitTradeAmm || ammB instanceof SplitTradeAmm) {
    return false;
  }

  return true;
};

const deserializeAccount = data => {
  if (data == undefined || data.length == 0) {
    return undefined;
  }

  const accountInfo = AccountLayout.decode(data);
  accountInfo.mint = new PublicKey(accountInfo.mint);
  accountInfo.owner = new PublicKey(accountInfo.owner);
  accountInfo.amount = u64.fromBuffer(accountInfo.amount);

  if (accountInfo.delegateOption === 0) {
    accountInfo.delegate = null;
    accountInfo.delegatedAmount = new u64(0);
  } else {
    accountInfo.delegate = new PublicKey(accountInfo.delegate);
    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);
  }

  accountInfo.isInitialized = accountInfo.state !== 0;
  accountInfo.isFrozen = accountInfo.state === 2;

  if (accountInfo.isNativeOption === 1) {
    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);
    accountInfo.isNative = true;
  } else {
    accountInfo.rentExemptReserve = null;
    accountInfo.isNative = false;
  }

  if (accountInfo.closeAuthorityOption === 0) {
    accountInfo.closeAuthority = null;
  } else {
    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);
  }

  return accountInfo;
};

class SaberAmm {
  constructor(stableSwap) {
    this.stableSwap = void 0;
    this.label = 'Saber';
    this.tokenAccounts = void 0;
    this.calculator = void 0;
    this.stableSwap = stableSwap;
  }

  get id() {
    return this.stableSwap.config.swapAccount.toBase58();
  }

  getAccountsForUpdate() {
    return [this.stableSwap.state.tokenA.reserve, this.stableSwap.state.tokenB.reserve];
  }

  update(accountInfoMap) {
    let tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());
    this.tokenAccounts = tokenAccountInfos.map(info => {
      const tokenAccount = deserializeAccount(info.data);

      if (!tokenAccount) {
        throw new Error('Invalid token account data');
      }

      return tokenAccount;
    });
    this.calculator = new Stable(JSBI.BigInt(this.stableSwap.state.targetAmpFactor.toString()), this.tokenAccounts.map(tokenAccount => {
      return JSBI.BigInt(tokenAccount.amount.toString());
    }), [ONE, ONE], // TODO: How to get the token decimal?
    new Fraction(this.stableSwap.state.fees.trade.numerator, this.stableSwap.state.fees.trade.denominator));
  }

  getQuote({
    sourceMint,
    destinationMint,
    amount
  }) {
    if (!this.tokenAccounts) {
      throw new Error('Unable to fetch accounts for specified tokens.');
    }

    if (this.calculator === undefined) {
      throw new Error('Unable to fetch accounts for Curve calculator.');
    }

    const feePct = new Decimal(this.stableSwap.state.fees.trade.asFraction.toFixed(4));
    const [inputIndex, outputIndex] = this.tokenAccounts[0].mint.equals(sourceMint) ? [0, 1] : [1, 0];
    const result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, inputIndex, outputIndex);
    return {
      notEnoughLiquidity: false,
      inAmount: amount,
      outAmount: JSBI.toNumber(result.expectedOutputAmount),
      feeAmount: JSBI.toNumber(result.fees),
      feeMint: destinationMint.toBase58(),
      feePct: feePct.toNumber(),
      priceImpactPct: result.priceImpact.toNumber()
    };
  }

  createSwapInstructions({
    sourceMint,
    sourceTokenAccount,
    destinationTokenAccount,
    userTransferAuthority,
    amount,
    minimumOutAmount,
    platformFee
  }) {
    // The input or output might require the magic wrapping
    return [createSaberExchangeInstruction(this.stableSwap, sourceMint, sourceTokenAccount, destinationTokenAccount, userTransferAuthority, amount, minimumOutAmount, platformFee)];
  }

  get reserveTokenMints() {
    return [this.stableSwap.state.tokenA.mint, this.stableSwap.state.tokenB.mint];
  }

}

const ZERO = /*#__PURE__*/new u64(0);
class Percentage {
  constructor(numerator, denominator) {
    this.numerator = void 0;
    this.denominator = void 0;

    this.toString = () => {
      return `${this.numerator.toString()}/${this.denominator.toString()}`;
    };

    this.numerator = numerator;
    this.denominator = denominator;
  }

  static fromDecimal(number) {
    return Percentage.fromFraction(number.toDecimalPlaces(1).mul(10).toNumber(), 1000);
  }

  static fromFraction(numerator, denominator) {
    const num = typeof numerator === 'number' ? new u64(numerator.toString()) : numerator;
    const denom = typeof denominator === 'number' ? new u64(denominator.toString()) : denominator;
    return new Percentage(num, denom);
  }

  toDecimal() {
    if (this.denominator.eq(ZERO)) {
      return new Decimal(0);
    }

    return new Decimal(this.numerator.toString()).div(new Decimal(this.denominator.toString()));
  }

  add(p2) {
    const denomGcd = this.denominator.gcd(p2.denominator);
    const denomLcm = this.denominator.div(denomGcd).mul(p2.denominator);
    const p1DenomAdjustment = denomLcm.div(this.denominator);
    const p2DenomAdjustment = denomLcm.div(p2.denominator);
    const p1NumeratorAdjusted = this.numerator.mul(p1DenomAdjustment);
    const p2NumeratorAdjusted = p2.numerator.mul(p2DenomAdjustment);
    const newNumerator = p1NumeratorAdjusted.add(p2NumeratorAdjusted);
    return new Percentage(new u64(newNumerator.toString()), new u64(denomLcm.toString()));
  }

}

const FEES_LAYOUT = /*#__PURE__*/struct([/*#__PURE__*/uint64('tradeFeeNumerator'), /*#__PURE__*/uint64('tradeFeeDenominator'), /*#__PURE__*/uint64('ownerTradeFeeNumerator'), /*#__PURE__*/uint64('ownerTradeFeeDenominator'), /*#__PURE__*/uint64('ownerWithdrawFeeNumerator'), /*#__PURE__*/uint64('ownerWithdrawFeeDenominator')], 'fees');
const POOL_FIELDS_COMMON = [/*#__PURE__*/blob(8, 'padding'), /*#__PURE__*/publicKey('lpTokenFreezeVault'), /*#__PURE__*/publicKey('poolMint'), /*#__PURE__*/publicKey('baseTokenVault'), /*#__PURE__*/publicKey('baseTokenMint'), /*#__PURE__*/publicKey('quoteTokenVault'), /*#__PURE__*/publicKey('quoteTokenMint'), /*#__PURE__*/publicKey('poolSigner'), /*#__PURE__*/u8('poolSignerNonce'), /*#__PURE__*/publicKey('authority'), /*#__PURE__*/publicKey('initializerAccount'), /*#__PURE__*/publicKey('feeBaseAccount'), /*#__PURE__*/publicKey('feeQuoteAccount'), /*#__PURE__*/publicKey('feePoolTokenAccount'), FEES_LAYOUT];
const POOL_LAYOUT = /*#__PURE__*/struct(POOL_FIELDS_COMMON);
const POOL_V2_LAYOUT = /*#__PURE__*/struct([...POOL_FIELDS_COMMON, /*#__PURE__*/u8('curveType'), /*#__PURE__*/publicKey('curve')]);
const STABLE_CURVE_LAYOUT = /*#__PURE__*/struct([/*#__PURE__*/blob(8, 'padding'), /*#__PURE__*/uint64('amp')]);
function accountInfoToAldrinPoolState(address, accountInfo) {
  const isV2 = accountInfo.owner.equals(ALDRIN_SWAP_V2_PROGRAM_ID) ? true : false;
  const decoded = (isV2 ? POOL_V2_LAYOUT : POOL_LAYOUT).decode(accountInfo.data);
  const curveObject = 'curveType' in decoded ? {
    curveType: decoded.curveType,
    curve: decoded.curve
  } : {};
  return {
    isV2,
    address,
    poolMint: decoded.poolMint,
    baseTokenVault: decoded.baseTokenVault,
    baseTokenMint: decoded.baseTokenMint,
    quoteTokenVault: decoded.quoteTokenVault,
    quoteTokenMint: decoded.quoteTokenMint,
    poolSigner: decoded.poolSigner,
    feeBaseAccount: decoded.feeBaseAccount,
    feeQuoteAccount: decoded.feeQuoteAccount,
    feePoolTokenAccount: decoded.feePoolTokenAccount,
    fees: {
      traderFee: Percentage.fromFraction(decoded.fees.tradeFeeNumerator, decoded.fees.tradeFeeDenominator),
      ownerFee: Percentage.fromFraction(decoded.fees.ownerTradeFeeNumerator, decoded.fees.ownerTradeFeeDenominator)
    },
    ...curveObject
  };
}

class AldrinAmm {
  constructor(address, accountInfo, params = {}) {
    this.params = void 0;
    this.label = 'Aldrin';
    this.poolState = void 0;
    this.tokenAccounts = [];
    this.calculator = void 0;
    this.params = params;
    this.poolState = accountInfoToAldrinPoolState(address, accountInfo);
  }

  static decodeStableCurveAmp(accountInfo) {
    const {
      amp
    } = STABLE_CURVE_LAYOUT.decode(accountInfo.data);
    return amp.toNumber() * 2; // times two for their AMP, dont ask me why, it is what it is
  }

  get id() {
    return this.poolState.address.toBase58();
  }

  getAccountsForUpdate() {
    return [this.poolState.quoteTokenVault, this.poolState.baseTokenVault];
  }

  update(accountInfoMap) {
    const tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());
    this.tokenAccounts = tokenAccountInfos.map(info => {
      const tokenAccount = deserializeAccount(info.data);

      if (!tokenAccount) {
        throw new Error('Invalid token account');
      }

      return tokenAccount;
    });

    if (!this.poolState.curveType) {
      this.calculator = new TokenSwapConstantProduct(this.tokenAccounts.map(tokenAccount => {
        return JSBI.BigInt(tokenAccount.amount.toString());
      }), new Fraction(JSBI.BigInt(this.poolState.fees.traderFee.numerator.toString()), JSBI.BigInt(this.poolState.fees.traderFee.denominator.toString())), new Fraction(JSBI.BigInt(this.poolState.fees.ownerFee.numerator.toString()), JSBI.BigInt(this.poolState.fees.ownerFee.denominator.toString())));
    } else if (this.poolState.curveType === 1) {
      const {
        amp
      } = this.params;

      if (!amp) {
        throw new Error('Amp is required for a stable curve');
      }

      this.calculator = new TokenSwapStable(JSBI.BigInt(amp), this.tokenAccounts.map(tokenAccount => {
        return JSBI.BigInt(tokenAccount.amount.toString());
      }), new Fraction(JSBI.BigInt(this.poolState.fees.traderFee.numerator.toString()), JSBI.BigInt(this.poolState.fees.traderFee.denominator.toString())), new Fraction(JSBI.BigInt(this.poolState.fees.ownerFee.numerator.toString()), JSBI.BigInt(this.poolState.fees.ownerFee.denominator.toString())));
    }
  }

  getQuote({
    sourceMint,
    amount
  }) {
    if (this.tokenAccounts.length === 0) {
      throw new Error('Unable to fetch accounts for specified tokens.');
    }

    if (this.calculator === undefined) {
      throw new Error('Unable to fetch accounts for Curve calculator.');
    }

    let feePct = new Decimal(this.poolState.fees.traderFee.numerator.toString()).div(this.poolState.fees.traderFee.denominator.toString()).add(new Decimal(this.poolState.fees.ownerFee.numerator.toString()).div(this.poolState.fees.ownerFee.denominator.toString()));
    const outputIndex = this.tokenAccounts[0].mint.equals(sourceMint) ? 1 : 0;
    let result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, outputIndex);
    return {
      notEnoughLiquidity: false,
      inAmount: amount,
      outAmount: JSBI.toNumber(result.expectedOutputAmount),
      feeAmount: JSBI.toNumber(result.fees),
      feeMint: sourceMint.toBase58(),
      feePct: feePct.toNumber(),
      priceImpactPct: result.priceImpact.toNumber()
    };
  }

  createSwapInstructions({
    sourceMint,
    sourceTokenAccount,
    destinationTokenAccount,
    userTransferAuthority,
    amount,
    minimumOutAmount,
    platformFee
  }) {
    if (this.poolState.isV2) {
      if (!this.poolState.curve) {
        throw new Error('Unable to fetch curve account.');
      }

      return [createAldrinV2SwapInstruction(this.poolState, sourceMint, sourceTokenAccount, destinationTokenAccount, this.poolState.curve, userTransferAuthority, amount, minimumOutAmount, platformFee)];
    }

    return [createAldrinSwapInstruction(this.poolState, sourceMint, sourceTokenAccount, destinationTokenAccount, userTransferAuthority, amount, minimumOutAmount, platformFee)];
  }

  get reserveTokenMints() {
    return [this.poolState.baseTokenMint, this.poolState.quoteTokenMint];
  }

}

const TOKEN_SWAP_POOLS = [];
const STEP_TOKEN_SWAP_PROGRAM_ID = /*#__PURE__*/new PublicKey('SSwpMgqNDsyV7mAgN9ady4bDVu5ySjmmXejXvy2vLt1');
const PROGRAM_ID_TO_LABEL = /*#__PURE__*/new Map([['9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP', 'Orca'], [/*#__PURE__*/STEP_TOKEN_SWAP_PROGRAM_ID.toBase58(), 'Step'], ['PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP', 'Penguin']]);
function getTokenSwapPools(cluster) {
  return cluster === 'mainnet-beta' ? TOKEN_SWAP_POOLS : [];
}

const TokenSwapLayout = /*#__PURE__*/struct([/*#__PURE__*/u8('version'), /*#__PURE__*/u8('isInitialized'), /*#__PURE__*/u8('bumpSeed'), /*#__PURE__*/publicKey('tokenProgramId'), /*#__PURE__*/publicKey('tokenAccountA'), /*#__PURE__*/publicKey('tokenAccountB'), /*#__PURE__*/publicKey('tokenPool'), /*#__PURE__*/publicKey('mintA'), /*#__PURE__*/publicKey('mintB'), /*#__PURE__*/publicKey('feeAccount'), /*#__PURE__*/uint64('tradeFeeNumerator'), /*#__PURE__*/uint64('tradeFeeDenominator'), /*#__PURE__*/uint64('ownerTradeFeeNumerator'), /*#__PURE__*/uint64('ownerTradeFeeDenominator'), /*#__PURE__*/uint64('ownerWithdrawFeeNumerator'), /*#__PURE__*/uint64('ownerWithdrawFeeDenominator'), /*#__PURE__*/uint64('hostFeeNumerator'), /*#__PURE__*/uint64('hostFeeDenominator'), /*#__PURE__*/u8('curveType'), /*#__PURE__*/blob(32, 'curveParameters')]);
const StepTokenSwapLayout = /*#__PURE__*/struct([/*#__PURE__*/u8('version'), /*#__PURE__*/u8('isInitialized'), /*#__PURE__*/u8('bumpSeed'), /*#__PURE__*/publicKey('tokenProgramId'), /*#__PURE__*/publicKey('tokenAccountA'), /*#__PURE__*/publicKey('tokenAccountB'), /*#__PURE__*/publicKey('tokenPool'), /*#__PURE__*/publicKey('mintA'), /*#__PURE__*/publicKey('mintB'), /*#__PURE__*/publicKey('feeAccount'), /*#__PURE__*/uint64('tradeFeeNumerator'), /*#__PURE__*/uint64('tradeFeeDenominator'), /*#__PURE__*/uint64('ownerTradeFeeNumerator'), /*#__PURE__*/uint64('ownerTradeFeeDenominator'), /*#__PURE__*/uint64('ownerWithdrawFeeNumerator'), /*#__PURE__*/uint64('ownerWithdrawFeeDenominator'), /*#__PURE__*/u8('curveType'), /*#__PURE__*/blob(32, 'curveParameters'), /*#__PURE__*/u8('poolNonce')]);
function accountInfoToTokenSwapState(address, tokenSwapAccountInfo) {
  const programId = tokenSwapAccountInfo.owner; // The layout difference only affects fields we do not actively use

  const tokenSwapData = programId.equals(STEP_TOKEN_SWAP_PROGRAM_ID) ? StepTokenSwapLayout.decode(tokenSwapAccountInfo.data) : TokenSwapLayout.decode(tokenSwapAccountInfo.data);

  if (!tokenSwapData.isInitialized) {
    throw new Error(`Invalid token swap state`);
  }

  const [authority] = findProgramAddressSync([address.toBuffer()], programId);
  const poolToken = new PublicKey(tokenSwapData.tokenPool);
  const feeAccount = new PublicKey(tokenSwapData.feeAccount);
  const tokenAccountA = new PublicKey(tokenSwapData.tokenAccountA);
  const tokenAccountB = new PublicKey(tokenSwapData.tokenAccountB);
  const mintA = new PublicKey(tokenSwapData.mintA);
  const mintB = new PublicKey(tokenSwapData.mintB);
  const tokenProgramId = new PublicKey(tokenSwapData.tokenProgramId);
  const tradeFeeNumerator = tokenSwapData.tradeFeeNumerator;
  const tradeFeeDenominator = tokenSwapData.tradeFeeDenominator;
  const ownerTradeFeeNumerator = tokenSwapData.ownerTradeFeeNumerator;
  const ownerTradeFeeDenominator = tokenSwapData.ownerTradeFeeDenominator;
  const ownerWithdrawFeeNumerator = tokenSwapData.ownerWithdrawFeeNumerator;
  const ownerWithdrawFeeDenominator = tokenSwapData.ownerWithdrawFeeDenominator;
  const curveType = tokenSwapData.curveType;
  const curveParameters = tokenSwapData.curveParameters;
  const poolNonce = 'poolNonce' in tokenSwapData ? tokenSwapData.poolNonce : undefined;
  return {
    address,
    programId,
    tokenProgramId,
    poolToken,
    feeAccount,
    authority,
    tokenAccountA,
    tokenAccountB,
    mintA,
    mintB,
    tradeFeeNumerator,
    tradeFeeDenominator,
    ownerTradeFeeNumerator,
    ownerTradeFeeDenominator,
    ownerWithdrawFeeNumerator,
    ownerWithdrawFeeDenominator,
    curveType,
    curveParameters,
    poolNonce
  };
}

var CurveType;

(function (CurveType) {
  CurveType[CurveType["ConstantProduct"] = 0] = "ConstantProduct";
  CurveType[CurveType["Stable"] = 2] = "Stable";
})(CurveType || (CurveType = {})); // Abstract any SPL token swap based AMM


class SplTokenSwapAmm {
  constructor(address, swapStateAccountInfo, label) {
    this.label = void 0;
    this.tokenSwapState = void 0;
    this.curveType = void 0;
    this.tokenAccounts = [];
    this.calculator = void 0;
    this.label = label;
    this.tokenSwapState = accountInfoToTokenSwapState(address, swapStateAccountInfo);
    this.curveType = this.tokenSwapState.curveType;

    if (!(this.curveType in CurveType)) {
      throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);
    }
  }

  get id() {
    return this.tokenSwapState.address.toBase58();
  }

  getAccountsForUpdate() {
    return [this.tokenSwapState.tokenAccountA, this.tokenSwapState.tokenAccountB];
  }

  update(accountInfoMap) {
    const tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());
    this.tokenAccounts = tokenAccountInfos.map(info => {
      const tokenAccount = deserializeAccount(info.data);

      if (!tokenAccount) {
        throw new Error('Invalid token account');
      }

      return tokenAccount;
    });

    if (this.tokenSwapState.curveType === CurveType.ConstantProduct) {
      this.calculator = new TokenSwapConstantProduct(this.tokenAccounts.map(tokenAccount => {
        return JSBI.BigInt(tokenAccount.amount.toString());
      }), new Fraction(JSBI.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()), JSBI.BigInt(this.tokenSwapState.tradeFeeDenominator.toString())), new Fraction(JSBI.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()), JSBI.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString())));
    } else if (this.tokenSwapState.curveType === CurveType.Stable) {
      this.calculator = new TokenSwapStable(JSBI.BigInt(this.tokenSwapState.curveParameters[0]), this.tokenAccounts.map(tokenAccount => {
        return JSBI.BigInt(tokenAccount.amount.toString());
      }), new Fraction(JSBI.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()), JSBI.BigInt(this.tokenSwapState.tradeFeeDenominator.toString())), new Fraction(JSBI.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()), JSBI.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString())));
    }
  }

  getQuote({
    sourceMint,
    amount
  }) {
    if (this.tokenAccounts.length === 0) {
      throw new Error('Unable to fetch accounts for specified tokens.');
    }

    if (this.calculator === undefined) {
      throw new Error('Unable to fetch accounts for Curve calculator.');
    }

    let feePct = new Decimal(this.tokenSwapState.tradeFeeNumerator.toString()).div(this.tokenSwapState.tradeFeeDenominator.toString()).add(new Decimal(this.tokenSwapState.ownerTradeFeeNumerator.toString()).div(this.tokenSwapState.ownerTradeFeeDenominator.toString()));
    const outputIndex = this.tokenAccounts[0].mint.equals(sourceMint) ? 1 : 0;
    let result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, outputIndex);
    return {
      notEnoughLiquidity: false,
      inAmount: amount,
      outAmount: JSBI.toNumber(result.expectedOutputAmount),
      feeAmount: JSBI.toNumber(result.fees),
      feeMint: sourceMint.toBase58(),
      feePct: feePct.toNumber(),
      priceImpactPct: result.priceImpact.toNumber()
    };
  }

  createSwapInstructions({
    sourceMint,
    sourceTokenAccount,
    destinationTokenAccount,
    userTransferAuthority,
    amount,
    minimumOutAmount,
    platformFee
  }) {
    return [createTokenSwapInstruction(this.tokenSwapState, sourceMint, sourceTokenAccount, destinationTokenAccount, userTransferAuthority, amount, minimumOutAmount, platformFee, this.tokenSwapState.programId.equals(STEP_TOKEN_SWAP_PROGRAM_ID))];
  }

  get reserveTokenMints() {
    return [this.tokenSwapState.mintA, this.tokenSwapState.mintB];
  }

}

const FEE_DENOMINATOR = /*#__PURE__*/Math.pow(10, 10);
const MercurialSwapLayout = /*#__PURE__*/struct([/*#__PURE__*/u8('version'), /*#__PURE__*/u8('isInitialized'), /*#__PURE__*/u8('nonce'), /*#__PURE__*/uint64('amplificationCoefficient'), /*#__PURE__*/uint64('feeNumerator'), /*#__PURE__*/uint64('adminFeeNumerator'), /*#__PURE__*/u32('tokenAccountsLength'), /*#__PURE__*/uint64('precisionFactor'), /*#__PURE__*/uint64('precisionMultiplierA'), /*#__PURE__*/uint64('precisionMultiplierB'), /*#__PURE__*/uint64('precisionMultiplierC'), /*#__PURE__*/uint64('precisionMultiplierD'), /*#__PURE__*/publicKey('tokenAccountA'), /*#__PURE__*/publicKey('tokenAccountB'), /*#__PURE__*/publicKey('tokenAccountC'), /*#__PURE__*/publicKey('tokenAccountD')]);
const accountInfoToMercurialSwapLayout = (address, accountInfo) => {
  const programId = accountInfo.owner;
  const decoded = MercurialSwapLayout.decode(accountInfo.data);
  const tokenAccountsLength = decoded.tokenAccountsLength;
  const [authority] = findProgramAddressSync([address.toBuffer()], programId);
  const precisionMultipliers = [decoded.precisionMultiplierA.toNumber(), decoded.precisionMultiplierB.toNumber(), decoded.precisionMultiplierC.toNumber(), decoded.precisionMultiplierD.toNumber()].slice(0, tokenAccountsLength);
  const tokenAccounts = [decoded.tokenAccountA, decoded.tokenAccountB, decoded.tokenAccountC, decoded.tokenAccountD].slice(0, tokenAccountsLength);
  return {
    programId,
    authority,
    isInitialized: Boolean(decoded.isInitialized),
    nonce: decoded.nonce,
    ammId: address,
    amplificationCoefficient: decoded.amplificationCoefficient.toNumber(),
    feeNumerator: decoded.feeNumerator.toNumber(),
    tokenAccountsLength,
    precisionFactor: decoded.precisionFactor.toNumber(),
    precisionMultipliers,
    tokenAccounts
  };
};

class MercurialAmm {
  constructor(address, accountInfo, params) {
    this.params = void 0;
    this.label = 'Mercurial';
    this.swapLayout = void 0;
    this.tokenAccounts = [];
    this.calculator = void 0;
    this.params = params;
    this.swapLayout = accountInfoToMercurialSwapLayout(address, accountInfo);
  }

  get id() {
    return this.swapLayout.ammId.toBase58();
  }

  getAccountsForUpdate() {
    return this.swapLayout.tokenAccounts;
  }

  update(accountInfoMap) {
    let tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());
    this.tokenAccounts = tokenAccountInfos.map(info => deserializeAccount(info.data)).filter(x => x !== null);
    this.calculator = new Stable(JSBI.BigInt(this.swapLayout.amplificationCoefficient), this.tokenAccounts.map(tokenAccount => {
      return JSBI.BigInt(tokenAccount.amount.toString());
    }), this.swapLayout.precisionMultipliers.map(precisionMultiplier => JSBI.BigInt(precisionMultiplier)), new Fraction(JSBI.BigInt(this.swapLayout.feeNumerator), JSBI.BigInt(FEE_DENOMINATOR)));
  }

  getQuote({
    sourceMint,
    destinationMint,
    amount
  }) {
    if (this.tokenAccounts.length === 0) {
      throw new Error('Unable to fetch accounts for specified tokens.');
    }

    if (this.calculator === undefined) {
      throw new Error('Unable to fetch accounts for Curve calculator.');
    }

    const inputIndex = this.tokenAccounts.findIndex(tokenAccount => tokenAccount.mint.equals(sourceMint));
    const outputIndex = this.tokenAccounts.findIndex(tokenAccount => tokenAccount.mint.equals(destinationMint));
    const result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, inputIndex, outputIndex);
    const feePct = this.swapLayout.feeNumerator / FEE_DENOMINATOR;
    return {
      notEnoughLiquidity: false,
      inAmount: amount,
      outAmount: JSBI.toNumber(result.expectedOutputAmount),
      feeAmount: JSBI.toNumber(result.fees),
      feeMint: destinationMint.toBase58(),
      feePct: feePct,
      priceImpactPct: result.priceImpact.toNumber()
    };
  }

  createSwapInstructions({
    sourceTokenAccount,
    destinationTokenAccount,
    userTransferAuthority,
    amount,
    minimumOutAmount,
    platformFee
  }) {
    return [createMercurialExchangeInstruction(this.swapLayout, sourceTokenAccount, destinationTokenAccount, userTransferAuthority, amount, minimumOutAmount, platformFee)];
  }

  get reserveTokenMints() {
    return this.params.tokenMints.map(tokenMint => new PublicKey(tokenMint));
  }

}
MercurialAmm.decodeSwapLayout = accountInfoToMercurialSwapLayout;

class CropperAmm {
  // Hardcoded because no where to query this
  static async getStateFromStateAccount(connection) {
    const accountInfo = await connection.getAccountInfo(CROPPER_STATE_ADDRESS);

    if (!accountInfo) {
      throw new Error('State account not found');
    }

    return stateAccountInfoToCropperState(accountInfo);
  }

  constructor(address, accountInfo, params) {
    this.params = void 0;
    this.label = 'Cropper';
    this.poolState = void 0;
    this.tokenAccounts = [];
    this.calculator = void 0;
    this.feePct = void 0;
    this.params = params;
    this.poolState = accountInfoToCropperPoolState(address, accountInfo);
    this.feePct = new Decimal(this.params.fixedFeeNumerator).div(this.params.feeDenominator).add(new Decimal(this.params.returnFeeNumerator).div(this.params.feeDenominator));
    this.params.tokenAFeeAccount = new PublicKey(this.params.tokenAFeeAccount);
    this.params.tokenBFeeAccount = new PublicKey(this.params.tokenBFeeAccount);
  }

  get id() {
    return this.poolState.ammId.toBase58();
  }

  getAccountsForUpdate() {
    return [this.poolState.tokenAAccount, this.poolState.tokenBAccount];
  }

  update(accountInfoMap) {
    const tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());
    this.tokenAccounts = tokenAccountInfos.map(info => {
      const tokenAccount = deserializeAccount(info.data);

      if (!tokenAccount) {
        throw new Error('Invalid token account');
      }

      return tokenAccount;
    });
    this.calculator = new TokenSwapConstantProduct(this.tokenAccounts.map(tokenAccount => {
      return JSBI.BigInt(tokenAccount.amount.toString());
    }), new Fraction(JSBI.BigInt(this.params.fixedFeeNumerator), JSBI.BigInt(this.params.feeDenominator)), new Fraction(JSBI.BigInt(this.params.returnFeeNumerator), JSBI.BigInt(this.params.feeDenominator)));
  }

  getQuote({
    sourceMint,
    amount
  }) {
    if (this.tokenAccounts.length === 0) {
      throw new Error('Unable to fetch accounts for specified tokens.');
    }

    if (this.calculator === undefined) {
      throw new Error('Unable to fetch accounts for calculator.');
    }

    const outputIndex = this.tokenAccounts[0].mint.equals(sourceMint) ? 1 : 0;
    let result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, outputIndex);
    return {
      notEnoughLiquidity: false,
      inAmount: amount,
      outAmount: JSBI.toNumber(result.expectedOutputAmount),
      feeAmount: JSBI.toNumber(result.fees),
      feeMint: sourceMint.toBase58(),
      feePct: this.feePct.toNumber(),
      priceImpactPct: result.priceImpact.toNumber()
    };
  }

  createSwapInstructions({
    sourceMint,
    sourceTokenAccount,
    destinationTokenAccount,
    userTransferAuthority,
    amount,
    minimumOutAmount,
    platformFee
  }) {
    const feeAccount = sourceMint.equals(this.poolState.mintA) ? this.params.tokenAFeeAccount : this.params.tokenBFeeAccount;
    return [createCropperSwapInstruction(this.poolState, sourceMint, sourceTokenAccount, destinationTokenAccount, userTransferAuthority, feeAccount, amount, minimumOutAmount, platformFee)];
  }

  get reserveTokenMints() {
    return [this.poolState.mintA, this.poolState.mintB];
  }

}
CropperAmm.decodePoolState = accountInfoToCropperPoolState;

const SenchaSwapLayout = /*#__PURE__*/struct([/*#__PURE__*/blob(8, 'discriminator'), /*#__PURE__*/publicKey('factory'), /*#__PURE__*/u8('bump'), /*#__PURE__*/uint64('index'), /*#__PURE__*/publicKey('admin'), /*#__PURE__*/publicKey('token0Reserves'), /*#__PURE__*/publicKey('token0Mint'), /*#__PURE__*/publicKey('token0Fees'), /*#__PURE__*/publicKey('token1Reserves'), /*#__PURE__*/publicKey('token1Mint'), /*#__PURE__*/publicKey('token1Fees'), /*#__PURE__*/u8('isPaused'), /*#__PURE__*/publicKey('poolMint'), /*#__PURE__*/uint64('tradeFeeKbps'), /*#__PURE__*/uint64('withdrawFeeKbps'), /*#__PURE__*/uint64('adminTradeFeeKbps'), /*#__PURE__*/uint64('adminWithdrawFeeKbps')]);
const accountInfoToSenchaPoolState = (address, accountInfo) => {
  const programId = accountInfo.owner;
  const decoded = SenchaSwapLayout.decode(accountInfo.data);
  return {
    programId,
    isPaused: Boolean(decoded.isPaused),
    bump: decoded.bump,
    ammId: address,
    token0Reserves: decoded.token0Reserves,
    token1Reserves: decoded.token1Reserves,
    token0Mint: decoded.token0Mint,
    token1Mint: decoded.token1Mint,
    token0Fees: decoded.token0Fees,
    token1Fees: decoded.token1Fees,
    poolMint: decoded.poolMint,
    tradeFeeKbps: decoded.tradeFeeKbps.toNumber()
  };
};

class SenchaAmm {
  constructor(address, accountInfo) {
    this.label = 'Sencha';
    this.poolState = void 0;
    this.calculator = void 0;
    this.tokenAccounts = [];
    this.poolState = accountInfoToSenchaPoolState(address, accountInfo);
  }

  get id() {
    return this.poolState.ammId.toBase58();
  }

  getAccountsForUpdate() {
    return [this.poolState.token0Reserves, this.poolState.token1Reserves];
  }

  update(accountInfoMap) {
    const tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());
    this.tokenAccounts = tokenAccountInfos.map(info => {
      const tokenAccount = deserializeAccount(info.data);

      if (!tokenAccount) {
        throw new Error('Invalid token account');
      }

      return tokenAccount;
    });
    this.calculator = new TokenSwapConstantProduct(this.tokenAccounts.map(tokenAccount => {
      return JSBI.BigInt(tokenAccount.amount.toString());
    }), new Fraction(JSBI.BigInt(this.poolState.tradeFeeKbps), JSBI.BigInt(10000000)), new Fraction(ZERO$1, ZERO$1), false);
  }

  getQuote({
    sourceMint,
    amount
  }) {
    if (this.tokenAccounts.length === 0) {
      throw new Error('Unable to fetch accounts for specified tokens.');
    }

    if (this.calculator === undefined) {
      throw new Error('Unable to fetch accounts for Curve calculator.');
    }

    const outputIndex = this.tokenAccounts[0].mint.equals(sourceMint) ? 1 : 0;
    let result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, outputIndex);
    let feePct = this.poolState.tradeFeeKbps / 10000000; // 100% kbps

    return {
      notEnoughLiquidity: false,
      inAmount: amount,
      outAmount: JSBI.toNumber(result.expectedOutputAmount),
      feeAmount: JSBI.toNumber(result.fees),
      feeMint: sourceMint.toBase58(),
      feePct,
      priceImpactPct: result.priceImpact.toNumber()
    };
  }

  createSwapInstructions({
    sourceMint,
    sourceTokenAccount,
    destinationTokenAccount,
    userTransferAuthority,
    amount,
    minimumOutAmount,
    platformFee
  }) {
    return [createSenchaSwapInstruction(this.poolState, sourceMint, sourceTokenAccount, destinationTokenAccount, userTransferAuthority, amount, minimumOutAmount, platformFee)];
  }

  get reserveTokenMints() {
    return [this.poolState.token0Mint, this.poolState.token1Mint];
  }

}

function ammFactory(address, accountInfo, params) {
  const programId = new PublicKey(accountInfo.owner);

  if (programId.equals(MAINNET_SERUM_DEX_PROGRAM) || programId.equals(DEVNET_SERUM_DEX_PROGRAM)) {
    const decoded = Market.getLayout(programId).decode(accountInfo.data);

    if (!decoded.accountFlags.initialized || !decoded.accountFlags.market) {
      throw new Error('Invalid market');
    }

    const serumMarket = new Market(decoded, 0, 0, {}, programId);
    return new SerumAmm(serumMarket);
  } else if (programId.equals(RAYDIUM_AMM_V4_PROGRAM_ID)) {
    const raydiumAmm = new RaydiumAmm(address, accountInfo);

    if (raydiumAmm.status === 1) {
      return raydiumAmm;
    }
  } else if (programId.equals(MERCURIAL_SWAP_PROGRAM_ID)) {
    return new MercurialAmm(address, accountInfo, params);
  } else if (programId.equals(SWAP_PROGRAM_ID)) {
    const stableSwap = StableSwap.loadWithData(address, accountInfo.data, findProgramAddressSync([address.toBuffer()], SWAP_PROGRAM_ID)[0]);
    return new SaberAmm(stableSwap);
  } else if (programId.equals(ALDRIN_SWAP_PROGRAM_ID) || programId.equals(ALDRIN_SWAP_V2_PROGRAM_ID)) {
    return new AldrinAmm(address, accountInfo, params);
  } else if ([...PROGRAM_ID_TO_LABEL.keys()].includes(programId.toBase58())) {
    var _PROGRAM_ID_TO_LABEL$;

    const label = (_PROGRAM_ID_TO_LABEL$ = PROGRAM_ID_TO_LABEL.get(accountInfo.owner.toBase58())) !== null && _PROGRAM_ID_TO_LABEL$ !== void 0 ? _PROGRAM_ID_TO_LABEL$ : 'Unknown';
    return new SplTokenSwapAmm(address, accountInfo, label);
  } else if (programId.equals(CROPPER_PROGRAM_ID)) {
    return new CropperAmm(address, accountInfo, params);
  } else if (programId.equals(SENCHA_PROGRAM_ID)) {
    return new SenchaAmm(address, accountInfo);
  } // Not supported by frontend


  return;
}

async function getAllAmms(connection, cluster, marketUrl) {
  const marketsCache = await (await fetch(marketUrl || MARKETS_URL[cluster])).json();

  const marketCacheToAccountInfo = marketsCache => {
    return marketsCache.map(market => {
      const {
        data: [accountInfo, format],
        pubkey,
        ...rest
      } = market;
      return { ...rest,
        pubkey: new PublicKey(pubkey),
        data: Buffer.from(accountInfo, format),
        owner: new PublicKey(rest.owner)
      };
    });
  }; // We add market accounts infos that do not come from the API yet
  // TODO: Move to market cache


  const tokenSwapPools = getTokenSwapPools(cluster);
  const extraKeys = tokenSwapPools;
  const extraMarketKeyedAccountInfos = (await connection.getMultipleAccountsInfo(extraKeys)).reduce((acc, accountInfo, index) => {
    if (accountInfo) {
      acc.push({ ...accountInfo,
        pubkey: extraKeys[index]
      });
    }

    return acc;
  }, new Array());
  const marketKeyedAccountInfos = marketCacheToAccountInfo(marketsCache).concat(extraMarketKeyedAccountInfos);
  const amms = marketKeyedAccountInfos.reduce((acc, keyedAccountInfo) => {
    const amm = ammFactory(keyedAccountInfo.pubkey, keyedAccountInfo, keyedAccountInfo.params); // Amm might not be recognized by the current version of the frontend
    // or be in a state we don't want

    if (amm) {
      acc.push(amm);
    }

    return acc;
  }, new Array());
  const naturalAmms = amms.slice();
  amms.push(...getSaberWrappedDecimalsAmms()); // Add the split trade Amms
  // This is very inefficient and slow

  ammCrossProtocolPairs(naturalAmms, (firstAmm, secondAmm) => {
    const splitTradeAmm = SplitTradeAmm.create(firstAmm, secondAmm);

    if (splitTradeAmm) {
      amms.push(splitTradeAmm);
    }
  });
  return amms;
}

function ammCrossProtocolPairs(arr, func) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = i; j < arr.length - 1; j++) {
      // Don't pair amm with same label
      if (arr[i].label !== arr[j].label) {
        func(arr[i], arr[j + 1]);
      }
    }
  }
}

function getTokenRouteSegments(amms) {
  const tokenRouteSegments = new Map();
  amms.forEach(amm => {
    const reserveTokenMintPermutations = getTwoPermutations(amm.reserveTokenMints);
    reserveTokenMintPermutations.forEach(([firstReserveMint, secondReserveMint]) => {
      addSegment(firstReserveMint.toBase58(), secondReserveMint.toBase58(), amm, tokenRouteSegments);
    });
  });
  return tokenRouteSegments;
}

function addSegment(inMint, outMint, amm, tokenRouteSegments) {
  let segments = tokenRouteSegments.get(inMint);

  if (!segments) {
    segments = new Map([[outMint, []]]);
    tokenRouteSegments.set(inMint, segments);
  }

  let marketMetas = segments.get(outMint);

  if (!marketMetas) {
    marketMetas = [];
    segments.set(outMint, marketMetas);
  }

  marketMetas.push({
    amm
  });
}

function computeRoutes(inputMint, outputMint, tokenRouteSegments) {
  var _firstSegment$get;

  const routes = [];
  const firstSegment = tokenRouteSegments === null || tokenRouteSegments === void 0 ? void 0 : tokenRouteSegments.get(inputMint.toBase58());
  const simpleRoutes = (_firstSegment$get = firstSegment === null || firstSegment === void 0 ? void 0 : firstSegment.get(outputMint.toBase58())) !== null && _firstSegment$get !== void 0 ? _firstSegment$get : []; // Direct trade

  simpleRoutes.forEach(simpleRoute => {
    // dont do direct decimal saber
    if (!(simpleRoute.amm instanceof SaberAddDecimalsAmm)) {
      routes.push({
        marketMetas: [simpleRoute]
      });
    }
  });
  const secondSegment = tokenRouteSegments === null || tokenRouteSegments === void 0 ? void 0 : tokenRouteSegments.get(outputMint.toBase58());

  for (const [mint, marketMetas] of (_firstSegment$entries = firstSegment === null || firstSegment === void 0 ? void 0 : firstSegment.entries()) !== null && _firstSegment$entries !== void 0 ? _firstSegment$entries : []) {
    var _firstSegment$entries, _secondSegment$get;

    const intersectionMarketMetas = (_secondSegment$get = secondSegment === null || secondSegment === void 0 ? void 0 : secondSegment.get(mint)) !== null && _secondSegment$get !== void 0 ? _secondSegment$get : [];

    for (const marketMeta of marketMetas) {
      for (const intersectionMarketMeta of intersectionMarketMetas) {
        if (isValidRoute(marketMeta.amm, intersectionMarketMeta.amm)) {
          routes.push({
            marketMetas: [marketMeta, intersectionMarketMeta],
            intermediateMint: new PublicKey(mint)
          });
        }
      }
    }
  }

  return routes;
}
function computeRouteMap(tokenRouteSegments) {
  const routeMap = new Map();

  for (const [tokenMint, firstLevelOutputs] of tokenRouteSegments) {
    const validOutputMints = new Set();

    for (const [firstLevelOutputMint, firstLevelMarketMetas] of firstLevelOutputs) {
      var _tokenRouteSegments$g;

      validOutputMints.add(firstLevelOutputMint); // add the single level output as possible valid mints as well

      const secondLevelOutputs = (_tokenRouteSegments$g = tokenRouteSegments.get(firstLevelOutputMint)) !== null && _tokenRouteSegments$g !== void 0 ? _tokenRouteSegments$g : [];

      for (const [secondLevelOutputMint, secondLevelMarketMetas] of secondLevelOutputs) {
        // Prevent output mint == input mint when routing
        if (secondLevelOutputMint === tokenMint) {
          continue;
        }

        for (const firstLevelMarketMeta of firstLevelMarketMetas) {
          for (const secondLevelMarketMeta of secondLevelMarketMetas) {
            if (isValidRoute(firstLevelMarketMeta.amm, secondLevelMarketMeta.amm)) {
              validOutputMints.add(secondLevelOutputMint);
              break;
            }
          }
        }
      }
    }

    routeMap.set(tokenMint, Array.from(validOutputMints));
  }

  return routeMap;
}
function isSplitSetupRequired(marketInfos) {
  if (marketInfos.length === 1) {
    const amm = marketInfos[0].marketMeta.amm;

    if (amm instanceof SplitTradeAmm && amm.shouldSplitSetup) {
      return true;
    }
  } else {
    const [firstMarket, secondMarket] = marketInfos.map(marketInfo => marketInfo.marketMeta.amm);

    if (firstMarket instanceof RaydiumAmm || secondMarket instanceof RaydiumAmm) {
      return true;
    } else if (firstMarket instanceof SerumAmm && secondMarket instanceof SerumAmm) {
      return true;
    }
  }

  return false;
}

function isPlatformFeeSupported(marketInfos) {
  if (marketInfos.length > 1) {
    const [firstMarket, secondMarket] = marketInfos.map(marketInfo => marketInfo.amm);

    if (firstMarket instanceof RaydiumAmm && secondMarket instanceof RaydiumAmm) {
      return false;
    }
  }

  return true;
}
function getRouteInfoUniqueId(routeInfo) {
  return routeInfo.marketInfos.map(marketInfo => `${marketInfo.marketMeta.amm.id}-${marketInfo.inputMint}`).join('-');
}

const getCacheMintKey = marketInfos => {
  var _marketInfos$, _marketInfos$2, _marketInfos$3;

  return `${(_marketInfos$ = marketInfos[0]) === null || _marketInfos$ === void 0 ? void 0 : _marketInfos$.inputMint}-${(_marketInfos$2 = marketInfos[0]) === null || _marketInfos$2 === void 0 ? void 0 : _marketInfos$2.outputMint}-${(_marketInfos$3 = marketInfos[1]) === null || _marketInfos$3 === void 0 ? void 0 : _marketInfos$3.outputMint}-${marketInfos.map(item => item.marketMeta.amm.id)}`;
};
const getInstructionCache = ({
  instructionCache,
  walletPublicKey,
  cacheKey
}) => {
  var _instructionCache$get;

  return (_instructionCache$get = instructionCache.get(walletPublicKey)) === null || _instructionCache$get === void 0 ? void 0 : _instructionCache$get.get(cacheKey);
};
const setInstructionCache = ({
  instructionCache,
  instructionResult,
  walletPublicKey,
  cacheKey
}) => {
  const walletCache = instructionCache.get(walletPublicKey) || new Map();
  walletCache.set(cacheKey, instructionResult);
  instructionCache.set(walletPublicKey, walletCache);
};
const deleteInstructionCache = ({
  instructionCache,
  walletPublicKey
}) => {
  var _instructionCache$get2;

  (_instructionCache$get2 = instructionCache.get(walletPublicKey)) === null || _instructionCache$get2 === void 0 ? void 0 : _instructionCache$get2.clear();
};

const getEmptyInstruction = () => ({
  instructions: [],
  cleanupInstructions: [],
  signers: []
});

async function createAndCloseWSOLAccount(connection, owner, amount) {
  const result = getEmptyInstruction();
  result.instructions = [];
  const toAccount = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, WRAPPED_SOL_MINT, owner);
  const info = await connection.getAccountInfo(toAccount);

  if (info === null) {
    result.instructions.push(Token.createAssociatedTokenAccountInstruction(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, WRAPPED_SOL_MINT, toAccount, owner, owner));
  } // Fund account and sync


  result.instructions.push(SystemProgram.transfer({
    fromPubkey: owner,
    toPubkey: toAccount,
    lamports: amount
  }));
  result.instructions.push( // This is not exposed by the types, but indeed it exists
  Token.createSyncNativeInstruction(TOKEN_PROGRAM_ID, toAccount));
  result.cleanupInstructions = [Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, toAccount, owner, owner, [])];
  return {
    address: toAccount,
    ...result
  };
}
async function findOrCreateAssociatedAccountByMint(connection, payer, owner, mintAddress, unwrapSOL) {
  const mint = typeof mintAddress === 'string' ? new PublicKey(mintAddress) : mintAddress;
  const toAccount = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint, owner);
  const cleanupInstructions = [];
  const instructions = [];
  const info = await connection.getAccountInfo(toAccount);

  if (info === null) {
    instructions.push(Token.createAssociatedTokenAccountInstruction(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint, toAccount, owner, payer));
  } // We close it when wrapped SOL


  if (mint.equals(WRAPPED_SOL_MINT) && unwrapSOL) {
    cleanupInstructions.push(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, toAccount, owner, owner, []));
  }

  return {
    address: toAccount,
    instructions: instructions,
    cleanupInstructions,
    signers: []
  };
}

async function routeToInstructions(user, openOrdersAddresses, userSourceTokenAccountAddress, userIntermediaryTokenAccountAddress, userDestinationTokenAccountAddress, routeInfo, platformFee, quoteMintToReferrer) {
  const outAmountWithSlippage = routeInfo.outAmountWithSlippage;
  const inputAmount = routeInfo.inAmount;
  const legs = routeInfo.marketInfos.length;

  if (legs == 2 && !userIntermediaryTokenAccountAddress) {
    throw new Error('Missing intermediary token account');
  }

  const userTokenAccountAddresses = legs === 1 ? [userSourceTokenAccountAddress, userDestinationTokenAccountAddress] : [userSourceTokenAccountAddress, userIntermediaryTokenAccountAddress, userDestinationTokenAccountAddress];
  let instructions = [];
  const platformFeeSupported = isPlatformFeeSupported(routeInfo.marketInfos.map(mi => mi.marketMeta));

  if (legs > 1) {
    instructions.push(createSetTokenLedgerInstruction(userIntermediaryTokenAccountAddress));
  }

  for (const [index, marketInfo] of routeInfo.marketInfos.entries()) {
    const amm = marketInfo.marketMeta.amm;
    const legInputAmount = index === 0 ? inputAmount : null;
    const legOutAmountWithSlippage = index === legs - 1 ? outAmountWithSlippage : 0;
    const legPlatformFee = index === legs - 1 && platformFeeSupported ? platformFee : undefined;
    const [source, destination] = userTokenAccountAddresses.slice(index);
    instructions.push(...amm.createSwapInstructions({
      sourceMint: marketInfo.inputMint,
      destinationMint: marketInfo.outputMint,
      sourceTokenAccount: source,
      destinationTokenAccount: destination,
      userTransferAuthority: user.publicKey,
      amount: legInputAmount,
      minimumOutAmount: legOutAmountWithSlippage,
      openOrdersAddress: openOrdersAddresses[index],
      platformFee: legPlatformFee,
      quoteMintToReferrer
    }));
  }

  const {
    signers,
    cleanupInstructions
  } = getEmptyInstruction();

  if (user.isKeyPair && user.signer) {
    signers.push(user.signer);
  }

  return {
    signers,
    cleanupInstructions,
    instructions
  };
}

const routeAtaInstructions = async (connection, marketInfos, userPublicKey, unwrapSOL) => {
  const getUserIntermediateTokenAccountAddress = async () => {
    const userIntermediateTokenAccountAddress = marketInfos.length === 2 ? await findOrCreateAssociatedAccountByMint(connection, userPublicKey, userPublicKey, marketInfos[0].outputMint, unwrapSOL) : undefined;
    return userIntermediateTokenAccountAddress;
  };

  const getUserDestinationTokenAccountAddress = async () => {
    return await findOrCreateAssociatedAccountByMint(connection, userPublicKey, userPublicKey, marketInfos.length === 2 ? marketInfos[1].outputMint : marketInfos[0].outputMint, unwrapSOL);
  };

  const [userIntermediaryTokenAccountResult, userDestinationTokenAccountResult] = await Promise.all([getUserIntermediateTokenAccountAddress(), getUserDestinationTokenAccountAddress()]);
  return {
    userIntermediaryTokenAccountResult,
    userDestinationTokenAccountResult
  };
};

async function getOrCreateOpenOrdersAddress(connection, user, serumMarket, marketToOpenOrdersAddress) {
  const result = getEmptyInstruction();
  const marketAddress = serumMarket.address.toString();

  if (marketToOpenOrdersAddress) {
    // check existing map
    let openOrdersAddress = marketToOpenOrdersAddress.get(marketAddress);

    if (openOrdersAddress) {
      let openOrdersAccountInfo = null; // We verify if it indeed exists, with low commitment to pick it up, to address the unsafe behaviour below

      openOrdersAccountInfo = await connection.getAccountInfo(openOrdersAddress, 'processed');

      if (openOrdersAccountInfo) {
        return { ...result,
          address: openOrdersAddress
        };
      }
    }
  }

  const [newOpenOrdersAddress, ix] = createOpenOrdersInstruction(serumMarket, user);
  const newOpenOrdersAddressInfo = await connection.getAccountInfo(newOpenOrdersAddress);

  if (!newOpenOrdersAddressInfo) {
    result.instructions = [ix];
  } // This is unsafe, since we don't know yet if it has succeeded


  marketToOpenOrdersAddress === null || marketToOpenOrdersAddress === void 0 ? void 0 : marketToOpenOrdersAddress.set(serumMarket.address.toString(), newOpenOrdersAddress);
  return { ...result,
    address: newOpenOrdersAddress
  };
}

const calculateTransactionDepositAndFee = ({
  intermediate,
  destination,
  openOrders,
  feeCalculator
}) => {
  const SERUM_OPEN_ACCOUNT_LAMPORTS = 23352760;
  const OPEN_TOKEN_ACCOUNT_LAMPORTS = 2039280;
  const openOrdersDeposits = openOrders.filter(ooi => ooi && ooi.instructions.length > 0).map(() => SERUM_OPEN_ACCOUNT_LAMPORTS);
  const ataDepositLength = [destination, intermediate].filter(item => (item === null || item === void 0 ? void 0 : item.instructions.length) && item.cleanupInstructions.length === 0).length;
  const ataDeposit = ataDepositLength * OPEN_TOKEN_ACCOUNT_LAMPORTS;
  return {
    signatureFee: ([destination.signers, intermediate === null || intermediate === void 0 ? void 0 : intermediate.signers, openOrders === null || openOrders === void 0 ? void 0 : openOrders.some(oo => oo === null || oo === void 0 ? void 0 : oo.signers)].filter(Boolean).flat().length + 1) * feeCalculator.lamportsPerSignature,
    openOrdersDeposits,
    ataDeposit,
    ataDepositLength: ataDepositLength
  };
};

const getDepositAndFeeFromInstructions = async ({
  connection,
  marketInfos,
  userPublicKey,
  feeCalculator,
  instructionCache,
  serumOpenOrdersPromise,
  unwrapSOL
}) => {
  const cacheKey = getCacheMintKey(marketInfos);
  const walletPublicKey = userPublicKey.toBase58();
  const routeCache = getInstructionCache({
    instructionCache,
    walletPublicKey,
    cacheKey
  });

  if (routeCache) {
    const {
      destination,
      intermediate,
      openOrders
    } = routeCache;
    return calculateTransactionDepositAndFee({
      intermediate,
      destination,
      openOrders,
      feeCalculator
    });
  }

  const openOrdersInstructionsPromise = Promise.all(marketInfos.map(async marketInfo => {
    const amm = marketInfo.marketMeta.amm;

    if (amm instanceof SerumAmm || amm instanceof SplitTradeAmm) {
      if (!amm.market) return;
      return await getOrCreateOpenOrdersAddress(connection, userPublicKey, amm.market, await serumOpenOrdersPromise);
    }

    return;
  }));
  const promise = routeAtaInstructions(connection, marketInfos, userPublicKey, unwrapSOL).then(({
    userIntermediaryTokenAccountResult,
    userDestinationTokenAccountResult
  }) => {
    return openOrdersInstructionsPromise.then(openOrdersInstructions => ({
      intermediate: userIntermediaryTokenAccountResult,
      destination: userDestinationTokenAccountResult,
      openOrders: openOrdersInstructions
    }));
  });
  const instructionResult = await promise;
  setInstructionCache({
    cacheKey,
    instructionCache,
    instructionResult,
    walletPublicKey
  });
  return calculateTransactionDepositAndFee({ ...instructionResult,
    feeCalculator
  });
};
const NO_PLATFORM_FEE = {
  feeBps: 0,
  feeAccounts: /*#__PURE__*/new Map()
};
async function getPlatformFeeAccounts(connection, feeAccountOwner) {
  const tokenAccounts = (await connection.getTokenAccountsByOwner(feeAccountOwner, {
    programId: TOKEN_PROGRAM_ID
  })).value;
  const feeAccounts = tokenAccounts.reduce((acc, tokenAccount) => {
    const deserializedtokenAccount = deserializeAccount(tokenAccount.account.data);

    if (deserializedtokenAccount) {
      acc.set(deserializedtokenAccount.mint.toBase58(), tokenAccount.pubkey);
    }

    return acc;
  }, new Map());
  return feeAccounts;
}

class TransactionBuilder {
  constructor(connection, feePayer, owner) {
    this.connection = void 0;
    this.feePayer = void 0;
    this.instructions = void 0;
    this.owner = void 0;
    this.connection = connection;
    this.feePayer = feePayer;
    this.instructions = [];
    this.owner = owner;
  }

  addInstruction(instruction) {
    this.instructions.push(instruction);
    return this;
  }

  async build(recentBlockHash) {
    if (!recentBlockHash) {
      recentBlockHash = (await this.connection.getRecentBlockhash('singleGossip')).blockhash;
    }

    const txFields = {
      recentBlockhash: recentBlockHash,
      feePayer: this.feePayer
    };
    let instructions = [];
    let cleanupInstructions = [];
    let signers = [];
    this.instructions.forEach(curr => {
      instructions = instructions.concat(curr.instructions);
      cleanupInstructions = cleanupInstructions.concat(curr.cleanupInstructions);
      signers = signers.concat(curr.signers);
    });
    const transaction = new Transaction(txFields);
    instructions.concat(cleanupInstructions).forEach(ix => transaction.add(ix));
    transaction.feePayer = this.feePayer;
    return {
      transaction: transaction,
      signers: signers,
      execute: this.owner.isKeyPair ? () => {
        return this.connection.sendTransaction(transaction, signers);
      } : async () => {
        throw new Error('Please use a Keypair for the owner parameter to enable the execute function');
      }
    };
  }

}

class Owner {
  constructor(owner) {
    this._owner = void 0;
    this._owner = owner;
  }

  get publicKey() {
    if (Owner.isKeyPair(this._owner)) {
      return this._owner.publicKey;
    }

    return this._owner;
  }

  get signer() {
    return Owner.isKeyPair(this._owner) ? this._owner : undefined;
  }

  get isKeyPair() {
    return Owner.isKeyPair(this._owner);
  }

  get isPublicKey() {
    return Owner.isPublicKey(this._owner);
  }

  static isKeyPair(owner) {
    return owner.secretKey !== undefined;
  }

  static isPublicKey(owner) {
    return !Owner.isKeyPair(owner);
  }

}

class TransactionError extends Error {
  constructor(m) {
    super(m); // Set the prototype explicitly.

    this.txid = void 0;
    Object.setPrototypeOf(this, Error.prototype);
  } // transaction id


}

function diffTokenBalance(accountKeyIndex, meta) {
  var _meta$postTokenBalanc, _meta$postTokenBalanc2, _meta$preTokenBalance, _meta$preTokenBalance2;

  const postBalance = (_meta$postTokenBalanc = meta.postTokenBalances) === null || _meta$postTokenBalanc === void 0 ? void 0 : (_meta$postTokenBalanc2 = _meta$postTokenBalanc.find(postTokenBalance => postTokenBalance.accountIndex === accountKeyIndex)) === null || _meta$postTokenBalanc2 === void 0 ? void 0 : _meta$postTokenBalanc2.uiTokenAmount.amount;
  const preBalance = (_meta$preTokenBalance = meta.preTokenBalances) === null || _meta$preTokenBalance === void 0 ? void 0 : (_meta$preTokenBalance2 = _meta$preTokenBalance.find(preTokenBalance => preTokenBalance.accountIndex === accountKeyIndex)) === null || _meta$preTokenBalance2 === void 0 ? void 0 : _meta$preTokenBalance2.uiTokenAmount.amount; // When token account is created it isn't present in preBalance

  if (!postBalance) return;
  return Math.abs(parseInt(postBalance) - (preBalance !== undefined ? parseInt(preBalance) : 0));
}

function extractTokenBalanceChangeFromTransaction(transactionResult, tokenAccountAddress) {
  const message = transactionResult.transaction.message;
  const meta = transactionResult.meta;

  if (!meta) {
    return;
  }

  const index = message.accountKeys.findIndex(p => p.equals(tokenAccountAddress));
  return diffTokenBalance(index, meta);
}
function extractWrappedSOLChangeFromTransaction(transactionResult) {
  var _meta$preTokenBalance3, _meta$preTokenBalance4;

  const meta = transactionResult.meta;

  if (!meta) {
    return;
  }

  const index = (_meta$preTokenBalance3 = meta.preTokenBalances) === null || _meta$preTokenBalance3 === void 0 ? void 0 : (_meta$preTokenBalance4 = _meta$preTokenBalance3.find(preTokenBalance => preTokenBalance.mint === WRAPPED_SOL_MINT.toString())) === null || _meta$preTokenBalance4 === void 0 ? void 0 : _meta$preTokenBalance4.accountIndex;
  if (!index) return;
  return diffTokenBalance(index, meta);
}
function extractSOLChangeFromTransaction(transactionResult) {
  var _meta$postTokenBalanc3, _meta$postTokenBalanc4;

  const meta = transactionResult.meta;

  if (!meta) {
    return;
  }

  const index = (_meta$postTokenBalanc3 = meta.postTokenBalances) === null || _meta$postTokenBalanc3 === void 0 ? void 0 : (_meta$postTokenBalanc4 = _meta$postTokenBalanc3.find(postTokenBalance => postTokenBalance.mint === WRAPPED_SOL_MINT.toString())) === null || _meta$postTokenBalanc4 === void 0 ? void 0 : _meta$postTokenBalanc4.accountIndex;
  if (!index) return;
  return diffTokenBalance(index, meta);
}
function getTokenBalanceChangesFromTransactionResponse(inputMint, outputMint, sourceAddress, destinationAddress, transactionResponse) {
  let sourceTokenBalanceChange;
  let destinationTokenBalanceChange;

  if (transactionResponse) {
    sourceTokenBalanceChange = inputMint.toBase58() === WRAPPED_SOL_MINT.toString() ? extractWrappedSOLChangeFromTransaction(transactionResponse) : extractTokenBalanceChangeFromTransaction(transactionResponse, sourceAddress);
    destinationTokenBalanceChange = outputMint.toBase58() === WRAPPED_SOL_MINT.toString() ? extractSOLChangeFromTransaction(transactionResponse) : extractTokenBalanceChangeFromTransaction(transactionResponse, destinationAddress);
  }

  if (!(sourceTokenBalanceChange && destinationTokenBalanceChange)) {
    throw new Error('Cannot find source or destination token account balance change');
  }

  return [sourceTokenBalanceChange, destinationTokenBalanceChange];
}
function getConfirmTransaction(connection, txid) {
  return promiseRetry(async retry => {
    const txResult = await connection.getTransaction(txid, {
      commitment: 'confirmed'
    });

    if (!txResult) {
      const error = new TransactionError('Transaction was not confirmed');
      error.txid = txid;
      retry(error);
      return txResult;
    }

    return txResult;
  }, {
    retries: 30,
    minTimeout: 500
  });
}

function chunks(array, size) {
  return Array.apply(0, new Array(Math.ceil(array.length / size))).map((_, index) => array.slice(index * size, (index + 1) * size));
}

async function chunkedGetMultipleAccountInfos(connection, pks, chunkSize = 100) {
  return (await Promise.all(chunks(pks, chunkSize).map(chunk => connection.getMultipleAccountsInfo(chunk)))).flat();
}

const PLATFORM_FEE_DENOMINATOR = 10000;
async function fetchRoutes(connection, routes, extraAccountInfosMap) {
  await routeBatchFetcher(connection, routes, extraAccountInfosMap);
  return routes;
}
const computeRouteInfos = ({
  routes,
  amount,
  inputMint,
  outputMint,
  platformFeeBps,
  slippage,
  getDepositAndFeeForRoute
}) => {
  const routesInfo = routes.map(route => {
    const {
      marketMetas,
      intermediateMint
    } = route; // Chain all marketMetas

    let marketInfos = [];
    let intermediateAmount = amount;
    let outAmountWithSlippage = amount;
    const platformFeeSupported = isPlatformFeeSupported(marketMetas);
    const tokenMints = [inputMint, outputMint]; // TODO: Avoid this hack with a smarter data structure

    if (intermediateMint) {
      tokenMints.splice(1, 0, intermediateMint);
    }

    const legs = marketMetas.length;

    for (const [i, marketMeta] of marketMetas.entries()) {
      try {
        const sourceMint = tokenMints[i];
        const destinationMint = tokenMints[i + 1];
        const quote = marketMeta.amm.getQuote({
          sourceMint,
          destinationMint,
          amount: intermediateAmount
        }); // Platform fee applicable only on last leg

        const platformFee = legs - 1 === i && platformFeeSupported ? {
          amount: Math.floor(quote.outAmount * platformFeeBps / PLATFORM_FEE_DENOMINATOR),
          mint: destinationMint.toBase58(),
          pct: platformFeeBps / 100
        } : {
          amount: 0,
          mint: destinationMint.toBase58(),
          pct: 0
        };
        const outAmountAfterFees = Math.max(0, quote.outAmount - platformFee.amount);
        const legOutAmountWithSlippage = Math.round(outAmountAfterFees * (1 - slippage / 100));
        marketInfos.push({
          marketMeta,
          inputMint: sourceMint,
          outputMint: destinationMint,
          notEnoughLiquidity: quote.notEnoughLiquidity,
          minInAmount: quote.minInAmount,
          minOutAmount: quote.minOutAmount,
          inAmount: quote.inAmount,
          outAmount: outAmountAfterFees,
          priceImpactPct: quote.priceImpactPct,
          lpFee: {
            amount: quote.feeAmount,
            mint: quote.feeMint,
            pct: quote.feePct
          },
          platformFee
        });
        intermediateAmount = outAmountAfterFees;
        outAmountWithSlippage = legOutAmountWithSlippage;
      } catch (e) {
        // we supress this error because it is not too critical and it's serum specific
        if (e.message === 'Number can only safely store up to 53 bits') {
          return undefined;
        }

        throw e;
      }
    }

    return {
      marketInfos,
      getDepositAndFee: () => getDepositAndFeeForRoute(marketInfos),
      inAmount: marketInfos[0].inAmount,
      outAmount: intermediateAmount,
      outAmountWithSlippage: outAmountWithSlippage,
      priceImpactPct: 1 - marketInfos.reduce((priceFactor, marketInfo) => {
        priceFactor *= 1 - marketInfo.priceImpactPct;
        return priceFactor;
      }, 1)
    };
  }).filter(item => item !== undefined).sort((a, b) => b.outAmount - a.outAmount); // sort based on which one have better output

  return routesInfo;
};

async function routeBatchFetcher(connection, routes, externalAccountInfosMap) {
  const hasExternalAccountInfosMap = Boolean(externalAccountInfosMap);
  const accountInfosMap = externalAccountInfosMap || new Map(); // dont fetch if externalAccountInfosMap is given

  if (!hasExternalAccountInfosMap) {
    externalAccountInfosMap = new Map();
    const accountsToFetchSet = new Set();
    routes.forEach(({
      marketMetas
    }) => {
      return marketMetas.forEach(({
        amm
      }) => {
        amm.getAccountsForUpdate().forEach(account => {
          // Only add accountInfos that is not in the Map
          accountsToFetchSet.add(account.toBase58());
        });
      });
    });
    const accountsToFetch = Array.from(accountsToFetchSet);

    if (accountsToFetch.length > 0) {
      const accountInfos = await chunkedGetMultipleAccountInfos(connection, accountsToFetch.map(account => new PublicKey(account)));
      accountInfos.forEach((item, index) => {
        const publicKey = accountsToFetch[index];

        if (item) {
          accountInfosMap.set(publicKey, item);
        }
      });
    }
  }

  routes.forEach(({
    marketMetas
  }) => {
    marketMetas.forEach(({
      amm
    }) => {
      amm.update(accountInfosMap);
    });
  });
}

class Jupiter {
  /* promise because we can choose not to await it when we dont need it */
  constructor(_connection, cluster, tokenRouteSegments, feeCalculator, platformFeeAndAccounts,
  /** Referrer account to collect Serum referrer fees for each given quote mint, the referrer fee is 20% of the Serum protocol fee */
  quoteMintToReferrer,
  /** route cache duration in ms */
  routeCacheDuration = 0,
  /** When set to true (default) native SOL is wrapped and wSOL unwrapped in each swap, otherwise it assumes wSOL is funded when it exists */
  wrapUnwrapSOL = true) {
    this.connection = void 0;
    this.cluster = void 0;
    this.tokenRouteSegments = void 0;
    this.feeCalculator = void 0;
    this.platformFeeAndAccounts = void 0;
    this.quoteMintToReferrer = void 0;
    this.routeCacheDuration = void 0;
    this.wrapUnwrapSOL = void 0;
    this.serumOpenOrdersPromise = undefined;
    this.instructionCache = new Map();
    this.user = void 0;
    this.routeCache = new Map();

    this.exchange = async ({
      route,
      userPublicKey,
      feeAccount
    }) => {
      var _instructions$interme;

      const {
        connection,
        serumOpenOrdersPromise
      } = this;
      const user = userPublicKey || this.user;

      if (!user) {
        throw new Error('user not found');
      }

      const owner = new Owner(user);
      const lastMarketInfoIndex = route.marketInfos.length - 1;
      const inputMint = route.marketInfos[0].inputMint;
      const outputMint = route.marketInfos[lastMarketInfoIndex].outputMint;
      const cacheKey = getCacheMintKey(route.marketInfos);
      let instructions = getInstructionCache({
        instructionCache: this.instructionCache,
        walletPublicKey: owner.publicKey.toBase58(),
        cacheKey
      });

      if (!instructions) {
        const [ataInstructions, openOrdersInstructions] = await Promise.all([routeAtaInstructions(connection, route.marketInfos, owner.publicKey, this.wrapUnwrapSOL), Promise.all(route.marketInfos.map(async ({
          marketMeta: {
            amm
          }
        }) => {
          if (amm instanceof SerumAmm || amm instanceof SplitTradeAmm) {
            if (!amm.market) return;
            return await getOrCreateOpenOrdersAddress(connection, owner.publicKey, amm.market, await serumOpenOrdersPromise);
          }

          return;
        }))]);
        instructions = {
          intermediate: ataInstructions.userIntermediaryTokenAccountResult,
          destination: ataInstructions.userDestinationTokenAccountResult,
          openOrders: openOrdersInstructions
        };
      }

      const sourceInstruction = inputMint.equals(WRAPPED_SOL_MINT) && this.wrapUnwrapSOL ? await createAndCloseWSOLAccount(connection, owner.publicKey, route.inAmount) : { ...getEmptyInstruction(),
        address: await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, inputMint, owner.publicKey)
      }; // Construct platform fee

      feeAccount = feeAccount || this.platformFeeAndAccounts.feeAccounts.get(outputMint.toBase58());
      const platformFee = feeAccount ? {
        feeBps: this.platformFeeAndAccounts.feeBps || Math.floor(route.marketInfos[lastMarketInfoIndex].platformFee.pct * 100),
        feeAccount
      } : undefined;
      const preparedInstructions = await routeToInstructions(owner, instructions.openOrders.map(oo => oo === null || oo === void 0 ? void 0 : oo.address), sourceInstruction.address, (_instructions$interme = instructions.intermediate) === null || _instructions$interme === void 0 ? void 0 : _instructions$interme.address, instructions.destination.address, route, platformFee, this.quoteMintToReferrer);
      const splitSetupRequired = isSplitSetupRequired(route.marketInfos);
      const setupTransactionBuilder = new TransactionBuilder(connection, owner.publicKey, owner);
      const transactionBuilder = new TransactionBuilder(connection, owner.publicKey, owner);
      const cleanupTransactionBuilder = new TransactionBuilder(connection, owner.publicKey, owner);

      if (splitSetupRequired) {
        var _instructions$interme2, _instructions$interme3;

        if (instructions.openOrders) {
          instructions.openOrders.forEach(openOrders => {
            if (openOrders) {
              setupTransactionBuilder.addInstruction(openOrders);
            }
          });
        }

        if (instructions.intermediate) {
          setupTransactionBuilder.addInstruction({ ...instructions.intermediate,
            cleanupInstructions: []
          });
        }

        setupTransactionBuilder.addInstruction({ ...sourceInstruction,
          cleanupInstructions: []
        });
        cleanupTransactionBuilder.addInstruction({ ...getEmptyInstruction(),
          cleanupInstructions: sourceInstruction.cleanupInstructions
        }).addInstruction({ ...getEmptyInstruction(),
          cleanupInstructions: (_instructions$interme2 = (_instructions$interme3 = instructions.intermediate) === null || _instructions$interme3 === void 0 ? void 0 : _instructions$interme3.cleanupInstructions) !== null && _instructions$interme2 !== void 0 ? _instructions$interme2 : []
        }); // if source address the same as destination address, then we don't need to setup or cleanup twice, mainly SOL-SOL

        if (!sourceInstruction.address.equals(instructions.destination.address)) {
          setupTransactionBuilder.addInstruction({ ...instructions.destination,
            cleanupInstructions: []
          });
          cleanupTransactionBuilder.addInstruction({ ...getEmptyInstruction(),
            cleanupInstructions: instructions.destination.cleanupInstructions
          });
        }
      } else {
        if (instructions.openOrders) {
          instructions.openOrders.forEach(openOrders => {
            if (openOrders) {
              transactionBuilder.addInstruction(openOrders);
            }
          });
        }

        if (instructions.intermediate) {
          transactionBuilder.addInstruction(instructions.intermediate);
        }

        transactionBuilder.addInstruction(sourceInstruction); // if source address the same as destination address, then we don't need to setup or cleanup twice, mainly SOL-SOL

        if (!sourceInstruction.address.equals(instructions.destination.address)) {
          transactionBuilder.addInstruction(instructions.destination);
        }
      }

      transactionBuilder.addInstruction(preparedInstructions);
      const recentBlockHash = (await this.connection.getRecentBlockhash('singleGossip')).blockhash;
      const {
        transaction: setupTransaction
      } = await setupTransactionBuilder.build(recentBlockHash);
      const {
        transaction
      } = await transactionBuilder.build(recentBlockHash);
      const {
        transaction: cleanupTransaction
      } = await cleanupTransactionBuilder.build(recentBlockHash); // Is this horrible? Yes.

      const [setupTransactionObject, swapTransactionObject, cleanupTransactionObject] = (() => {
        if (setupTransaction.instructions.length && cleanupTransaction.instructions.length) {
          return [setupTransaction, transaction, cleanupTransaction];
        } else if (setupTransaction.instructions.length) {
          const [first, second] = [setupTransaction, transaction];
          return [first, second, undefined];
        } else if (cleanupTransaction.instructions.length) {
          const [second, third] = [transaction, cleanupTransaction];
          return [undefined, second, third];
        } else {
          return [undefined, transaction, undefined];
        }
      })();

      return {
        transactions: {
          setupTransaction: setupTransactionObject,
          swapTransaction: swapTransactionObject,
          cleanupTransaction: cleanupTransactionObject
        },
        execute: async ({
          wallet,
          confirmationWaiterFactory
        } = {}) => {

          try {
            const transactions = [setupTransactionObject, swapTransactionObject, cleanupTransactionObject].filter(Boolean);
            const totalTxs = transactions.length;

            if (owner.isKeyPair && owner.signer) {
              transactions.forEach(transaction => {
                transaction.sign(owner.signer);
              });
            } else {
              if (!wallet) {
                throw new Error('Signer wallet not found');
              }

              if (totalTxs > 1) {
                await wallet.signAllTransactions(transactions);
              } else {
                await wallet.signTransaction(transactions[0]);
              }
            }

            let setupError;

            if (setupTransactionObject) {
              try {
                const setupTxid = await connection.sendRawTransaction(setupTransactionObject.serialize(), {
                  skipPreflight: true
                });

                if (confirmationWaiterFactory) {
                  await confirmationWaiterFactory(setupTxid, totalTxs);
                } else {
                  await getConfirmTransaction(connection, setupTxid);
                }
              } catch (e) {
                setupError = e;
                throw setupError;
              }
            }

            try {
              const txid = await connection.sendRawTransaction(swapTransactionObject.serialize(), {
                skipPreflight: true
              });
              let transactionResponse = null;

              if (confirmationWaiterFactory) {
                transactionResponse = await confirmationWaiterFactory(txid, totalTxs);
              }

              if (!transactionResponse) {
                transactionResponse = await getConfirmTransaction(connection, txid);
              }

              const [sourceTokenBalanceChange, destinationTokenBalanceChange] = getTokenBalanceChangesFromTransactionResponse(inputMint, outputMint, sourceInstruction.address, instructions.destination.address, transactionResponse);
              return {
                txid,
                inputAddress: sourceInstruction.address,
                outputAddress: instructions.destination.address,
                inputAmount: sourceTokenBalanceChange,
                outputAmount: destinationTokenBalanceChange
              };
            } catch (e) {
              throw e;
            } finally {
              if (cleanupTransactionObject && !setupError) {
                const cleanupTxId = await connection.sendRawTransaction(cleanupTransactionObject.serialize(), {
                  skipPreflight: true
                });
                await (confirmationWaiterFactory === null || confirmationWaiterFactory === void 0 ? void 0 : confirmationWaiterFactory(cleanupTxId, totalTxs));
              }
            }
          } catch (e) {
            const transactionError = e;

            return {
              error: transactionError
            };
          } finally {
            var _instructions, _instructions2, _instructions2$interm, _instructions3;

            const hasOpenOrders = (_instructions = instructions) === null || _instructions === void 0 ? void 0 : _instructions.openOrders.some(oo => oo === null || oo === void 0 ? void 0 : oo.instructions.length);

            if (hasOpenOrders || (_instructions2 = instructions) !== null && _instructions2 !== void 0 && (_instructions2$interm = _instructions2.intermediate) !== null && _instructions2$interm !== void 0 && _instructions2$interm.instructions.length || (_instructions3 = instructions) !== null && _instructions3 !== void 0 && _instructions3.destination.instructions.length) {
              deleteInstructionCache({
                instructionCache: this.instructionCache,
                walletPublicKey: owner.publicKey.toBase58()
              });
            }

            this.routeCache.clear();
          }
        }
      };
    };

    this.connection = _connection;
    this.cluster = cluster;
    this.tokenRouteSegments = tokenRouteSegments;
    this.feeCalculator = feeCalculator;
    this.platformFeeAndAccounts = platformFeeAndAccounts;
    this.quoteMintToReferrer = quoteMintToReferrer;
    this.routeCacheDuration = routeCacheDuration;
    this.wrapUnwrapSOL = wrapUnwrapSOL;
  }
  /**
   * load performs the necessary async scaffolding of the Jupiter object
   */


  static async load({
    connection,
    cluster,
    user,
    platformFeeAndAccounts = NO_PLATFORM_FEE,
    quoteMintToReferrer,
    routeCacheDuration = 0,
    wrapUnwrapSOL = true,
    // @internal,
    marketUrl
  }) {
    const [tokenRouteSegments, {
      value: {
        feeCalculator
      }
    }, defaultQuoteMintToReferrer] = await Promise.all([Jupiter.fetchTokenRouteSegments(connection, cluster, marketUrl), connection.getRecentBlockhashAndContext('processed'), getPlatformFeeAccounts(connection, new PublicKey(JUPITER_WALLET))]);
    const jupiter = new Jupiter(connection, cluster, tokenRouteSegments, feeCalculator, platformFeeAndAccounts, quoteMintToReferrer || defaultQuoteMintToReferrer, routeCacheDuration, wrapUnwrapSOL);
    if (user) jupiter.setUserPublicKey(user);
    return jupiter;
  }

  getPublicKeysToUpdate() {
    const publicKeys = new Set();
    this.tokenRouteSegments.forEach(tokenRouteSegment => {
      Array.from(tokenRouteSegment.values()).forEach(marketInfos => {
        marketInfos.forEach(({
          amm
        }) => {
          amm.getAccountsForUpdate().forEach(account => {
            publicKeys.add(account.toBase58());
          });
        });
      });
    });
    return Array.from(publicKeys);
  }

  async computeRoutes(inputMint, outputMint, inputAmount, slippage, shouldFetchRoutes = false,
  /* external accountInfosMap that allow external fetching  */
  externalAccountInfosMap, feeBps = 0) {
    const getDepositAndFees = async marketInfos => {
      if (this.user && this.serumOpenOrdersPromise) {
        const owner = new Owner(this.user);
        return getDepositAndFeeFromInstructions({
          connection: this.connection,
          feeCalculator: this.feeCalculator,
          instructionCache: this.instructionCache,
          marketInfos: marketInfos,
          serumOpenOrdersPromise: this.serumOpenOrdersPromise,
          userPublicKey: owner.publicKey,
          unwrapSOL: this.wrapUnwrapSOL
        });
      }
    }; // Platform fee can only be applied when fee account exists


    const platformFeeBps = feeBps || (this.platformFeeAndAccounts.feeAccounts.get(outputMint.toBase58()) ? this.platformFeeAndAccounts.feeBps : 0);
    const now = new Date().getTime(); // do sort so that it's always the same order for the same inputMint and outputMint and vice versa

    const inputMintAndOutputMint = [inputMint.toBase58(), outputMint.toBase58()].sort((a, b) => a.localeCompare(b)).join('');
    const routeCache = this.routeCache.get(inputMintAndOutputMint);
    const routes = computeRoutes(inputMint, outputMint, this.tokenRouteSegments);

    if (routeCache) {
      const {
        fetchTimestamp
      } = routeCache;

      if (now - fetchTimestamp > this.routeCacheDuration) {
        shouldFetchRoutes = true;
      }
    } else {
      shouldFetchRoutes = true;
    }

    if (shouldFetchRoutes) {
      await fetchRoutes(this.connection, routes, externalAccountInfosMap);
      this.routeCache.set(inputMintAndOutputMint, {
        fetchTimestamp: new Date().getTime()
      });
    }

    try {
      const routesInfos = computeRouteInfos({
        routes,
        amount: inputAmount,
        inputMint,
        outputMint,
        getDepositAndFeeForRoute: getDepositAndFees,
        slippage,
        platformFeeBps
      });
      return {
        routesInfos,

        /* indicate if the result is fetched or get from cache */
        cached: !shouldFetchRoutes
      };
    } catch (e) {
      throw e;
    } finally {
      // clear cache if it is expired
      this.routeCache.forEach(({
        fetchTimestamp
      }, key) => {
        if (fetchTimestamp - now > this.routeCacheDuration) {
          this.routeCache.delete(key);
        }
      });
    }
  }

  setUserPublicKey(userPublicKey) {
    this.user = userPublicKey;
    const owner = new Owner(this.user);
    this.serumOpenOrdersPromise = Jupiter.findSerumOpenOrdersForOwner({
      connection: this.connection,
      cluster: this.cluster,
      userPublicKey: owner.publicKey
    });
  }
  /**
   * The token route segments contains all the routes and the market meta information.
   */


  static async fetchTokenRouteSegments(connection, cluster, marketUrl) {
    const amms = await getAllAmms(connection, cluster, marketUrl);
    const tokenRouteSegments = getTokenRouteSegments(amms);
    return tokenRouteSegments;
  }
  /**
   * This generate a routeMap which represents every possible output token mint for a given input token mint.
   * For example, we have SOL to USDC and this pairs have many routings like
   * SOL => USDT
   * USDT => USDC
   * SOL => USDC
   *
   * From here we know that we can have 2 different routing of SOL => USDC.
   * We do single level routing map but for all coins which result in the route map below:
   * SOL => USDT, USDC
   * USDT => SOL
   * USDC => SOL, USDT
   *
   * From this route map we can map out all possible route from one to another by checking the intersection.
   */


  getRouteMap() {
    return computeRouteMap(this.tokenRouteSegments);
  }
  /**
   * Query existing open order account, this query is slow.
   * We suggest to fetch this in the background.
   */


}

Jupiter.findSerumOpenOrdersForOwner = async ({
  userPublicKey,
  cluster,
  connection
}) => {
  const newMarketToOpenOrdersAddress = new Map();

  if (userPublicKey) {
    const programId = cluster === 'mainnet-beta' ? MAINNET_SERUM_DEX_PROGRAM : DEVNET_SERUM_DEX_PROGRAM;
    const allOpenOrders = await OpenOrders.findForOwner(connection, userPublicKey, programId);
    allOpenOrders.forEach(openOrders => {
      newMarketToOpenOrdersAddress.set(openOrders.market.toString(), openOrders.address);
    });
  }

  return newMarketToOpenOrdersAddress;
};

Jupiter.createCreateTokenLedgerInstruction = createCreateTokenLedgerInstruction;
Jupiter.createOpenOrdersInstruction = createOpenOrdersInstruction;
Jupiter.createRaydiumSwapInstruction = createRaydiumSwapInstruction;
Jupiter.createMercurialExchangeInstruction = createMercurialExchangeInstruction;
Jupiter.createSerumSwapInstruction = createSerumSwapInstruction;
Jupiter.createSetTokenLedgerInstruction = createSetTokenLedgerInstruction;

export { AldrinAmm, CropperAmm, Jupiter, MARKETS_URL, MercurialAmm, RaydiumAmm, SaberAmm, SenchaAmm, SerumAmm, SplTokenSwapAmm, TOKEN_LIST_URL, TransactionBuilder, getEmptyInstruction, getPlatformFeeAccounts, getRouteInfoUniqueId };
//# sourceMappingURL=core.esm.js.map
