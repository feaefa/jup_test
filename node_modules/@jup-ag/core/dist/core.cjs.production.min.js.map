{"version":3,"file":"core.cjs.production.min.js","sources":["../src/lib/idl/jupiter.ts","../src/constants.ts","../src/utils/layout.ts","../src/lib/cropper/swapLayout.ts","../src/lib/jupiterInstruction.ts","../src/lib/saber/saberAddDecimalsAmm.ts","../src/utils/getTwoPermutations.ts","../src/lib/amm.ts","../src/lib/raydium/pools.ts","../src/lib/raydium/raydiumAmm.ts","../src/lib/serum/market.ts","../src/lib/serum/serumAmm.ts","../src/lib/split-trade/splitTradeAmm.ts","../src/lib/market.ts","../src/utils/deserializeAccount.ts","../src/lib/saber/saberAmm.ts","../src/lib/aldrin/percentage.ts","../src/lib/aldrin/poolState.ts","../src/lib/aldrin/aldrinAmm.ts","../src/lib/spl-token-swap/splTokenSwapPools.ts","../src/lib/spl-token-swap/tokenSwapLayout.ts","../src/lib/spl-token-swap/splTokenSwapAmm.ts","../src/lib/mercurial/swapLayout.ts","../src/lib/mercurial/mercurialAmm.ts","../src/lib/cropper/cropperAmm.ts","../src/lib/sencha/swapLayout.ts","../src/lib/sencha/senchaAmm.ts","../src/lib/routes.ts","../src/lib/cache.ts","../src/utils/token.ts","../src/lib/routeToInstructions.ts","../src/lib/serum/openOrders.ts","../src/utils/instruction.ts","../src/lib/fee.ts","../src/utils/TransactionBuilder.ts","../src/utils/Owner.ts","../src/lib/error.ts","../src/utils/transactionHelpers.ts","../src/lib/jupiter.ts","../src/lib/computeRouteInfos.ts","../src/utils/chunkedGetMultipleAccountInfos.ts","../src/utils/chunks.ts","../src/lib/ammFactory.ts"],"sourcesContent":["export type Jupiter = {\n  version: '0.1.0';\n  name: 'jupiter';\n  instructions: [\n    {\n      name: 'mercurialExchange';\n      accounts: [\n        {\n          name: 'swapProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'swapState';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'poolAuthority';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'userTransferAuthority';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'sourceTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'destinationTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'saberExchange';\n      accounts: [\n        {\n          name: 'swapProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'swap';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'swapAuthority';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'userAuthority';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'clock';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'inputUserAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'inputTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'outputUserAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'outputTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'feesTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'saberAddDecimalsDeposit';\n      accounts: [\n        {\n          name: 'addDecimalsProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'wrapper';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'wrapperMint';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'wrapperUnderlyingTokens';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'owner';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'userUnderlyingTokens';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userWrappedTokens';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'saberAddDecimalsWithdraw';\n      accounts: [\n        {\n          name: 'addDecimalsProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'wrapper';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'wrapperMint';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'wrapperUnderlyingTokens';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'owner';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'userUnderlyingTokens';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userWrappedTokens';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'senchaExchange';\n      accounts: [\n        {\n          name: 'swapProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'swap';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userAuthority';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'inputUserAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'inputTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'inputFeesAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'outputUserAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'outputTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'outputFeesAccount';\n          isMut: true;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'serumSwap';\n      accounts: [\n        {\n          name: 'market';\n          accounts: [\n            {\n              name: 'market';\n              isMut: true;\n              isSigner: false;\n            },\n            {\n              name: 'openOrders';\n              isMut: true;\n              isSigner: false;\n            },\n            {\n              name: 'requestQueue';\n              isMut: true;\n              isSigner: false;\n            },\n            {\n              name: 'eventQueue';\n              isMut: true;\n              isSigner: false;\n            },\n            {\n              name: 'bids';\n              isMut: true;\n              isSigner: false;\n            },\n            {\n              name: 'asks';\n              isMut: true;\n              isSigner: false;\n            },\n            {\n              name: 'coinVault';\n              isMut: true;\n              isSigner: false;\n            },\n            {\n              name: 'pcVault';\n              isMut: true;\n              isSigner: false;\n            },\n            {\n              name: 'vaultSigner';\n              isMut: false;\n              isSigner: false;\n            },\n          ];\n        },\n        {\n          name: 'authority';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'orderPayerTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'coinWallet';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'pcWallet';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'dexProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'rent';\n          isMut: false;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'side';\n          type: {\n            defined: 'Side';\n          };\n        },\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'tokenSwap';\n      accounts: [\n        {\n          name: 'tokenSwapProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'swap';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'authority';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'userTransferAuthority';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'source';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'swapSource';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'swapDestination';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'destination';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'poolMint';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'poolFee';\n          isMut: true;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'stepTokenSwap';\n      accounts: [\n        {\n          name: 'tokenSwapProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'swap';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'authority';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'userTransferAuthority';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'source';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'swapSource';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'swapDestination';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'destination';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'poolMint';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'poolFee';\n          isMut: true;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'cropperTokenSwap';\n      accounts: [\n        {\n          name: 'tokenSwapProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'swap';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'swapState';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'authority';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'userTransferAuthority';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'source';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'swapSource';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'swapDestination';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'destination';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'poolMint';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'poolFee';\n          isMut: true;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'raydiumSwap';\n      accounts: [\n        {\n          name: 'swapProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'ammId';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'ammAuthority';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'ammOpenOrders';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'ammTargetOrders';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'poolCoinTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'poolPcTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumProgramId';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'serumMarket';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumBids';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumAsks';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumEventQueue';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumCoinVaultAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumPcVaultAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumVaultSigner';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'userSourceTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userDestinationTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userSourceOwner';\n          isMut: false;\n          isSigner: true;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'raydiumSwapV2';\n      accounts: [\n        {\n          name: 'swapProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'ammId';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'ammAuthority';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'ammOpenOrders';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'poolCoinTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'poolPcTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumProgramId';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'serumMarket';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumBids';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumAsks';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumEventQueue';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumCoinVaultAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumPcVaultAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'serumVaultSigner';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'userSourceTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userDestinationTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userSourceOwner';\n          isMut: false;\n          isSigner: true;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'aldrinSwap';\n      accounts: [\n        {\n          name: 'swapProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'pool';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'poolSigner';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'poolMint';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'baseTokenVault';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'quoteTokenVault';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'feePoolTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'walletAuthority';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'userBaseTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userQuoteTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'side';\n          type: {\n            defined: 'Side';\n          };\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'aldrinV2Swap';\n      accounts: [\n        {\n          name: 'swapProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'pool';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'poolSigner';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'poolMint';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'baseTokenVault';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'quoteTokenVault';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'feePoolTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'walletAuthority';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'userBaseTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userQuoteTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'curve';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'inAmount';\n          type: {\n            option: 'u64';\n          };\n        },\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'side';\n          type: {\n            defined: 'Side';\n          };\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'riskCheckAndFee';\n      accounts: [\n        {\n          name: 'tokenLedger';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userDestinationTokenAccount';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'userTransferAuthority';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'tokenProgram';\n          isMut: false;\n          isSigner: false;\n        },\n      ];\n      args: [\n        {\n          name: 'minimumOutAmount';\n          type: 'u64';\n        },\n        {\n          name: 'platformFeeBps';\n          type: 'u8';\n        },\n      ];\n    },\n    {\n      name: 'initializeTokenLedger';\n      accounts: [\n        {\n          name: 'tokenLedger';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'payer';\n          isMut: false;\n          isSigner: true;\n        },\n        {\n          name: 'systemProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'rent';\n          isMut: false;\n          isSigner: false;\n        },\n      ];\n      args: [];\n    },\n    {\n      name: 'setTokenLedger';\n      accounts: [\n        {\n          name: 'tokenLedger';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'tokenAccount';\n          isMut: false;\n          isSigner: false;\n        },\n      ];\n      args: [];\n    },\n    {\n      name: 'createOpenOrders';\n      accounts: [\n        {\n          name: 'openOrders';\n          isMut: true;\n          isSigner: false;\n        },\n        {\n          name: 'payer';\n          isMut: true;\n          isSigner: true;\n        },\n        {\n          name: 'dexProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'systemProgram';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'rent';\n          isMut: false;\n          isSigner: false;\n        },\n        {\n          name: 'market';\n          isMut: false;\n          isSigner: false;\n        },\n      ];\n      args: [];\n    },\n  ];\n  accounts: [\n    {\n      name: 'tokenLedger';\n      type: {\n        kind: 'struct';\n        fields: [\n          {\n            name: 'tokenAccount';\n            type: 'publicKey';\n          },\n          {\n            name: 'amount';\n            type: 'u64';\n          },\n        ];\n      };\n    },\n  ];\n  types: [\n    {\n      name: 'Swap';\n      type: {\n        kind: 'struct';\n        fields: [\n          {\n            name: 'tokens';\n            type: 'u64';\n          },\n          {\n            name: 'minTokens';\n            type: 'u64';\n          },\n          {\n            name: 'side';\n            type: {\n              defined: 'Side';\n            };\n          },\n        ];\n      };\n    },\n    {\n      name: 'Swap';\n      type: {\n        kind: 'struct';\n        fields: [\n          {\n            name: 'tokens';\n            type: 'u64';\n          },\n          {\n            name: 'minTokens';\n            type: 'u64';\n          },\n          {\n            name: 'side';\n            type: {\n              defined: 'Side';\n            };\n          },\n        ];\n      };\n    },\n    {\n      name: 'Deposit';\n      type: {\n        kind: 'struct';\n        fields: [\n          {\n            name: 'amount';\n            type: 'u64';\n          },\n        ];\n      };\n    },\n    {\n      name: 'Withdraw';\n      type: {\n        kind: 'struct';\n        fields: [\n          {\n            name: 'maxBurnAmount';\n            type: 'u64';\n          },\n        ];\n      };\n    },\n    {\n      name: 'Direction';\n      type: {\n        kind: 'enum';\n        variants: [\n          {\n            name: 'LeftToRight';\n          },\n          {\n            name: 'RightToLeft';\n          },\n        ];\n      };\n    },\n    {\n      name: 'Side';\n      type: {\n        kind: 'enum';\n        variants: [\n          {\n            name: 'Bid';\n          },\n          {\n            name: 'Ask';\n          },\n        ];\n      };\n    },\n  ];\n  errors: [\n    {\n      code: 6000;\n      name: 'SlippageToleranceExceeded';\n      msg: 'Slippage tolerance exceeded';\n    },\n    {\n      code: 6001;\n      name: 'InvalidTokenLedger';\n      msg: 'Invalid token ledger';\n    },\n    {\n      code: 6002;\n      name: 'MissingTokenLedger';\n      msg: 'Missing token ledger';\n    },\n    {\n      code: 6003;\n      name: 'MissingMercurialExchangeTokenAccount';\n      msg: 'Missing mercurial exchange token account';\n    },\n    {\n      code: 6004;\n      name: 'LedgerTokenAccountDoesNotMatch';\n      msg: 'Ledger token account does not match';\n    },\n    {\n      code: 6005;\n      name: 'MissingPlatformFeeAccount';\n      msg: 'Missing platform fee account';\n    },\n    {\n      code: 6006;\n      name: 'InvalidCalculation';\n      msg: 'Invalid calculation';\n    },\n  ];\n};\n\nexport const IDL: Jupiter = {\n  version: '0.1.0',\n  name: 'jupiter',\n  instructions: [\n    {\n      name: 'mercurialExchange',\n      accounts: [\n        {\n          name: 'swapProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'swapState',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'poolAuthority',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'userTransferAuthority',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'sourceTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'destinationTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'saberExchange',\n      accounts: [\n        {\n          name: 'swapProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'swap',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'swapAuthority',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'userAuthority',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'clock',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'inputUserAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'inputTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'outputUserAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'outputTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'feesTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'saberAddDecimalsDeposit',\n      accounts: [\n        {\n          name: 'addDecimalsProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'wrapper',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'wrapperMint',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'wrapperUnderlyingTokens',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'owner',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'userUnderlyingTokens',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userWrappedTokens',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'saberAddDecimalsWithdraw',\n      accounts: [\n        {\n          name: 'addDecimalsProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'wrapper',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'wrapperMint',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'wrapperUnderlyingTokens',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'owner',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'userUnderlyingTokens',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userWrappedTokens',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'senchaExchange',\n      accounts: [\n        {\n          name: 'swapProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'swap',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userAuthority',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'inputUserAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'inputTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'inputFeesAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'outputUserAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'outputTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'outputFeesAccount',\n          isMut: true,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'serumSwap',\n      accounts: [\n        {\n          name: 'market',\n          accounts: [\n            {\n              name: 'market',\n              isMut: true,\n              isSigner: false,\n            },\n            {\n              name: 'openOrders',\n              isMut: true,\n              isSigner: false,\n            },\n            {\n              name: 'requestQueue',\n              isMut: true,\n              isSigner: false,\n            },\n            {\n              name: 'eventQueue',\n              isMut: true,\n              isSigner: false,\n            },\n            {\n              name: 'bids',\n              isMut: true,\n              isSigner: false,\n            },\n            {\n              name: 'asks',\n              isMut: true,\n              isSigner: false,\n            },\n            {\n              name: 'coinVault',\n              isMut: true,\n              isSigner: false,\n            },\n            {\n              name: 'pcVault',\n              isMut: true,\n              isSigner: false,\n            },\n            {\n              name: 'vaultSigner',\n              isMut: false,\n              isSigner: false,\n            },\n          ],\n        },\n        {\n          name: 'authority',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'orderPayerTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'coinWallet',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'pcWallet',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'dexProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'rent',\n          isMut: false,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'side',\n          type: {\n            defined: 'Side',\n          },\n        },\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'tokenSwap',\n      accounts: [\n        {\n          name: 'tokenSwapProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'swap',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'authority',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'userTransferAuthority',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'source',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'swapSource',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'swapDestination',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'destination',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'poolMint',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'poolFee',\n          isMut: true,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'stepTokenSwap',\n      accounts: [\n        {\n          name: 'tokenSwapProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'swap',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'authority',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'userTransferAuthority',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'source',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'swapSource',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'swapDestination',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'destination',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'poolMint',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'poolFee',\n          isMut: true,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'cropperTokenSwap',\n      accounts: [\n        {\n          name: 'tokenSwapProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'swap',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'swapState',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'authority',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'userTransferAuthority',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'source',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'swapSource',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'swapDestination',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'destination',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'poolMint',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'poolFee',\n          isMut: true,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'raydiumSwap',\n      accounts: [\n        {\n          name: 'swapProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'ammId',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'ammAuthority',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'ammOpenOrders',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'ammTargetOrders',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'poolCoinTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'poolPcTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumProgramId',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'serumMarket',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumBids',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumAsks',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumEventQueue',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumCoinVaultAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumPcVaultAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumVaultSigner',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'userSourceTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userDestinationTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userSourceOwner',\n          isMut: false,\n          isSigner: true,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'raydiumSwapV2',\n      accounts: [\n        {\n          name: 'swapProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'ammId',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'ammAuthority',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'ammOpenOrders',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'poolCoinTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'poolPcTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumProgramId',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'serumMarket',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumBids',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumAsks',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumEventQueue',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumCoinVaultAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumPcVaultAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'serumVaultSigner',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'userSourceTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userDestinationTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userSourceOwner',\n          isMut: false,\n          isSigner: true,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'aldrinSwap',\n      accounts: [\n        {\n          name: 'swapProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'pool',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'poolSigner',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'poolMint',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'baseTokenVault',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'quoteTokenVault',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'feePoolTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'walletAuthority',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'userBaseTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userQuoteTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'side',\n          type: {\n            defined: 'Side',\n          },\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'aldrinV2Swap',\n      accounts: [\n        {\n          name: 'swapProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'pool',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'poolSigner',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'poolMint',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'baseTokenVault',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'quoteTokenVault',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'feePoolTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'walletAuthority',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'userBaseTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userQuoteTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'curve',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'inAmount',\n          type: {\n            option: 'u64',\n          },\n        },\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'side',\n          type: {\n            defined: 'Side',\n          },\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'riskCheckAndFee',\n      accounts: [\n        {\n          name: 'tokenLedger',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userDestinationTokenAccount',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'userTransferAuthority',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'tokenProgram',\n          isMut: false,\n          isSigner: false,\n        },\n      ],\n      args: [\n        {\n          name: 'minimumOutAmount',\n          type: 'u64',\n        },\n        {\n          name: 'platformFeeBps',\n          type: 'u8',\n        },\n      ],\n    },\n    {\n      name: 'initializeTokenLedger',\n      accounts: [\n        {\n          name: 'tokenLedger',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'payer',\n          isMut: false,\n          isSigner: true,\n        },\n        {\n          name: 'systemProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'rent',\n          isMut: false,\n          isSigner: false,\n        },\n      ],\n      args: [],\n    },\n    {\n      name: 'setTokenLedger',\n      accounts: [\n        {\n          name: 'tokenLedger',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'tokenAccount',\n          isMut: false,\n          isSigner: false,\n        },\n      ],\n      args: [],\n    },\n    {\n      name: 'createOpenOrders',\n      accounts: [\n        {\n          name: 'openOrders',\n          isMut: true,\n          isSigner: false,\n        },\n        {\n          name: 'payer',\n          isMut: true,\n          isSigner: true,\n        },\n        {\n          name: 'dexProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'systemProgram',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'rent',\n          isMut: false,\n          isSigner: false,\n        },\n        {\n          name: 'market',\n          isMut: false,\n          isSigner: false,\n        },\n      ],\n      args: [],\n    },\n  ],\n  accounts: [\n    {\n      name: 'tokenLedger',\n      type: {\n        kind: 'struct',\n        fields: [\n          {\n            name: 'tokenAccount',\n            type: 'publicKey',\n          },\n          {\n            name: 'amount',\n            type: 'u64',\n          },\n        ],\n      },\n    },\n  ],\n  types: [\n    {\n      name: 'Swap',\n      type: {\n        kind: 'struct',\n        fields: [\n          {\n            name: 'tokens',\n            type: 'u64',\n          },\n          {\n            name: 'minTokens',\n            type: 'u64',\n          },\n          {\n            name: 'side',\n            type: {\n              defined: 'Side',\n            },\n          },\n        ],\n      },\n    },\n    {\n      name: 'Swap',\n      type: {\n        kind: 'struct',\n        fields: [\n          {\n            name: 'tokens',\n            type: 'u64',\n          },\n          {\n            name: 'minTokens',\n            type: 'u64',\n          },\n          {\n            name: 'side',\n            type: {\n              defined: 'Side',\n            },\n          },\n        ],\n      },\n    },\n    {\n      name: 'Deposit',\n      type: {\n        kind: 'struct',\n        fields: [\n          {\n            name: 'amount',\n            type: 'u64',\n          },\n        ],\n      },\n    },\n    {\n      name: 'Withdraw',\n      type: {\n        kind: 'struct',\n        fields: [\n          {\n            name: 'maxBurnAmount',\n            type: 'u64',\n          },\n        ],\n      },\n    },\n    {\n      name: 'Direction',\n      type: {\n        kind: 'enum',\n        variants: [\n          {\n            name: 'LeftToRight',\n          },\n          {\n            name: 'RightToLeft',\n          },\n        ],\n      },\n    },\n    {\n      name: 'Side',\n      type: {\n        kind: 'enum',\n        variants: [\n          {\n            name: 'Bid',\n          },\n          {\n            name: 'Ask',\n          },\n        ],\n      },\n    },\n  ],\n  errors: [\n    {\n      code: 6000,\n      name: 'SlippageToleranceExceeded',\n      msg: 'Slippage tolerance exceeded',\n    },\n    {\n      code: 6001,\n      name: 'InvalidTokenLedger',\n      msg: 'Invalid token ledger',\n    },\n    {\n      code: 6002,\n      name: 'MissingTokenLedger',\n      msg: 'Missing token ledger',\n    },\n    {\n      code: 6003,\n      name: 'MissingMercurialExchangeTokenAccount',\n      msg: 'Missing mercurial exchange token account',\n    },\n    {\n      code: 6004,\n      name: 'LedgerTokenAccountDoesNotMatch',\n      msg: 'Ledger token account does not match',\n    },\n    {\n      code: 6005,\n      name: 'MissingPlatformFeeAccount',\n      msg: 'Missing platform fee account',\n    },\n    {\n      code: 6006,\n      name: 'InvalidCalculation',\n      msg: 'Invalid calculation',\n    },\n  ],\n};\n","import { Fraction } from '@jup-ag/math';\nimport JSBI from 'jsbi';\nimport { Cluster, PublicKey } from '@solana/web3.js';\n\nexport const WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\nexport const MAINNET_SERUM_DEX_PROGRAM = new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin');\nexport const DEVNET_SERUM_DEX_PROGRAM = new PublicKey('DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY');\n\nexport const MARKETS_URL: Record<Cluster, string> = {\n  devnet: 'https://api.jup.ag/api/markets/cache/devnet',\n  'mainnet-beta': 'https://cache.jup.ag/markets?v=3',\n  testnet: 'https://api.jup.ag/api/markets/cache/devnet',\n};\n\nexport const TOKEN_LIST_URL: Record<Cluster, string> = {\n  devnet: 'https://api.jup.ag/api/tokens/devnet',\n  testnet: 'https://api.jup.ag/api/markets/devnet',\n  'mainnet-beta': 'https://cache.jup.ag/tokens',\n};\n\nexport const LAMPORTS_PER_SIGNATURE = 5000;\n\nexport const RAYDIUM_AMM_V4_PROGRAM_ID = new PublicKey('675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8');\n\nexport const ALDRIN_SWAP_PROGRAM_ID = new PublicKey('AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6');\n\n// https://github.com/aldrin-exchange/aldrin-sdk/blob/f93fe3f2d847d79d8ddff507d8d4f62fd803421b/src/v2.json\nexport const ALDRIN_SWAP_V2_PROGRAM_ID = new PublicKey('CURVGoZn8zycx6FXwwevgBTB2gVvdbGTEpvMJDbgs2t4');\n\nexport const SABER_ADD_DECIMALS_PROGRAM_ID = new PublicKey('DecZY86MU5Gj7kppfUCEmd4LbXXuyZH1yHaP2NTqdiZB');\n\nexport const CROPPER_PROGRAM_ID = new PublicKey('CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh');\n\nexport const SENCHA_PROGRAM_ID = new PublicKey('SCHAtsf8mbjyjiv4LkhLKutTf6JnZAbdJKFkXQNMFHZ');\n\nexport const ZERO_FRACTION = new Fraction(JSBI.BigInt(0), JSBI.BigInt(1));\n\nexport const JUPITER_WALLET = new PublicKey('BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9');\n\nexport const MERCURIAL_SWAP_PROGRAM_ID = new PublicKey('MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky');\n","import { blob, Layout, Structure, u8, union } from '@solana/buffer-layout';\nimport { u64 } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\n\nclass PublicKeyLayout extends Layout<PublicKey> {\n  private layout: Layout<any>;\n\n  constructor(property?: string) {\n    const layout = blob(32);\n    super(layout.span, property);\n    this.layout = layout;\n  }\n\n  getSpan(b: Uint8Array, offset?: number) {\n    return this.layout.getSpan(b, offset);\n  }\n\n  decode(b: Uint8Array, offset?: number): PublicKey {\n    return new PublicKey(this.layout.decode(b, offset));\n  }\n\n  encode(src: PublicKey, b: Uint8Array, offset: number): number {\n    return this.layout.encode(src.toBuffer(), b, offset);\n  }\n}\n\n/**\n * Layout for a public key\n */\nexport const publicKey = (property: string) => new PublicKeyLayout(property);\n\nclass U64Layout extends Layout<u64> {\n  private layout: Layout<any>;\n\n  constructor(span = 8, property: string) {\n    const layout = blob(span);\n    super(layout.span, property);\n    this.layout = layout;\n  }\n\n  getSpan(b: Uint8Array, offset?: number) {\n    return this.layout.getSpan(b, offset);\n  }\n\n  decode(b: Uint8Array, offset?: number): u64 {\n    const bn = new u64(this.layout.decode(b, offset), 10, 'le');\n\n    return bn;\n  }\n\n  encode(src: u64, b: Uint8Array, offset: number): number {\n    return this.layout.encode(src.toArrayLike(Buffer, 'le', this.layout.span), b, offset);\n  }\n}\n\n/**\n * Layout for a 64bit unsigned value\n */\nexport const uint64 = (property: string) => new U64Layout(8, property);\n\nexport const uint128 = (property: string) => new U64Layout(16, property);\n\nexport const rustEnum = (variants: Structure<any>[], property: string) => {\n  // @ts-expect-error TODO: fix this\n  const unionLayout = union(u8(), u8(), property);\n  variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property || ''));\n  return unionLayout;\n};\n","import { findProgramAddressSync } from '@project-serum/anchor/dist/cjs/utils/pubkey';\nimport { blob, struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/spl-token';\nimport { AccountInfo, PublicKey } from '@solana/web3.js';\nimport { publicKey, uint64 } from '../../utils/layout';\n\ninterface CropperTokenSwapLayout {\n  version: number;\n  isInitialized: number;\n  nonce: number;\n  ammId: PublicKey;\n  serumProgramId: PublicKey;\n  serumMarket: PublicKey;\n  tokenProgramId: PublicKey;\n  tokenAAccount: PublicKey;\n  tokenBAccount: PublicKey;\n  poolMint: PublicKey;\n  mintA: PublicKey;\n  mintB: PublicKey;\n}\n\nexport const CropperTokenSwapLayout = struct<CropperTokenSwapLayout>([\n  u8('version'),\n  u8('isInitialized'),\n  u8('nonce'),\n  publicKey('ammId'),\n  publicKey('serumProgramId'),\n  publicKey('serumMarket'),\n  publicKey('tokenProgramId'),\n  publicKey('tokenAAccount'),\n  publicKey('tokenBAccount'),\n  publicKey('poolMint'),\n  publicKey('mintA'),\n  publicKey('mintB'),\n]);\n\ninterface CropperStateLayout {\n  isInitialized: number;\n  stateOwner: PublicKey;\n  feeOwner: PublicKey;\n  initialSupply: u64;\n  returnFeeNumerator: u64;\n  fixedFeeNumerator: u64;\n  feeDenominator: u64;\n  curveType: number;\n  curveParameters: Uint8Array;\n}\n\nconst CropperStateLayout = struct<CropperStateLayout>([\n  u8('isInitialized'),\n  publicKey('stateOwner'),\n  publicKey('feeOwner'),\n  uint64('initialSupply'),\n  uint64('returnFeeNumerator'),\n  uint64('fixedFeeNumerator'),\n  uint64('feeDenominator'),\n  u8('curveType'),\n  blob(32, 'curveParameters'),\n]);\n\nexport interface CropperState {\n  isInitialized: boolean;\n  stateOwner: PublicKey;\n  feeOwner: PublicKey;\n  initialSupply: u64;\n  returnFeeNumerator: number;\n  fixedFeeNumerator: number;\n  feeDenominator: number;\n  curveType: number;\n  curveParameters: Uint8Array;\n}\n\nexport interface CropperPoolState {\n  programId: PublicKey;\n  authority: PublicKey;\n  version: number;\n  isInitialized: boolean;\n  nonce: number;\n  ammId: PublicKey;\n  serumProgramId: PublicKey;\n  serumMarket: PublicKey;\n  tokenProgramId: PublicKey;\n  tokenAAccount: PublicKey;\n  tokenBAccount: PublicKey;\n  poolMint: PublicKey;\n  mintA: PublicKey;\n  mintB: PublicKey;\n}\n\n// This seems to be hardcoded.\nexport const CROPPER_STATE_ADDRESS = new PublicKey('3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq');\n\nexport const accountInfoToCropperPoolState = (\n  address: PublicKey,\n  accountInfo: AccountInfo<Buffer>,\n): CropperPoolState => {\n  const programId = accountInfo.owner;\n\n  const decoded = CropperTokenSwapLayout.decode(accountInfo.data);\n  const [authority] = findProgramAddressSync([address.toBuffer()], programId);\n\n  return {\n    programId,\n    authority,\n    version: decoded.version,\n    isInitialized: Boolean(decoded.isInitialized),\n    nonce: decoded.nonce,\n    ammId: decoded.ammId,\n    serumProgramId: decoded.serumProgramId,\n    tokenProgramId: decoded.tokenProgramId,\n    tokenAAccount: decoded.tokenAAccount,\n    tokenBAccount: decoded.tokenBAccount,\n    serumMarket: decoded.serumMarket,\n    poolMint: decoded.poolMint,\n    mintA: decoded.mintA,\n    mintB: decoded.mintB,\n  };\n};\n\nexport const stateAccountInfoToCropperState = (accountInfo: AccountInfo<Buffer>): CropperState => {\n  const decoded = CropperStateLayout.decode(accountInfo.data);\n\n  return {\n    isInitialized: Boolean(decoded.isInitialized),\n    stateOwner: decoded.stateOwner,\n    feeOwner: decoded.feeOwner,\n    initialSupply: decoded.initialSupply,\n    returnFeeNumerator: decoded.returnFeeNumerator.toNumber(),\n    fixedFeeNumerator: decoded.fixedFeeNumerator.toNumber(),\n    feeDenominator: decoded.feeDenominator.toNumber(),\n    curveType: decoded.curveType,\n    curveParameters: decoded.curveParameters,\n  };\n};\n","import type { Provider } from '@project-serum/anchor';\nimport { Program } from '@project-serum/anchor';\nimport { createProgramAddressSync, findProgramAddressSync } from '@project-serum/anchor/dist/cjs/utils/pubkey';\nimport { Market } from '@project-serum/serum';\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport {\n  AccountMeta,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_CLOCK_PUBKEY,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport { BN } from 'bn.js';\nimport { Jupiter as JupiterIDL, IDL } from './idl/jupiter';\nimport type { RaydiumAmm } from './raydium/raydiumAmm';\nimport { StableSwap } from '@saberhq/stableswap-sdk';\nimport {\n  ALDRIN_SWAP_PROGRAM_ID,\n  ALDRIN_SWAP_V2_PROGRAM_ID,\n  RAYDIUM_AMM_V4_PROGRAM_ID,\n  SABER_ADD_DECIMALS_PROGRAM_ID,\n  MERCURIAL_SWAP_PROGRAM_ID,\n} from '../constants';\nimport { AldrinPoolState } from './aldrin/poolState';\nimport type { TokenSwapState } from './spl-token-swap/tokenSwapLayout';\nimport { PlatformFee } from './types';\nimport type { AddDecimals } from './saber/saberAddDecimalsAmm';\nimport { CropperPoolState, CROPPER_STATE_ADDRESS } from './cropper/swapLayout';\nimport { SenchaPoolState } from './sencha/swapLayout';\nimport { MercurialSwapLayoutState } from './mercurial/swapLayout';\n\n// Side rust enum used for the program's RPC API.\nconst Side = {\n  Bid: { bid: {} },\n  Ask: { ask: {} },\n};\n\nexport const JUPITER_PROGRAM_ID_STAGING = new PublicKey(\n  '64vBwEhR447K9tJxE4bwfkpXhgYcGz78a3AATC8sPrUS', //'JUSCvTfqyK9H9yjb64AasMc6fVpK3VsE3RCBCFz9y4Z'\n);\n\nexport const JUPITER_PROGRAM_ID_PRODUCTION = new PublicKey('JUP2jxvXaqu7NQY1GmNF4m1vodw12LVXYxbFL2uJvfo');\n\nconst JUPITER_PROGRAM_ID = JUPITER_PROGRAM_ID_PRODUCTION; // JUPITER_PROGRAM_ID_PRODUCTION;\n\nconst JUPITER_PROGRAM = new Program<JupiterIDL>(IDL as JupiterIDL, JUPITER_PROGRAM_ID, {} as Provider);\n\nconst [TOKEN_LEDGER] = findProgramAddressSync([Buffer.from('token_ledger')], JUPITER_PROGRAM_ID);\n\nfunction stableSwapNPoolIntoMercurialExchange(\n  swayLayout: MercurialSwapLayoutState,\n  sourceTokenAccount: PublicKey,\n  destinationTokenAccount: PublicKey,\n  user: PublicKey,\n) {\n  return {\n    swapProgram: MERCURIAL_SWAP_PROGRAM_ID,\n    swapState: swayLayout.ammId,\n    tokenProgram: TOKEN_PROGRAM_ID,\n    poolAuthority: swayLayout.authority,\n    userTransferAuthority: user,\n\n    sourceTokenAccount,\n    destinationTokenAccount,\n  };\n}\n\nfunction raydiumAmmToRaydiumSwap(\n  raydiumAmm: RaydiumAmm,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  user: PublicKey,\n) {\n  const [ammAuthority] = findProgramAddressSync(\n    [new Uint8Array(Buffer.from('amm authority'.replace('\\u00A0', ' '), 'utf-8'))],\n    RAYDIUM_AMM_V4_PROGRAM_ID,\n  );\n\n  if (!raydiumAmm.serumMarketKeys) {\n    throw Error('RaydiumAmm is missing serumMarketKeys');\n  }\n\n  return {\n    swapProgram: RAYDIUM_AMM_V4_PROGRAM_ID,\n    tokenProgram: TOKEN_PROGRAM_ID,\n    ammId: raydiumAmm.ammId,\n    ammAuthority,\n    ammOpenOrders: raydiumAmm.ammOpenOrders,\n    poolCoinTokenAccount: raydiumAmm.poolCoinTokenAccount,\n    poolPcTokenAccount: raydiumAmm.poolPcTokenAccount,\n    serumProgramId: raydiumAmm.serumProgramId,\n    serumMarket: raydiumAmm.serumMarket,\n    serumBids: raydiumAmm.serumMarketKeys.serumBids,\n    serumAsks: raydiumAmm.serumMarketKeys.serumAsks,\n    serumEventQueue: raydiumAmm.serumMarketKeys.serumEventQueue,\n    serumCoinVaultAccount: raydiumAmm.serumMarketKeys.serumCoinVaultAccount,\n    serumPcVaultAccount: raydiumAmm.serumMarketKeys.serumPcVaultAccount,\n    serumVaultSigner: raydiumAmm.serumMarketKeys.serumVaultSigner,\n    userSourceTokenAccount: userSourceTokenAccountAddress,\n    userDestinationTokenAccount: userDestinationTokenAccountAddress,\n    userSourceOwner: user,\n  };\n}\n\nfunction marketIntoSerumSwap(\n  market: Market,\n  openOrdersAddress: PublicKey,\n  orderPayerTokenAccountAddress: PublicKey,\n  coinWallet: PublicKey,\n  pcWallet: PublicKey,\n  user: PublicKey,\n) {\n  const vaultSigner = createProgramAddressSync(\n    [market.address.toBuffer(), market.decoded.vaultSignerNonce.toArrayLike(Buffer, 'le', 8)],\n    market.programId,\n  );\n\n  return {\n    market: {\n      market: market.address,\n      openOrders: openOrdersAddress,\n      requestQueue: market.decoded.requestQueue,\n      eventQueue: market.decoded.eventQueue,\n      bids: market.bidsAddress,\n      asks: market.asksAddress,\n      coinVault: market.decoded.baseVault,\n      pcVault: market.decoded.quoteVault,\n      vaultSigner,\n    },\n    authority: user,\n    orderPayerTokenAccount: orderPayerTokenAccountAddress,\n    coinWallet,\n    pcWallet,\n    // Programs.\n    dexProgram: market.programId,\n    tokenProgram: TOKEN_PROGRAM_ID,\n    // Sysvars.\n    rent: SYSVAR_RENT_PUBKEY,\n  };\n}\n\nexport function createMercurialExchangeInstruction(\n  swapLayout: MercurialSwapLayoutState,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  user: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n): TransactionInstruction {\n  const remainingAccounts: AccountMeta[] = [];\n\n  for (const swapTokenAccount of swapLayout.tokenAccounts) {\n    remainingAccounts.push({\n      pubkey: swapTokenAccount,\n      isSigner: false,\n      isWritable: true,\n    });\n  }\n  remainingAccounts.push(...prepareRemainingAccounts(amount, platformFee?.feeAccount));\n\n  return JUPITER_PROGRAM.instruction.mercurialExchange(\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: stableSwapNPoolIntoMercurialExchange(\n        swapLayout,\n        userSourceTokenAccountAddress,\n        userDestinationTokenAccountAddress,\n        user,\n      ),\n      remainingAccounts,\n    },\n  );\n}\n\nexport function createSerumSwapInstruction(\n  market: Market,\n  inputMint: PublicKey,\n  openOrdersAddress: PublicKey,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  user: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n  referrer: PublicKey | undefined,\n): TransactionInstruction {\n  const { side, coinWallet, pcWallet } = inputMint.equals(market.baseMintAddress)\n    ? {\n        side: Side.Ask,\n        coinWallet: userSourceTokenAccountAddress,\n        pcWallet: userDestinationTokenAccountAddress,\n      }\n    : {\n        side: Side.Bid,\n        coinWallet: userDestinationTokenAccountAddress,\n        pcWallet: userSourceTokenAccountAddress,\n      };\n\n  let remainingAccounts = prepareRemainingAccounts(amount, platformFee?.feeAccount);\n\n  if (referrer) {\n    remainingAccounts.push({\n      pubkey: referrer,\n      isSigner: false,\n      isWritable: true,\n    });\n  }\n\n  return JUPITER_PROGRAM.instruction.serumSwap(\n    side,\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: marketIntoSerumSwap(\n        market,\n        openOrdersAddress,\n        userSourceTokenAccountAddress,\n        coinWallet,\n        pcWallet,\n        user,\n      ),\n      remainingAccounts,\n    },\n  );\n}\n\nexport function createTokenSwapInstruction(\n  tokenSwapState: TokenSwapState,\n  inputMint: PublicKey,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  user: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n  isStep: boolean,\n): TransactionInstruction {\n  const [swapSource, swapDestination] = inputMint.equals(tokenSwapState.mintA)\n    ? [tokenSwapState.tokenAccountA, tokenSwapState.tokenAccountB]\n    : [tokenSwapState.tokenAccountB, tokenSwapState.tokenAccountA];\n\n  return (isStep ? JUPITER_PROGRAM.instruction.stepTokenSwap : JUPITER_PROGRAM.instruction.tokenSwap)(\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: {\n        tokenSwapProgram: tokenSwapState.programId,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        swap: tokenSwapState.address,\n        authority: tokenSwapState.authority,\n        userTransferAuthority: user,\n        source: userSourceTokenAccountAddress,\n        swapSource,\n        swapDestination,\n        destination: userDestinationTokenAccountAddress,\n        poolMint: tokenSwapState.poolToken,\n        poolFee: tokenSwapState.feeAccount,\n      },\n      remainingAccounts: prepareRemainingAccounts(amount, platformFee?.feeAccount),\n    },\n  );\n}\n\nexport function createSenchaSwapInstruction(\n  poolState: SenchaPoolState,\n  sourceMint: PublicKey,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  user: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n): TransactionInstruction {\n  const [swapSource, swapDestination] = sourceMint.equals(poolState.token0Mint)\n    ? [poolState.token0Reserves, poolState.token1Reserves]\n    : [poolState.token1Reserves, poolState.token0Reserves];\n\n  const [feesSource, feesDestination] = sourceMint.equals(poolState.token0Mint)\n    ? [poolState.token0Fees, poolState.token1Fees]\n    : [poolState.token1Fees, poolState.token0Fees];\n\n  return JUPITER_PROGRAM.instruction.senchaExchange(\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: {\n        swapProgram: poolState.programId,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        swap: poolState.ammId,\n        userAuthority: user,\n        inputUserAccount: userSourceTokenAccountAddress,\n        inputTokenAccount: swapSource,\n        inputFeesAccount: feesSource,\n        outputUserAccount: userDestinationTokenAccountAddress,\n        outputTokenAccount: swapDestination,\n        outputFeesAccount: feesDestination,\n      },\n      remainingAccounts: prepareRemainingAccounts(amount, platformFee?.feeAccount),\n    },\n  );\n}\n\nexport function createCropperSwapInstruction(\n  poolState: CropperPoolState,\n  sourceMint: PublicKey,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  user: PublicKey,\n  feeAccount: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n): TransactionInstruction {\n  const [swapSource, swapDestination] = sourceMint.equals(poolState.mintA)\n    ? [poolState.tokenAAccount, poolState.tokenBAccount]\n    : [poolState.tokenBAccount, poolState.tokenAAccount];\n\n  return JUPITER_PROGRAM.instruction.cropperTokenSwap(\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: {\n        tokenSwapProgram: poolState.programId,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        swap: poolState.ammId,\n        swapState: CROPPER_STATE_ADDRESS,\n        authority: poolState.authority,\n        userTransferAuthority: user,\n        source: userSourceTokenAccountAddress,\n        swapSource,\n        swapDestination,\n        destination: userDestinationTokenAccountAddress,\n        poolMint: poolState.poolMint,\n        poolFee: feeAccount,\n      },\n      remainingAccounts: prepareRemainingAccounts(amount, platformFee?.feeAccount),\n    },\n  );\n}\n\nexport function createRaydiumSwapInstruction(\n  raydiumAmm: RaydiumAmm,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  user: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n): TransactionInstruction {\n  return JUPITER_PROGRAM.instruction.raydiumSwapV2(\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: raydiumAmmToRaydiumSwap(\n        raydiumAmm,\n        userSourceTokenAccountAddress,\n        userDestinationTokenAccountAddress,\n        user,\n      ),\n      remainingAccounts: prepareRemainingAccounts(amount, platformFee?.feeAccount),\n    },\n  );\n}\n\nexport function createAldrinSwapInstruction(\n  poolState: AldrinPoolState,\n  sourceMint: PublicKey,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  user: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n): TransactionInstruction {\n  const [side, userBaseTokenAccount, userQuoteTokenAccount] = sourceMint.equals(poolState.baseTokenMint)\n    ? [Side.Ask, userSourceTokenAccountAddress, userDestinationTokenAccountAddress]\n    : [Side.Bid, userDestinationTokenAccountAddress, userSourceTokenAccountAddress];\n\n  return JUPITER_PROGRAM.instruction.aldrinSwap(\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    side,\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: {\n        swapProgram: ALDRIN_SWAP_PROGRAM_ID,\n        pool: poolState.address,\n        poolSigner: poolState.poolSigner,\n        poolMint: poolState.poolMint,\n        baseTokenVault: poolState.baseTokenVault,\n        quoteTokenVault: poolState.quoteTokenVault,\n        feePoolTokenAccount: poolState.feePoolTokenAccount,\n        walletAuthority: user,\n        userBaseTokenAccount,\n        userQuoteTokenAccount,\n        tokenProgram: TOKEN_PROGRAM_ID,\n      },\n      remainingAccounts: prepareRemainingAccounts(amount, platformFee?.feeAccount),\n    },\n  );\n}\n\nexport function createAldrinV2SwapInstruction(\n  poolState: AldrinPoolState,\n  sourceMint: PublicKey,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  curve: PublicKey,\n  user: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n): TransactionInstruction {\n  const [side, userBaseTokenAccount, userQuoteTokenAccount] = sourceMint.equals(poolState.baseTokenMint)\n    ? [Side.Ask, userSourceTokenAccountAddress, userDestinationTokenAccountAddress]\n    : [Side.Bid, userDestinationTokenAccountAddress, userSourceTokenAccountAddress];\n\n  return JUPITER_PROGRAM.instruction.aldrinV2Swap(\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    side,\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: {\n        swapProgram: ALDRIN_SWAP_V2_PROGRAM_ID,\n        pool: poolState.address,\n        poolSigner: poolState.poolSigner,\n        poolMint: poolState.poolMint,\n        baseTokenVault: poolState.baseTokenVault,\n        quoteTokenVault: poolState.quoteTokenVault,\n        feePoolTokenAccount: poolState.feePoolTokenAccount,\n        walletAuthority: user,\n        userBaseTokenAccount,\n        userQuoteTokenAccount,\n        curve,\n        tokenProgram: TOKEN_PROGRAM_ID,\n      },\n      remainingAccounts: prepareRemainingAccounts(amount, platformFee?.feeAccount),\n    },\n  );\n}\n\nexport function createRiskCheckAndFeeInstruction(\n  userDestinationTokenAccount: PublicKey,\n  userTransferAuthority: PublicKey,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n): TransactionInstruction {\n  const remainingAccounts: AccountMeta[] = [];\n\n  if (platformFee?.feeAccount) {\n    remainingAccounts.push({\n      pubkey: platformFee.feeAccount,\n      isSigner: false,\n      isWritable: true,\n    });\n  }\n\n  return JUPITER_PROGRAM.instruction.riskCheckAndFee(new BN(minimumOutAmount), platformFee?.feeBps ?? 0, {\n    accounts: {\n      tokenLedger: TOKEN_LEDGER,\n      userDestinationTokenAccount,\n      userTransferAuthority,\n      tokenProgram: TOKEN_PROGRAM_ID,\n    },\n    remainingAccounts,\n  });\n}\n\nexport function createSetTokenLedgerInstruction(tokenAccountAddress: PublicKey): TransactionInstruction {\n  return JUPITER_PROGRAM.instruction.setTokenLedger({\n    accounts: {\n      tokenLedger: TOKEN_LEDGER,\n      tokenAccount: tokenAccountAddress,\n    },\n  });\n}\n\nexport function createCreateTokenLedgerInstruction(user: PublicKey): TransactionInstruction {\n  return JUPITER_PROGRAM.instruction.initializeTokenLedger({\n    accounts: {\n      tokenLedger: TOKEN_LEDGER,\n      payer: user,\n      systemProgram: SystemProgram.programId,\n      rent: SYSVAR_RENT_PUBKEY,\n    },\n  });\n}\n\nexport function createOpenOrdersInstruction(market: Market, user: PublicKey): [PublicKey, TransactionInstruction] {\n  const [openOrders] = findProgramAddressSync(\n    [Buffer.from('open_orders'), market.publicKey.toBuffer(), user.toBuffer()],\n    JUPITER_PROGRAM_ID,\n  );\n\n  const ix = JUPITER_PROGRAM.instruction.createOpenOrders({\n    accounts: {\n      openOrders,\n      payer: user,\n      dexProgram: market.programId,\n      systemProgram: SystemProgram.programId,\n      rent: SYSVAR_RENT_PUBKEY,\n      market: market.publicKey,\n    },\n  });\n  return [openOrders, ix];\n}\n\nfunction saberPoolIntoSaberExchange(\n  saberPool: StableSwap,\n  sourceMintAddress: PublicKey,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  user: PublicKey,\n) {\n  const feesTokenAccount = sourceMintAddress.equals(saberPool.state.tokenA.mint)\n    ? saberPool.state.tokenB.adminFeeAccount\n    : saberPool.state.tokenA.adminFeeAccount;\n  const [inputTokenAccount, outputTokenAccount] = sourceMintAddress.equals(saberPool.state.tokenA.mint)\n    ? [saberPool.state.tokenA.reserve, saberPool.state.tokenB.reserve]\n    : [saberPool.state.tokenB.reserve, saberPool.state.tokenA.reserve];\n\n  return {\n    swapProgram: saberPool.config.swapProgramID,\n    tokenProgram: TOKEN_PROGRAM_ID,\n    swap: saberPool.config.swapAccount,\n    swapAuthority: saberPool.config.authority,\n    userAuthority: user,\n    clock: SYSVAR_CLOCK_PUBKEY,\n    inputUserAccount: userSourceTokenAccountAddress,\n    inputTokenAccount,\n    outputUserAccount: userDestinationTokenAccountAddress,\n    outputTokenAccount,\n    feesTokenAccount,\n  };\n}\n\nexport function createSaberExchangeInstruction(\n  saberPool: StableSwap,\n  inputMint: PublicKey,\n  userSourceTokenAccountAddress: PublicKey,\n  userDestinationTokenAccountAddress: PublicKey,\n  user: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n): TransactionInstruction {\n  const remainingAccounts = prepareRemainingAccounts(amount, platformFee?.feeAccount);\n  return JUPITER_PROGRAM.instruction.saberExchange(\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: saberPoolIntoSaberExchange(\n        saberPool,\n        inputMint,\n        userSourceTokenAccountAddress,\n        userDestinationTokenAccountAddress,\n        user,\n      ),\n      remainingAccounts,\n    },\n  );\n}\n\nexport function createSaberAddDecimalsDepositInstruction(\n  addDecimals: AddDecimals,\n  sourceTokenAccountAddress: PublicKey,\n  destinationTokenAccountAddress: PublicKey,\n  userTransferAuthority: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n) {\n  const remainingAccounts = prepareRemainingAccounts(amount, platformFee?.feeAccount);\n  return JUPITER_PROGRAM.instruction.saberAddDecimalsDeposit(\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: {\n        addDecimalsProgram: SABER_ADD_DECIMALS_PROGRAM_ID,\n        wrapper: addDecimals.wrapper,\n        wrapperMint: addDecimals.mint,\n        wrapperUnderlyingTokens: addDecimals.wrapperUnderlyingTokens,\n        owner: userTransferAuthority,\n        userUnderlyingTokens: sourceTokenAccountAddress,\n        userWrappedTokens: destinationTokenAccountAddress,\n        tokenProgram: TOKEN_PROGRAM_ID,\n      },\n      remainingAccounts,\n    },\n  );\n}\n\nexport function createSaberAddDecimalsWithdrawInstruction(\n  addDecimals: AddDecimals,\n  sourceTokenAccountAddress: PublicKey,\n  destinationTokenAccountAddress: PublicKey,\n  userTransferAuthority: PublicKey,\n  amount: number | null,\n  minimumOutAmount: number,\n  platformFee: PlatformFee | undefined,\n) {\n  const remainingAccounts = prepareRemainingAccounts(amount, platformFee?.feeAccount);\n  return JUPITER_PROGRAM.instruction.saberAddDecimalsWithdraw(\n    amount ? new BN(amount) : amount,\n    new BN(minimumOutAmount),\n    platformFee?.feeBps ?? 0,\n    {\n      accounts: {\n        addDecimalsProgram: SABER_ADD_DECIMALS_PROGRAM_ID,\n        wrapper: addDecimals.wrapper,\n        wrapperMint: addDecimals.mint,\n        wrapperUnderlyingTokens: addDecimals.wrapperUnderlyingTokens,\n        owner: userTransferAuthority,\n        userUnderlyingTokens: destinationTokenAccountAddress,\n        userWrappedTokens: sourceTokenAccountAddress,\n        tokenProgram: TOKEN_PROGRAM_ID,\n      },\n      remainingAccounts,\n    },\n  );\n}\n\nfunction prepareRemainingAccounts(amount: number | null, feeAccount: PublicKey | undefined): AccountMeta[] {\n  const remainingAccounts = [];\n\n  if (amount === null) {\n    remainingAccounts.push({\n      pubkey: TOKEN_LEDGER,\n      isSigner: false,\n      isWritable: true,\n    });\n  }\n  if (feeAccount) {\n    remainingAccounts.push({\n      pubkey: feeAccount,\n      isSigner: false,\n      isWritable: true,\n    });\n  }\n\n  return remainingAccounts;\n}\n","import { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport JSBI from 'jsbi';\nimport { AccountInfoMap, Amm, QuoteParams, SwapParams } from '../amm';\n// Modified from saber's registry to contain the underlying mint decimal to avoid pointless queries\nimport addDecimalsJson from './add-decimals-complete-state.mainnet-beta.json';\nimport {\n  createSaberAddDecimalsDepositInstruction,\n  createSaberAddDecimalsWithdrawInstruction,\n} from '../jupiterInstruction';\n\nexport interface AddDecimals {\n  wrapper: PublicKey;\n  underlying: PublicKey;\n  underlyingDecimals: number;\n  wrapperUnderlyingTokens: PublicKey;\n  mint: PublicKey;\n  decimals: number;\n}\n\nexport function getSaberWrappedDecimalsAmms() {\n  return addDecimalsJson.map((addDecimalJson) => {\n    const addDecimals = {\n      wrapper: new PublicKey(addDecimalJson.wrapper),\n      underlying: new PublicKey(addDecimalJson.underlying),\n      underlyingDecimals: addDecimalJson.underlyingDecimals,\n      wrapperUnderlyingTokens: new PublicKey(addDecimalJson.wrapperUnderlyingTokens),\n      mint: new PublicKey(addDecimalJson.mint),\n      decimals: addDecimalJson.decimals,\n    };\n\n    return new SaberAddDecimalsAmm(new WrappedToken(addDecimals));\n  });\n}\n\nexport class WrappedToken {\n  constructor(public addDecimals: AddDecimals) {}\n\n  private get multiplier() {\n    return 10 ** (this.addDecimals.decimals - this.addDecimals.underlyingDecimals);\n  }\n\n  getOutputAmount(inputAmount: number, inputMint: PublicKey): JSBI {\n    if (this.addDecimals.mint.equals(inputMint)) {\n      // withdraw, so divide\n      return this.calculateWithdrawOutputAmount(inputAmount);\n    } else if (this.addDecimals.underlying.equals(inputMint)) {\n      // deposit, so multiply\n      return this.calculateDepositOutputAmount(inputAmount);\n    }\n    throw new Error(`unknown input token: ${inputMint.toString()}`);\n  }\n\n  private calculateDepositOutputAmount(inputAmount: number) {\n    return JSBI.multiply(JSBI.BigInt(inputAmount), JSBI.BigInt(this.multiplier));\n  }\n\n  private calculateWithdrawOutputAmount(inputAmount: number) {\n    return JSBI.divide(JSBI.BigInt(inputAmount), JSBI.BigInt(this.multiplier));\n  }\n}\n\n// This isn't technically an Amm but this the smoothest solution to allow its usage without a major refactor of the abstractions for now\nexport class SaberAddDecimalsAmm implements Amm {\n  label = 'Saber (Decimals)' as const;\n\n  constructor(private wrappedToken: WrappedToken) {}\n\n  get id() {\n    return this.wrappedToken.addDecimals.wrapper.toBase58();\n  }\n\n  getAccountsForUpdate() {\n    return new Array<PublicKey>();\n  }\n\n  update(_accountInfoMap: AccountInfoMap) {}\n\n  getQuote({ sourceMint, amount }: QuoteParams) {\n    const outAmount = JSBI.toNumber(this.wrappedToken.getOutputAmount(amount, sourceMint));\n    return {\n      notEnoughLiquidity: false,\n      inAmount: amount,\n      outAmount,\n      feeAmount: 0,\n      feeMint: sourceMint.toBase58(),\n      feePct: 0,\n      priceImpactPct: 0,\n    };\n  }\n\n  createSwapInstructions({\n    sourceMint,\n    sourceTokenAccount,\n    destinationTokenAccount,\n    userTransferAuthority,\n    amount,\n    minimumOutAmount,\n    platformFee,\n  }: SwapParams) {\n    if (this.wrappedToken.addDecimals.underlying.equals(sourceMint)) {\n      return [\n        createSaberAddDecimalsDepositInstruction(\n          this.wrappedToken.addDecimals,\n          sourceTokenAccount,\n          destinationTokenAccount,\n          userTransferAuthority,\n          amount,\n          minimumOutAmount,\n          platformFee,\n        ),\n      ];\n    } else {\n      return [\n        createSaberAddDecimalsWithdrawInstruction(\n          this.wrappedToken.addDecimals,\n          sourceTokenAccount,\n          destinationTokenAccount,\n          userTransferAuthority,\n          amount,\n          minimumOutAmount,\n          platformFee,\n        ),\n      ];\n    }\n  }\n\n  get reserveTokenMints() {\n    return [this.wrappedToken.addDecimals.underlying, this.wrappedToken.addDecimals.mint];\n  }\n}\n","export function getTwoPermutations<T>(array: T[]) {\n  return array.reduce((acc, item) => {\n    array.forEach((otherItem) => {\n      if (item !== otherItem) {\n        acc.push([item, otherItem]);\n      }\n    });\n    return acc;\n  }, new Array<T[]>());\n}\n","import { AccountInfo, PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { PlatformFee, QuoteMintToReferrer, TokenMintAddress } from '..';\n\nexport interface QuoteParams {\n  sourceMint: PublicKey;\n  destinationMint: PublicKey;\n  amount: number;\n}\n\nexport interface Quote {\n  notEnoughLiquidity: boolean;\n  minInAmount?: number;\n  minOutAmount?: number;\n  inAmount: number;\n  outAmount: number;\n  feeAmount: number;\n  feeMint: TokenMintAddress;\n  feePct: number;\n  priceImpactPct: number;\n}\n\nexport interface SwapParams {\n  sourceMint: PublicKey;\n  destinationMint: PublicKey;\n  sourceTokenAccount: PublicKey;\n  destinationTokenAccount: PublicKey;\n  userTransferAuthority: PublicKey;\n  amount: number | null;\n  minimumOutAmount: number;\n  openOrdersAddress?: PublicKey;\n  platformFee?: PlatformFee;\n  quoteMintToReferrer?: QuoteMintToReferrer;\n}\n\nexport type AccountInfoMap = Map<string, AccountInfo<Buffer> | null>;\n\nexport interface Amm {\n  /* Label for UI usage */\n  label: string;\n  /* Unique id to recognize the AMM */\n  id: string;\n  /* Reserve token mints for the purpose of routing */\n  reserveTokenMints: PublicKey[];\n\n  getAccountsForUpdate(): PublicKey[];\n  update(accountInfoMap: AccountInfoMap): void;\n\n  getQuote(quoteParams: QuoteParams): Quote;\n\n  createSwapInstructions(swapParams: SwapParams): TransactionInstruction[];\n}\n\nexport const mapAddressToAccountInfos = (accountInfoMap: AccountInfoMap, addresses: PublicKey[]) => {\n  const accountInfos = addresses.map((address) => {\n    const accountInfo = accountInfoMap.get(address.toString());\n    if (!accountInfo) {\n      throw new Error(`Account info ${address.toBase58()} missing`);\n    }\n    return accountInfo;\n  });\n\n  return accountInfos;\n};\n","// Only a few hardcoded pools for now, until we query the whole lot through api\nimport { struct, nu64 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { publicKey, uint128, uint64 } from '../../utils/layout';\n\ninterface AmmInfoLayoutV4 {\n  status: number;\n  nonce: number;\n  orderNum: number;\n  depth: number;\n  coinDecimals: number;\n  pcDecimals: number;\n  state: number;\n  resetFlag: number;\n  minSize: number;\n  volMaxCutRatio: number;\n  amountWaveRatio: number;\n  coinLotSize: number;\n  pcLotSize: number;\n  minPriceMultiplier: number;\n  maxPriceMultiplier: number;\n  systemDecimalsValue: number;\n  minSeparateNumerator: number;\n  minSeparateDenominator: number;\n  tradeFeeNumerator: number;\n  tradeFeeDenominator: number;\n  pnlNumerator: number;\n  pnlDenominator: number;\n  swapFeeNumerator: number;\n  swapFeeDenominator: number;\n  needTakePnlCoin: number;\n  needTakePnlPc: number;\n  totalPnlPc: number;\n  totalPnlCoin: number;\n  poolTotalDepositPc: u64;\n  poolTotalDepositCoin: u64;\n  swapCoinInAmount: u64;\n  swapPcOutAmount: u64;\n  swapCoin2PcFee: number;\n  swapPcInAmount: u64;\n  swapCoinOutAmount: u64;\n  swapPc2CoinFee: number;\n  poolCoinTokenAccount: PublicKey;\n  poolPcTokenAccount: PublicKey;\n  coinMintAddress: PublicKey;\n  pcMintAddress: PublicKey;\n  lpMintAddress: PublicKey;\n  ammOpenOrders: PublicKey;\n  serumMarket: PublicKey;\n  serumProgramId: PublicKey;\n  ammTargetOrders: PublicKey;\n  poolWithdrawQueue: PublicKey;\n  poolTempLpTokenAccount: PublicKey;\n  ammOwner: PublicKey;\n  pnlOwner: PublicKey;\n}\n\nexport const AMM_INFO_LAYOUT_V4 = struct<AmmInfoLayoutV4>([\n  nu64('status'),\n  nu64('nonce'),\n  nu64('orderNum'),\n  nu64('depth'),\n  nu64('coinDecimals'),\n  nu64('pcDecimals'),\n  nu64('state'),\n  nu64('resetFlag'),\n  nu64('minSize'),\n  nu64('volMaxCutRatio'),\n  nu64('amountWaveRatio'),\n  nu64('coinLotSize'),\n  nu64('pcLotSize'),\n  nu64('minPriceMultiplier'),\n  nu64('maxPriceMultiplier'),\n  nu64('systemDecimalsValue'),\n  // Fees\n  nu64('minSeparateNumerator'),\n  nu64('minSeparateDenominator'),\n  nu64('tradeFeeNumerator'),\n  nu64('tradeFeeDenominator'),\n  nu64('pnlNumerator'),\n  nu64('pnlDenominator'),\n  nu64('swapFeeNumerator'),\n  nu64('swapFeeDenominator'),\n  // OutPutData\n  nu64('needTakePnlCoin'),\n  nu64('needTakePnlPc'),\n  nu64('totalPnlPc'),\n  nu64('totalPnlCoin'),\n  uint128('poolTotalDepositPc'),\n  uint128('poolTotalDepositCoin'),\n  uint128('swapCoinInAmount'),\n  uint128('swapPcOutAmount'),\n  nu64('swapCoin2PcFee'),\n  uint128('swapPcInAmount'),\n  uint128('swapCoinOutAmount'),\n  nu64('swapPc2CoinFee'),\n\n  publicKey('poolCoinTokenAccount'),\n  publicKey('poolPcTokenAccount'),\n  publicKey('coinMintAddress'),\n  publicKey('pcMintAddress'),\n  publicKey('lpMintAddress'),\n  publicKey('ammOpenOrders'),\n  publicKey('serumMarket'),\n  publicKey('serumProgramId'),\n  publicKey('ammTargetOrders'),\n  publicKey('poolWithdrawQueue'),\n  publicKey('poolTempLpTokenAccount'),\n  publicKey('ammOwner'),\n  publicKey('pnlOwner'),\n]);\n","// https://github.com/raydium-io/raydium-ui/blob/4048286f79fc4b71c3ffbfd9095470ab0c7d3862/src/utils/liquidity.ts#L30-L82\n\nimport { createProgramAddressSync } from '@project-serum/anchor/dist/cjs/utils/pubkey';\nimport { Market, OpenOrders } from '@project-serum/serum';\nimport { u64 } from '@solana/spl-token';\nimport { AccountInfo, PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport Decimal from 'decimal.js';\nimport { AccountInfoMap, Amm, mapAddressToAccountInfos, Quote, QuoteParams, SwapParams } from '../amm';\nimport { createRaydiumSwapInstruction } from '../jupiterInstruction';\nimport { AMM_INFO_LAYOUT_V4 } from './pools';\n\n// Explained here\n// https://discordapp.com/channels/813741812598439958/813750197423308820/900288485028683776\n// total_pc = amminfo.pc_vault.balance + amminfo.openorder.total_quote - amminfo.need_taken_pnl_pc\n// total_coin = amminfo.coin_vault.balance + amminfo.openorder.total_base - amminfo.need_taken_pnl_coin\n\ntype SerumMarketKeys = {\n  serumBids: PublicKey;\n  serumAsks: PublicKey;\n  serumEventQueue: PublicKey;\n  serumCoinVaultAccount: PublicKey;\n  serumPcVaultAccount: PublicKey;\n  serumVaultSigner: PublicKey;\n};\n\nexport class RaydiumAmm implements Amm {\n  label = 'Raydium' as const;\n\n  coinMint: PublicKey;\n  pcMint: PublicKey;\n\n  status: number;\n  serumProgramId: PublicKey;\n  serumMarket: PublicKey;\n  ammOpenOrders: PublicKey;\n  ammTargetOrders: PublicKey;\n  poolCoinTokenAccount: PublicKey;\n  poolPcTokenAccount: PublicKey;\n\n  serumMarketKeys: SerumMarketKeys | undefined;\n\n  coinReserve: u64 | undefined;\n  pcReserve: u64 | undefined;\n\n  swapFeeNumerator: u64;\n  swapFeeDenominator: u64;\n\n  constructor(public ammId: PublicKey, public ammAccountInfo: AccountInfo<Buffer>) {\n    const decoded = AMM_INFO_LAYOUT_V4.decode(ammAccountInfo.data);\n\n    this.status = decoded.status;\n    this.coinMint = new PublicKey(decoded.coinMintAddress);\n    this.pcMint = new PublicKey(decoded.pcMintAddress);\n\n    this.poolCoinTokenAccount = new PublicKey(decoded.poolCoinTokenAccount);\n    this.poolPcTokenAccount = new PublicKey(decoded.poolPcTokenAccount);\n\n    this.swapFeeNumerator = new u64(decoded.swapFeeNumerator);\n    this.swapFeeDenominator = new u64(decoded.swapFeeDenominator);\n\n    this.serumProgramId = new PublicKey(decoded.serumProgramId);\n    this.serumMarket = new PublicKey(decoded.serumMarket);\n    this.ammOpenOrders = new PublicKey(decoded.ammOpenOrders);\n    this.ammTargetOrders = new PublicKey(decoded.ammTargetOrders);\n  }\n\n  get id() {\n    return this.ammId.toBase58();\n  }\n\n  getAccountsForUpdate(): PublicKey[] {\n    return [this.ammId, this.poolCoinTokenAccount, this.poolPcTokenAccount, this.ammOpenOrders, this.serumMarket];\n  }\n\n  update(accountInfoMap: AccountInfoMap) {\n    const [\n      ammAccountInfo,\n      poolCoinTokenAccountInfo,\n      poolPcTokenAccountInfo,\n      ammOpenOrdersAccountInfo,\n      serumMarketMarketInfo,\n    ] = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());\n\n    this.ammAccountInfo = ammAccountInfo!;\n\n    const [coinAmount, pcAmount] = [\n      RaydiumAmm.tokenAmountAccessor(poolCoinTokenAccountInfo!),\n      RaydiumAmm.tokenAmountAccessor(poolPcTokenAccountInfo!),\n    ];\n\n    const openOrders = OpenOrders.fromAccountInfo(\n      this.ammOpenOrders,\n      ammOpenOrdersAccountInfo!,\n      ammOpenOrdersAccountInfo!.owner,\n    );\n\n    // TODO: Possibly better design is to have this passed to the ctor, so it isn't an independant instruction\n    const decodedMarket = Market.getLayout(this.serumProgramId).decode(serumMarketMarketInfo!.data);\n    const serumVaultSigner = createProgramAddressSync(\n      [this.serumMarket.toBuffer(), decodedMarket.vaultSignerNonce.toArrayLike(Buffer, 'le', 8)],\n      this.serumProgramId,\n    );\n    this.serumMarketKeys = {\n      serumBids: decodedMarket.bids,\n      serumAsks: decodedMarket.asks,\n      serumEventQueue: decodedMarket.eventQueue,\n      serumCoinVaultAccount: decodedMarket.baseVault,\n      serumPcVaultAccount: decodedMarket.quoteVault,\n      serumVaultSigner: serumVaultSigner,\n    };\n\n    const decoded = AMM_INFO_LAYOUT_V4.decode(this.ammAccountInfo.data);\n\n    this.coinReserve = coinAmount.add(openOrders.baseTokenTotal).sub(new u64(String(decoded.needTakePnlCoin)));\n\n    this.pcReserve = pcAmount.add(openOrders.quoteTokenTotal).sub(new u64(String(decoded.needTakePnlPc)));\n  }\n\n  private static tokenAmountAccessor(tokenAccountInfo: AccountInfo<Buffer>): u64 {\n    return u64.fromBuffer(tokenAccountInfo.data.slice(64, 64 + 8));\n  }\n\n  getQuote({ sourceMint, amount }: QuoteParams): Quote {\n    if (!this.coinReserve || !this.pcReserve) {\n      throw new Error('Pool token accounts balances not refreshed or empty');\n    }\n\n    const { coinReserve, pcReserve } = this;\n\n    const [inputReserve, outputReserve] = this.coinMint.equals(sourceMint)\n      ? [coinReserve, pcReserve]\n      : [pcReserve, coinReserve];\n\n    const inAmountBN = new BN(String(amount));\n    const feeAmount = inAmountBN.mul(this.swapFeeNumerator).div(this.swapFeeDenominator);\n    const inAmountAfterFee = inAmountBN.sub(feeAmount);\n\n    const numerator = inAmountAfterFee.mul(outputReserve);\n    const denominator = inputReserve.add(inAmountAfterFee);\n\n    const outAmountWithoutPriceImpact = inAmountAfterFee.mul(outputReserve).div(inputReserve);\n\n    const outAmountBN = numerator.div(denominator);\n    const outAmount = Number(outAmountBN.toString());\n\n    return {\n      notEnoughLiquidity: false,\n      inAmount: amount,\n      outAmount,\n      feeAmount: Number(feeAmount.toString()),\n      feeMint: sourceMint.toBase58(),\n      feePct: Number(new Decimal(this.swapFeeNumerator.toString()).div(this.swapFeeDenominator.toString()).toString()),\n      priceImpactPct: Number(\n        new Decimal(outAmountWithoutPriceImpact.sub(outAmountBN).toString())\n          .div(outAmountWithoutPriceImpact.toString())\n          .toString(),\n      ),\n    };\n  }\n\n  createSwapInstructions({\n    sourceTokenAccount,\n    destinationTokenAccount,\n    userTransferAuthority,\n    amount,\n    minimumOutAmount,\n    platformFee,\n  }: SwapParams) {\n    return [\n      createRaydiumSwapInstruction(\n        this,\n        sourceTokenAccount,\n        destinationTokenAccount,\n        userTransferAuthority,\n        amount,\n        minimumOutAmount,\n        platformFee,\n      ),\n    ];\n  }\n\n  get reserveTokenMints() {\n    return [this.coinMint, this.pcMint];\n  }\n}\n","import { Market, Orderbook } from '@project-serum/serum';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\n\nconst TAKER_FEE_PCT = 0.0004;\nconst STABLE_TAKER_FEE_PCT = 0.0001;\n\n// Stable markets are hardcoded in the program\nconst STABLE_MARKET_ADDRESSES = [\n  '77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS', // USDT/USDC\n  '5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z', // mSOL/SOL\n];\n\ninterface IMarketMeta {\n  /** buy or sell side */\n  side: 'buy' | 'sell';\n  /** indicate that your order is too huge for the market */\n  notEnoughLiquidity: boolean;\n  /** minimum in amount and the corresponding out amount */\n  minimum: {\n    in: number;\n    out: number;\n  };\n  /** amount in taken for the trade */\n  inAmount: number;\n  /** the amount out for the trade */\n  outAmount: number;\n  /** the total fee amount */\n  feeAmount: number;\n  /** price impact percentage */\n  priceImpactPct: number;\n  /** fee percentage */\n  feePct: number;\n}\n\n// Provides swap like out amount, with slippage and corresponding minimum amount out\nexport function getOutAmountMeta({\n  market,\n  asks,\n  bids,\n  fromAmount,\n  fromMint,\n  toMint,\n}: {\n  market: Market;\n  asks: Orderbook;\n  bids: Orderbook;\n  fromMint: PublicKey;\n  toMint: PublicKey;\n  fromAmount: number;\n}) {\n  const takerFeePct = STABLE_MARKET_ADDRESSES.includes(market.address.toBase58())\n    ? STABLE_TAKER_FEE_PCT\n    : TAKER_FEE_PCT;\n\n  if (fromMint.equals(market.quoteMintAddress) && toMint.equals(market.baseMintAddress)) {\n    // buy\n    return forecastBuy(market, asks, fromAmount, takerFeePct);\n  } else {\n    return forecastSell(market, bids, fromAmount, takerFeePct);\n  }\n}\n\nexport function forecastBuy(market: Market, orderBook: Orderbook, pcIn: number, takerFeePct: number): IMarketMeta {\n  let coinOut = 0;\n  let bestPrice = 0;\n  let worstPrice = 0;\n  // total base price\n  let totalCost = 0;\n  let totalCoins = 0;\n\n  // Serum buy order take fee in quote tokens\n  let availablePc = pcIn / (1 + takerFeePct);\n\n  const baseSizeLots = market.baseSizeLotsToNumber(new BN(1));\n  const quoteSizeLots = market.quoteSizeLotsToNumber(new BN(1));\n\n  for (const order of orderBook.items(false)) {\n    const price = market.priceLotsToNumber(order.priceLots);\n    const size = market.baseSizeLotsToNumber(order.sizeLots);\n    totalCoins += size;\n\n    if (!bestPrice && price !== 0) {\n      bestPrice = price;\n    }\n    worstPrice = price;\n\n    const orderCoinAmount = order.sizeLots.toNumber() * baseSizeLots;\n    const orderPcAmount = order.sizeLots.toNumber() * order.priceLots.toNumber() * quoteSizeLots;\n\n    const lotPrice = order.priceLots.toNumber() * quoteSizeLots;\n\n    if (orderPcAmount >= availablePc) {\n      const numberLotsCanBuy = Math.floor(availablePc / lotPrice);\n      totalCost += numberLotsCanBuy * lotPrice;\n      coinOut += numberLotsCanBuy * baseSizeLots;\n      availablePc -= numberLotsCanBuy * lotPrice;\n      break;\n    } else {\n      totalCost += order.sizeLots.toNumber() * lotPrice;\n      coinOut += orderCoinAmount;\n      availablePc -= orderPcAmount;\n    }\n  }\n\n  const priceImpactPct = bestPrice ? (worstPrice - bestPrice) / bestPrice : 0;\n\n  return {\n    side: 'buy',\n    notEnoughLiquidity: totalCoins <= coinOut,\n    minimum: {\n      in: Math.ceil(baseSizeLots * bestPrice * (1 + takerFeePct)),\n      out: baseSizeLots,\n    },\n    inAmount: Math.ceil(totalCost * (1 + takerFeePct)),\n    outAmount: coinOut,\n    feeAmount: Math.round(totalCost * takerFeePct),\n    priceImpactPct,\n    feePct: takerFeePct,\n  };\n}\n\nexport function forecastSell(market: Market, orderBook: Orderbook, coinIn: number, takerFeePct: number): IMarketMeta {\n  let pcOut = 0;\n  let bestPrice = 0;\n  let worstPrice = 0;\n  let availableCoin = coinIn;\n  let inAmount = 0;\n\n  const baseSizeLots = market.baseSizeLotsToNumber(new BN(1));\n  const quoteSizeLots = market.quoteSizeLotsToNumber(new BN(1));\n\n  for (const order of orderBook.items(true)) {\n    const price = market.priceLotsToNumber(order.priceLots);\n\n    if (!bestPrice && price !== 0) {\n      bestPrice = price;\n    }\n\n    worstPrice = price;\n\n    const orderCoinAmount = order.sizeLots.toNumber() * baseSizeLots;\n    const orderPcAmount = order.sizeLots.toNumber() * order.priceLots.toNumber() * quoteSizeLots;\n\n    if (availableCoin <= orderCoinAmount) {\n      const numberLotsCanSell = Math.floor(availableCoin / baseSizeLots);\n      pcOut += numberLotsCanSell * order.priceLots.toNumber() * quoteSizeLots;\n      availableCoin = 0;\n      inAmount += numberLotsCanSell * baseSizeLots;\n      break;\n    } else {\n      pcOut += orderPcAmount;\n      availableCoin -= orderCoinAmount;\n      inAmount += orderCoinAmount;\n    }\n  }\n\n  pcOut = Math.floor(pcOut * (1 - takerFeePct));\n\n  const priceImpactPct = bestPrice ? (bestPrice - worstPrice) / bestPrice : 0;\n\n  return {\n    side: 'sell',\n    notEnoughLiquidity: availableCoin > 0,\n    minimum: {\n      in: baseSizeLots,\n      out: Math.ceil(baseSizeLots * bestPrice * (1 - takerFeePct)),\n    },\n    inAmount: inAmount,\n    outAmount: pcOut,\n    feeAmount: Math.round(pcOut * takerFeePct),\n    priceImpactPct,\n    feePct: takerFeePct,\n  };\n}\n","import { Orderbook } from '@project-serum/serum';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { AccountInfoMap, Amm, mapAddressToAccountInfos, Quote, QuoteParams, SwapParams } from '../amm';\nimport { createSerumSwapInstruction } from '../jupiterInstruction';\nimport { SerumMarket } from '../market';\nimport { getOutAmountMeta } from './market';\n\nexport class SerumAmm implements Amm {\n  label = 'Serum' as const;\n  private orderbooks: { asks: Orderbook; bids: Orderbook } | undefined;\n\n  constructor(public market: SerumMarket) {}\n\n  get id() {\n    return this.market.address.toBase58();\n  }\n\n  getAccountsForUpdate(): PublicKey[] {\n    return [this.market.asksAddress, this.market.bidsAddress];\n  }\n\n  update(accountInfoMap: AccountInfoMap): void {\n    const [asksAccountInfo, bidsAccountInfo] = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());\n\n    const asks = Orderbook.decode(this.market, asksAccountInfo.data);\n    const bids = Orderbook.decode(this.market, bidsAccountInfo.data);\n\n    this.orderbooks = {\n      asks,\n      bids,\n    };\n  }\n\n  getQuote({ sourceMint, destinationMint, amount }: QuoteParams): Quote {\n    if (!this.orderbooks) {\n      throw new Error('Failed to find orderbooks');\n    }\n\n    const outAmountMeta = getOutAmountMeta({\n      market: this.market,\n      asks: this.orderbooks.asks,\n      bids: this.orderbooks.bids,\n      fromMint: sourceMint,\n      toMint: destinationMint,\n      fromAmount: amount,\n    });\n\n    return {\n      notEnoughLiquidity: outAmountMeta.notEnoughLiquidity,\n      minInAmount: outAmountMeta.minimum.in,\n      minOutAmount: outAmountMeta.minimum.out,\n      inAmount: outAmountMeta.inAmount,\n      outAmount: outAmountMeta.outAmount,\n      feeAmount: outAmountMeta.feeAmount,\n      feeMint: this.market.quoteMintAddress.toBase58(),\n      feePct: outAmountMeta.feePct,\n      priceImpactPct: outAmountMeta.priceImpactPct,\n    };\n  }\n\n  createSwapInstructions({\n    sourceMint,\n    sourceTokenAccount,\n    destinationTokenAccount,\n    userTransferAuthority,\n    amount,\n    minimumOutAmount,\n    openOrdersAddress,\n    platformFee,\n    quoteMintToReferrer,\n  }: SwapParams) {\n    if (!openOrdersAddress) {\n      throw new Error('Missing open orders');\n    }\n\n    return [\n      createSerumSwapInstruction(\n        this.market,\n        sourceMint,\n        openOrdersAddress,\n        sourceTokenAccount,\n        destinationTokenAccount,\n        userTransferAuthority,\n        amount,\n        minimumOutAmount,\n        platformFee,\n        quoteMintToReferrer?.get(this.market.quoteMintAddress.toBase58()),\n      ),\n    ];\n  }\n\n  get reserveTokenMints() {\n    return [this.market.baseMintAddress, this.market.quoteMintAddress];\n  }\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { getTwoPermutations } from '../../utils/getTwoPermutations';\nimport { AccountInfoMap, Amm, Quote, QuoteParams, SwapParams } from '../amm';\nimport { RaydiumAmm } from '../raydium/raydiumAmm';\nimport { createRiskCheckAndFeeInstruction, createSetTokenLedgerInstruction } from '../jupiterInstruction';\nimport { SerumAmm } from '../serum/serumAmm';\nimport { SerumMarket } from '../market';\n\ninterface SplitSolution {\n  outAmount: number;\n  portion: number;\n  firstQuote: Quote | undefined;\n  secondQuote: Quote | undefined;\n}\n\nfunction isSplitSupported(firstAmm: Amm, secondAmm: Amm) {\n  if (\n    (firstAmm instanceof SerumAmm && secondAmm instanceof RaydiumAmm) ||\n    (firstAmm instanceof RaydiumAmm && secondAmm instanceof SerumAmm) ||\n    (firstAmm instanceof SerumAmm && secondAmm instanceof SerumAmm)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction requiresSplitSetup(firstAmm: Amm, secondAmm: Amm): boolean {\n  if (firstAmm instanceof RaydiumAmm || secondAmm instanceof RaydiumAmm) {\n    return true;\n  } else if (firstAmm instanceof SerumAmm && secondAmm instanceof SerumAmm) {\n    return true;\n  }\n  return false;\n}\n\n// Create an iteration to quote with a stepped split\nexport class SplitTradeAmm implements Amm {\n  shouldSplitSetup: boolean;\n  market: SerumMarket | null;\n  private portion1: number = 0;\n  private portion2: number = 0;\n\n  constructor(private firstAmm: Amm, private secondAmm: Amm, public reserveTokenMints: PublicKey[]) {\n    this.shouldSplitSetup = requiresSplitSetup(firstAmm, secondAmm);\n    this.market =\n      firstAmm instanceof SerumAmm ? firstAmm.market : secondAmm instanceof SerumAmm ? secondAmm.market : null;\n  }\n\n  static create(firstAmm: Amm, secondAmm: Amm) {\n    if (!isSplitSupported(firstAmm, secondAmm)) return;\n\n    const firstAmmTwoPermutations = getTwoPermutations(firstAmm.reserveTokenMints);\n    const secondAmmTwoPermutations = getTwoPermutations(secondAmm.reserveTokenMints);\n\n    for (const firstAmmTwoPermutation of firstAmmTwoPermutations) {\n      for (const secondAmmTwoPermutation of secondAmmTwoPermutations) {\n        if (firstAmmTwoPermutation.every((value, index) => value.equals(secondAmmTwoPermutation[index]))) {\n          return new SplitTradeAmm(firstAmm, secondAmm, firstAmmTwoPermutation);\n        }\n      }\n    }\n  }\n\n  get id() {\n    return `${this.firstAmm.id}-${this.secondAmm.id}`;\n  }\n\n  get label() {\n    const labelWithPortions = [\n      { label: this.firstAmm.label, portion: this.portion1 },\n      { label: this.secondAmm.label, portion: this.portion2 },\n    ].sort((a, b) => b.portion - a.portion);\n\n    return labelWithPortions.map(({ label, portion }) => `${label} (${portion}%)`).join(' + ');\n  }\n\n  getAccountsForUpdate() {\n    return [];\n  }\n\n  update(_accountInfoMap: AccountInfoMap) {\n    // Underlying amms are updated\n  }\n\n  getQuote(quoteParams: QuoteParams): Quote {\n    const sourceMintString = quoteParams.sourceMint.toBase58();\n    const amount = quoteParams.amount;\n    // Portion in % directly to please the UI\n    let bestSolution: SplitSolution = {\n      outAmount: 0,\n      portion: 0,\n      firstQuote: undefined,\n      secondQuote: undefined,\n    };\n\n    // Increase portion until 100\n    for (let p = 100; (p -= 5); p > 0) {\n      const firstAmount = Math.floor((amount * p) / 100);\n      const secondAmount = amount - firstAmount;\n\n      const firstQuote = this.firstAmm.getQuote({\n        ...quoteParams,\n        amount: firstAmount,\n      });\n      const secondQuote = this.secondAmm.getQuote({\n        ...quoteParams,\n        amount: secondAmount,\n      });\n      const outAmount = firstQuote.outAmount + secondQuote.outAmount;\n\n      if (outAmount < bestSolution.outAmount) {\n        break;\n      }\n\n      bestSolution = {\n        outAmount,\n        portion: p,\n        firstQuote,\n        secondQuote,\n      };\n    }\n\n    if (!bestSolution.firstQuote || !bestSolution.secondQuote) {\n      throw new Error('Unreachable: There was no better solution than getting 0 outAmount');\n    }\n\n    const { outAmount, portion, firstQuote, secondQuote } = bestSolution;\n    const portion1 = portion;\n    const portion2 = 100 - portion1;\n\n    // For UI display\n    this.portion1 = portion1;\n    this.portion2 = portion2;\n\n    let firstAmmFee = {\n      amount: firstQuote.feeAmount,\n      mint: firstQuote.feeMint,\n    };\n    let secondAmmFee = {\n      amount: secondQuote.feeAmount,\n      mint: secondQuote.feeMint,\n    };\n\n    if (firstAmmFee.mint !== secondAmmFee.mint) {\n      // Then we convert destinationMint fee into a sourceMint, to please the current data structure\n      // This will lead to inexact fees but this doesn't affect the user minimum out amount\n      if (firstAmmFee.mint !== sourceMintString) {\n        firstAmmFee = {\n          amount: Math.floor((firstAmmFee.amount * amount * portion1) / 100 / bestSolution.outAmount),\n          mint: sourceMintString,\n        };\n      }\n      if (secondAmmFee.mint !== sourceMintString) {\n        secondAmmFee = {\n          amount: Math.floor((secondAmmFee.amount * amount * portion2) / 100 / bestSolution.outAmount),\n          mint: sourceMintString,\n        };\n      }\n    }\n\n    const feePct = (portion1 * firstQuote.feePct + portion2 * secondQuote.feePct) / 100;\n    const priceImpactPct = (portion1 * firstQuote.priceImpactPct + portion2 * secondQuote.priceImpactPct) / 100;\n\n    // Not sure about the relevance on minInAmount and minOutAmount in this case\n    const minInAmount =\n      firstQuote.minInAmount || secondQuote.minInAmount\n        ? (firstQuote.minInAmount ?? 0) + (secondQuote.minInAmount ?? 0)\n        : undefined;\n    const minOutAmount =\n      firstQuote.minOutAmount || secondQuote.minOutAmount\n        ? (firstQuote.minOutAmount ?? 0) + (secondQuote.minOutAmount ?? 0)\n        : undefined;\n    return {\n      notEnoughLiquidity: false,\n      inAmount: quoteParams.amount,\n      outAmount: outAmount,\n      minInAmount,\n      minOutAmount,\n      feeAmount: firstAmmFee.amount + secondAmmFee.amount,\n      feeMint: firstAmmFee.mint, // Guaranteed identical mint at this point\n      feePct,\n      priceImpactPct,\n    };\n  }\n\n  createSwapInstructions(swapParams: SwapParams) {\n    const amount = swapParams.amount!; // Cannot be null!\n\n    // We rely on the fact that this.portion1 is set, what if it isn't?\n    const firstAmount = Math.floor((amount * this.portion1) / 100);\n    const secondAmount = amount - firstAmount;\n\n    return [\n      createSetTokenLedgerInstruction(swapParams.destinationTokenAccount),\n      ...this.firstAmm.createSwapInstructions({\n        ...swapParams,\n        amount: firstAmount,\n        minimumOutAmount: 0,\n        platformFee: undefined,\n      }),\n      ...this.secondAmm.createSwapInstructions({\n        ...swapParams,\n        amount: secondAmount,\n        minimumOutAmount: 0,\n        platformFee: undefined,\n      }),\n      createRiskCheckAndFeeInstruction(\n        swapParams.destinationTokenAccount,\n        swapParams.userTransferAuthority,\n        swapParams.minimumOutAmount,\n        swapParams.platformFee,\n      ),\n    ];\n  }\n}\n","import { Market as SerumMarket } from '@project-serum/serum';\nimport { PublicKey } from '@solana/web3.js';\nimport { StableSwap } from '@saberhq/stableswap-sdk';\nimport { MarketMeta } from './types';\nimport { SaberAddDecimalsAmm } from './saber/saberAddDecimalsAmm';\nimport { SplitTradeAmm } from './split-trade/splitTradeAmm';\n\nexport interface Fee {\n  amount: number;\n  mint: string;\n  pct: number;\n}\n\nexport { SerumMarket, StableSwap };\n\nexport interface MarketInfo {\n  marketMeta: MarketMeta; //name: string, // pair for serum, pool name for mer pool\n  inputMint: PublicKey;\n  outputMint: PublicKey;\n  minInAmount?: number;\n  minOutAmount?: number;\n  inAmount: number;\n  outAmount: number;\n  notEnoughLiquidity: boolean;\n  priceImpactPct: number;\n  lpFee: Fee;\n  platformFee: Fee;\n}\n\n// This is to check if the two markets are supported by the aggregator\nexport const isValidRoute = (ammA: MarketMeta['amm'], ammB: MarketMeta['amm']) => {\n  // don't show decimal as input or output\n  if (ammA instanceof SaberAddDecimalsAmm && ammB instanceof SaberAddDecimalsAmm) {\n    return false;\n  } else if (ammA instanceof SplitTradeAmm || ammB instanceof SplitTradeAmm) {\n    return false;\n  }\n\n  return true;\n};\n","import { AccountInfo, AccountLayout, u64 } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\n\nexport const deserializeAccount = (data: Buffer | undefined): AccountInfo | undefined => {\n  if (data == undefined || data.length == 0) {\n    return undefined;\n  }\n\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n","import { StableSwap } from '@saberhq/stableswap-sdk';\nimport { PublicKey } from '@solana/web3.js';\nimport { Fraction, ONE, Stable } from '@jup-ag/math';\nimport JSBI from 'jsbi';\nimport Decimal from 'decimal.js';\nimport { AccountInfoMap, Amm, mapAddressToAccountInfos, Quote, QuoteParams, SwapParams } from '../amm';\nimport { createSaberExchangeInstruction } from '../jupiterInstruction';\nimport { deserializeAccount } from '../../utils/deserializeAccount';\nimport { AccountInfo } from '@solana/spl-token';\nimport { ZERO_FRACTION } from '../../constants';\n\nexport class SaberAmm implements Amm {\n  label = 'Saber' as const;\n  private tokenAccounts: AccountInfo[] | undefined;\n  private calculator: Stable | undefined;\n\n  constructor(private stableSwap: StableSwap) {}\n\n  get id() {\n    return this.stableSwap.config.swapAccount.toBase58();\n  }\n\n  getAccountsForUpdate(): PublicKey[] {\n    return [this.stableSwap.state.tokenA.reserve, this.stableSwap.state.tokenB.reserve];\n  }\n\n  update(accountInfoMap: AccountInfoMap) {\n    let tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());\n\n    this.tokenAccounts = tokenAccountInfos.map((info) => {\n      const tokenAccount = deserializeAccount(info.data);\n      if (!tokenAccount) {\n        throw new Error('Invalid token account data');\n      }\n      return tokenAccount;\n    });\n\n    this.calculator = new Stable(\n      JSBI.BigInt(this.stableSwap.state.targetAmpFactor.toString()),\n      this.tokenAccounts.map((tokenAccount) => {\n        return JSBI.BigInt(tokenAccount.amount.toString());\n      }),\n      [ONE, ONE], // TODO: How to get the token decimal?\n      new Fraction(this.stableSwap.state.fees.trade.numerator, this.stableSwap.state.fees.trade.denominator),\n    );\n  }\n\n  getQuote({ sourceMint, destinationMint, amount }: QuoteParams): Quote {\n    if (!this.tokenAccounts) {\n      throw new Error('Unable to fetch accounts for specified tokens.');\n    }\n\n    if (this.calculator === undefined) {\n      throw new Error('Unable to fetch accounts for Curve calculator.');\n    }\n\n    const feePct = new Decimal(this.stableSwap.state.fees.trade.asFraction.toFixed(4));\n\n    const [inputIndex, outputIndex] = this.tokenAccounts[0].mint.equals(sourceMint) ? [0, 1] : [1, 0];\n\n    const result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, inputIndex, outputIndex);\n\n    return {\n      notEnoughLiquidity: false,\n      inAmount: amount,\n      outAmount: JSBI.toNumber(result.expectedOutputAmount),\n      feeAmount: JSBI.toNumber(result.fees),\n      feeMint: destinationMint.toBase58(),\n      feePct: feePct.toNumber(),\n      priceImpactPct: result.priceImpact.toNumber(),\n    };\n  }\n\n  createSwapInstructions({\n    sourceMint,\n    sourceTokenAccount,\n    destinationTokenAccount,\n    userTransferAuthority,\n    amount,\n    minimumOutAmount,\n    platformFee,\n  }: SwapParams) {\n    // The input or output might require the magic wrapping\n    return [\n      createSaberExchangeInstruction(\n        this.stableSwap,\n        sourceMint,\n        sourceTokenAccount,\n        destinationTokenAccount,\n        userTransferAuthority,\n        amount,\n        minimumOutAmount,\n        platformFee,\n      ),\n    ];\n  }\n\n  get reserveTokenMints() {\n    return [this.stableSwap.state.tokenA.mint, this.stableSwap.state.tokenB.mint];\n  }\n}\n","import { u64 } from '@solana/spl-token';\nimport Decimal from 'decimal.js';\n\nconst ZERO = new u64(0);\n\nexport class Percentage {\n  readonly numerator: u64;\n  readonly denominator: u64;\n\n  constructor(numerator: u64, denominator: u64) {\n    this.numerator = numerator;\n    this.denominator = denominator;\n  }\n\n  public static fromDecimal(number: Decimal): Percentage {\n    return Percentage.fromFraction(number.toDecimalPlaces(1).mul(10).toNumber(), 1000);\n  }\n\n  public static fromFraction(numerator: u64 | number, denominator: u64 | number): Percentage {\n    const num = typeof numerator === 'number' ? new u64(numerator.toString()) : numerator;\n    const denom = typeof denominator === 'number' ? new u64(denominator.toString()) : denominator;\n    return new Percentage(num, denom);\n  }\n\n  public toString = (): string => {\n    return `${this.numerator.toString()}/${this.denominator.toString()}`;\n  };\n\n  public toDecimal() {\n    if (this.denominator.eq(ZERO)) {\n      return new Decimal(0);\n    }\n    return new Decimal(this.numerator.toString()).div(new Decimal(this.denominator.toString()));\n  }\n\n  public add(p2: Percentage): Percentage {\n    const denomGcd = this.denominator.gcd(p2.denominator);\n    const denomLcm = this.denominator.div(denomGcd).mul(p2.denominator);\n\n    const p1DenomAdjustment = denomLcm.div(this.denominator);\n    const p2DenomAdjustment = denomLcm.div(p2.denominator);\n\n    const p1NumeratorAdjusted = this.numerator.mul(p1DenomAdjustment);\n    const p2NumeratorAdjusted = p2.numerator.mul(p2DenomAdjustment);\n\n    const newNumerator = p1NumeratorAdjusted.add(p2NumeratorAdjusted);\n\n    return new Percentage(new u64(newNumerator.toString()), new u64(denomLcm.toString()));\n  }\n}\n","import { struct, blob, u8, Structure } from '@solana/buffer-layout';\nimport { u64 } from '@solana/spl-token';\nimport { AccountInfo, PublicKey } from '@solana/web3.js';\nimport { ALDRIN_SWAP_V2_PROGRAM_ID } from '../../constants';\nimport { publicKey, rustEnum, uint64 } from '../../utils/layout';\nimport { Percentage } from './percentage';\n\ntype FeeStructure = {\n  traderFee: Percentage;\n  ownerFee: Percentage;\n};\n\ninterface FeeLayout {\n  tradeFeeNumerator: u64;\n  tradeFeeDenominator: u64;\n  ownerTradeFeeNumerator: u64;\n  ownerTradeFeeDenominator: u64;\n  ownerWithdrawFeeNumerator: u64;\n  ownerWithdrawFeeDenominator: u64;\n}\n\n// https://github.com/aldrin-exchange/aldrin-sdk/blob/78527e3adfc02e186956f420b5083fa0950e7263/src/pools/layout.ts\nconst FEES_LAYOUT = struct<FeeLayout>(\n  [\n    uint64('tradeFeeNumerator'),\n    uint64('tradeFeeDenominator'),\n    uint64('ownerTradeFeeNumerator'),\n    uint64('ownerTradeFeeDenominator'),\n    uint64('ownerWithdrawFeeNumerator'),\n    uint64('ownerWithdrawFeeDenominator'),\n  ],\n  'fees',\n);\n\nconst POOL_FIELDS_COMMON = [\n  blob(8, 'padding'),\n  publicKey('lpTokenFreezeVault'),\n  publicKey('poolMint'),\n  publicKey('baseTokenVault'),\n  publicKey('baseTokenMint'),\n  publicKey('quoteTokenVault'),\n  publicKey('quoteTokenMint'),\n  publicKey('poolSigner'),\n  u8('poolSignerNonce'),\n  publicKey('authority'),\n  publicKey('initializerAccount'),\n  publicKey('feeBaseAccount'),\n  publicKey('feeQuoteAccount'),\n  publicKey('feePoolTokenAccount'),\n  FEES_LAYOUT,\n];\n\ninterface PoolLayout {\n  padding: any;\n  lpTokenFreezeVault: PublicKey;\n  poolMint: PublicKey;\n  baseTokenVault: PublicKey;\n  baseTokenMint: PublicKey;\n  quoteTokenVault: PublicKey;\n  quoteTokenMint: PublicKey;\n  poolSigner: PublicKey;\n  poolSignerNonce: number;\n  authority: PublicKey;\n  initializerAccount: PublicKey;\n  feeBaseAccount: PublicKey;\n  feeQuoteAccount: PublicKey;\n  feePoolTokenAccount: PublicKey;\n  fees: FeeLayout;\n}\n\nexport const POOL_LAYOUT = struct<PoolLayout>(POOL_FIELDS_COMMON);\n\ninterface PoolV2Layout extends PoolLayout {\n  curveType: number;\n  curve: PublicKey;\n}\n\nexport const POOL_V2_LAYOUT = struct<PoolV2Layout>([...POOL_FIELDS_COMMON, u8('curveType'), publicKey('curve')]);\n\ninterface StableCurveLayout {\n  padding: any;\n  amp: u64;\n}\n\nexport const STABLE_CURVE_LAYOUT = struct<StableCurveLayout>([blob(8, 'padding'), uint64('amp')]);\n\ninterface SwapInstructionLayout {\n  instruction: any;\n  tokens: u64;\n  minTokens: u64;\n  side: 'bid' | 'ask';\n}\n\nexport const SWAP_INSTRUCTION_LAYOUT = struct<SwapInstructionLayout>([\n  blob(8, 'instruction'),\n  uint64('tokens'),\n  uint64('minTokens'),\n  rustEnum([new Structure([], 'bid'), new Structure([], 'ask')], 'side'),\n]);\n\nexport function accountInfoToAldrinPoolState(address: PublicKey, accountInfo: AccountInfo<Buffer>): AldrinPoolState {\n  const isV2 = accountInfo.owner.equals(ALDRIN_SWAP_V2_PROGRAM_ID) ? true : false;\n\n  const decoded: PoolV2Layout | PoolLayout = (isV2 ? POOL_V2_LAYOUT : POOL_LAYOUT).decode(accountInfo.data) as\n    | PoolV2Layout\n    | PoolLayout;\n\n  const curveObject = 'curveType' in decoded ? { curveType: decoded.curveType, curve: decoded.curve } : {};\n\n  return {\n    isV2,\n    address,\n    poolMint: decoded.poolMint,\n    baseTokenVault: decoded.baseTokenVault,\n    baseTokenMint: decoded.baseTokenMint,\n    quoteTokenVault: decoded.quoteTokenVault,\n    quoteTokenMint: decoded.quoteTokenMint,\n    poolSigner: decoded.poolSigner,\n    feeBaseAccount: decoded.feeBaseAccount,\n    feeQuoteAccount: decoded.feeQuoteAccount,\n    feePoolTokenAccount: decoded.feePoolTokenAccount,\n    fees: {\n      traderFee: Percentage.fromFraction(decoded.fees.tradeFeeNumerator, decoded.fees.tradeFeeDenominator),\n      ownerFee: Percentage.fromFraction(decoded.fees.ownerTradeFeeNumerator, decoded.fees.ownerTradeFeeDenominator),\n    },\n    ...curveObject,\n  };\n}\n\nexport interface AldrinPoolState {\n  isV2: Boolean;\n  address: PublicKey;\n  poolMint: PublicKey;\n  baseTokenVault: PublicKey;\n  baseTokenMint: PublicKey;\n  quoteTokenVault: PublicKey;\n  quoteTokenMint: PublicKey;\n  poolSigner: PublicKey;\n  feeBaseAccount: PublicKey;\n  feeQuoteAccount: PublicKey;\n  feePoolTokenAccount: PublicKey;\n  fees: FeeStructure;\n  curveType?: number;\n  curve?: PublicKey;\n}\n","import { Fraction, TokenSwapConstantProduct, TokenSwapStable } from '@jup-ag/math';\nimport { AccountInfo, PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport JSBI from 'jsbi';\nimport { deserializeAccount } from '../../utils/deserializeAccount';\nimport { AccountInfoMap, Amm, mapAddressToAccountInfos, Quote, QuoteParams, SwapParams } from '../amm';\nimport { createAldrinSwapInstruction, createAldrinV2SwapInstruction } from '../jupiterInstruction';\nimport { accountInfoToAldrinPoolState, AldrinPoolState, STABLE_CURVE_LAYOUT } from './poolState';\nimport { AccountInfo as TokenAccountInfo } from '@solana/spl-token';\nimport Decimal from 'decimal.js';\nimport { ZERO_FRACTION } from '../../constants';\n\ninterface AldrinParams {\n  amp?: number;\n}\n\nexport class AldrinAmm implements Amm {\n  label = 'Aldrin' as const;\n  poolState: AldrinPoolState;\n  private tokenAccounts: TokenAccountInfo[] = [];\n  calculator: TokenSwapConstantProduct | TokenSwapStable | undefined;\n\n  constructor(address: PublicKey, accountInfo: AccountInfo<Buffer>, private params: AldrinParams = {}) {\n    this.poolState = accountInfoToAldrinPoolState(address, accountInfo);\n  }\n\n  static decodeStableCurveAmp(accountInfo: AccountInfo<Buffer>) {\n    const { amp } = STABLE_CURVE_LAYOUT.decode(accountInfo.data);\n\n    return amp.toNumber() * 2; // times two for their AMP, dont ask me why, it is what it is\n  }\n\n  get id() {\n    return this.poolState.address.toBase58();\n  }\n\n  getAccountsForUpdate(): PublicKey[] {\n    return [this.poolState.quoteTokenVault, this.poolState.baseTokenVault];\n  }\n\n  update(accountInfoMap: AccountInfoMap): void {\n    const tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());\n\n    this.tokenAccounts = tokenAccountInfos.map((info) => {\n      const tokenAccount = deserializeAccount(info.data);\n      if (!tokenAccount) {\n        throw new Error('Invalid token account');\n      }\n      return tokenAccount;\n    });\n\n    if (!this.poolState.curveType) {\n      this.calculator = new TokenSwapConstantProduct(\n        this.tokenAccounts.map((tokenAccount) => {\n          return JSBI.BigInt(tokenAccount.amount.toString());\n        }),\n        new Fraction(\n          JSBI.BigInt(this.poolState.fees.traderFee.numerator.toString()),\n          JSBI.BigInt(this.poolState.fees.traderFee.denominator.toString()),\n        ),\n        new Fraction(\n          JSBI.BigInt(this.poolState.fees.ownerFee.numerator.toString()),\n          JSBI.BigInt(this.poolState.fees.ownerFee.denominator.toString()),\n        ),\n      );\n    } else if (this.poolState.curveType === 1) {\n      const { amp } = this.params;\n      if (!amp) {\n        throw new Error('Amp is required for a stable curve');\n      }\n\n      this.calculator = new TokenSwapStable(\n        JSBI.BigInt(amp),\n        this.tokenAccounts.map((tokenAccount) => {\n          return JSBI.BigInt(tokenAccount.amount.toString());\n        }),\n        new Fraction(\n          JSBI.BigInt(this.poolState.fees.traderFee.numerator.toString()),\n          JSBI.BigInt(this.poolState.fees.traderFee.denominator.toString()),\n        ),\n        new Fraction(\n          JSBI.BigInt(this.poolState.fees.ownerFee.numerator.toString()),\n          JSBI.BigInt(this.poolState.fees.ownerFee.denominator.toString()),\n        ),\n      );\n    }\n  }\n\n  getQuote({ sourceMint, amount }: QuoteParams): Quote {\n    if (this.tokenAccounts.length === 0) {\n      throw new Error('Unable to fetch accounts for specified tokens.');\n    }\n\n    if (this.calculator === undefined) {\n      throw new Error('Unable to fetch accounts for Curve calculator.');\n    }\n\n    let feePct = new Decimal(this.poolState.fees.traderFee.numerator.toString())\n      .div(this.poolState.fees.traderFee.denominator.toString())\n      .add(\n        new Decimal(this.poolState.fees.ownerFee.numerator.toString()).div(\n          this.poolState.fees.ownerFee.denominator.toString(),\n        ),\n      );\n\n    const outputIndex = this.tokenAccounts[0].mint.equals(sourceMint) ? 1 : 0;\n    let result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, outputIndex);\n\n    return {\n      notEnoughLiquidity: false,\n      inAmount: amount,\n      outAmount: JSBI.toNumber(result.expectedOutputAmount),\n      feeAmount: JSBI.toNumber(result.fees),\n      feeMint: sourceMint.toBase58(),\n      feePct: feePct.toNumber(),\n      priceImpactPct: result.priceImpact.toNumber(),\n    };\n  }\n\n  createSwapInstructions({\n    sourceMint,\n    sourceTokenAccount,\n    destinationTokenAccount,\n    userTransferAuthority,\n    amount,\n    minimumOutAmount,\n    platformFee,\n  }: SwapParams) {\n    if (this.poolState.isV2) {\n      if (!this.poolState.curve) {\n        throw new Error('Unable to fetch curve account.');\n      }\n\n      return [\n        createAldrinV2SwapInstruction(\n          this.poolState,\n          sourceMint,\n          sourceTokenAccount,\n          destinationTokenAccount,\n          this.poolState.curve,\n          userTransferAuthority,\n          amount,\n          minimumOutAmount,\n          platformFee,\n        ),\n      ];\n    }\n\n    return [\n      createAldrinSwapInstruction(\n        this.poolState,\n        sourceMint,\n        sourceTokenAccount,\n        destinationTokenAccount,\n        userTransferAuthority,\n        amount,\n        minimumOutAmount,\n        platformFee,\n      ),\n    ];\n  }\n\n  get reserveTokenMints() {\n    return [this.poolState.baseTokenMint, this.poolState.quoteTokenMint];\n  }\n}\n","import { PublicKey } from '@solana/web3.js';\n\n// TODO: Remove harcoded pools before merge\nconst TOKEN_SWAP_POOLS: PublicKey[] = [];\n\nexport const STEP_TOKEN_SWAP_PROGRAM_ID = new PublicKey('SSwpMgqNDsyV7mAgN9ady4bDVu5ySjmmXejXvy2vLt1');\n\nexport const PROGRAM_ID_TO_LABEL = new Map<string, string>([\n  ['9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP', 'Orca'],\n  [STEP_TOKEN_SWAP_PROGRAM_ID.toBase58(), 'Step'],\n  ['PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP', 'Penguin'],\n]);\n\nexport function getTokenSwapPools(cluster: string) {\n  return cluster === 'mainnet-beta' ? TOKEN_SWAP_POOLS : [];\n}\n","import { findProgramAddressSync } from '@project-serum/anchor/dist/cjs/utils/pubkey';\nimport { struct, u8, blob } from '@solana/buffer-layout';\nimport { u64 } from '@solana/spl-token';\nimport { AccountInfo, PublicKey } from '@solana/web3.js';\nimport { publicKey, uint64 } from '../../utils/layout';\nimport { STEP_TOKEN_SWAP_PROGRAM_ID } from './splTokenSwapPools';\n\ninterface TokenSwapLayout {\n  version: number;\n  isInitialized: number;\n  bumpSeed: number;\n  tokenProgramId: PublicKey;\n  tokenAccountA: PublicKey;\n  tokenAccountB: PublicKey;\n  tokenPool: PublicKey;\n  mintA: PublicKey;\n  mintB: PublicKey;\n  feeAccount: PublicKey;\n  tradeFeeNumerator: u64;\n  tradeFeeDenominator: u64;\n  ownerTradeFeeNumerator: u64;\n  ownerTradeFeeDenominator: u64;\n  ownerWithdrawFeeNumerator: u64;\n  ownerWithdrawFeeDenominator: u64;\n  hostFeeNumerator: u64;\n  hostFeeDenominator: u64;\n  curveType: number;\n  curveParameters: Uint8Array;\n}\n\nconst TokenSwapLayout = struct<TokenSwapLayout>([\n  u8('version'),\n  u8('isInitialized'),\n  u8('bumpSeed'),\n  publicKey('tokenProgramId'),\n  publicKey('tokenAccountA'),\n  publicKey('tokenAccountB'),\n  publicKey('tokenPool'),\n  publicKey('mintA'),\n  publicKey('mintB'),\n  publicKey('feeAccount'),\n  uint64('tradeFeeNumerator'),\n  uint64('tradeFeeDenominator'),\n  uint64('ownerTradeFeeNumerator'),\n  uint64('ownerTradeFeeDenominator'),\n  uint64('ownerWithdrawFeeNumerator'),\n  uint64('ownerWithdrawFeeDenominator'),\n  uint64('hostFeeNumerator'),\n  uint64('hostFeeDenominator'),\n  u8('curveType'),\n  blob(32, 'curveParameters'),\n]);\n\ninterface StepTokenSwapLayout extends TokenSwapLayout {\n  poolNonce: u64;\n}\n\nconst StepTokenSwapLayout = struct<StepTokenSwapLayout>([\n  u8('version'),\n  u8('isInitialized'),\n  u8('bumpSeed'),\n  publicKey('tokenProgramId'),\n  publicKey('tokenAccountA'),\n  publicKey('tokenAccountB'),\n  publicKey('tokenPool'),\n  publicKey('mintA'),\n  publicKey('mintB'),\n  publicKey('feeAccount'),\n  uint64('tradeFeeNumerator'),\n  uint64('tradeFeeDenominator'),\n  uint64('ownerTradeFeeNumerator'),\n  uint64('ownerTradeFeeDenominator'),\n  uint64('ownerWithdrawFeeNumerator'),\n  uint64('ownerWithdrawFeeDenominator'),\n  u8('curveType'),\n  blob(32, 'curveParameters'),\n  u8('poolNonce'),\n]);\n\nexport interface TokenSwapState {\n  address: PublicKey;\n  programId: PublicKey;\n  tokenProgramId: PublicKey;\n  poolToken: PublicKey;\n  feeAccount: PublicKey;\n  authority: PublicKey;\n  tokenAccountA: PublicKey;\n  tokenAccountB: PublicKey;\n  mintA: PublicKey;\n  mintB: PublicKey;\n  tradeFeeNumerator: u64;\n  tradeFeeDenominator: u64;\n  ownerTradeFeeNumerator: u64;\n  ownerTradeFeeDenominator: u64;\n  ownerWithdrawFeeNumerator: u64;\n  ownerWithdrawFeeDenominator: u64;\n  curveType: number;\n  curveParameters: Uint8Array;\n  poolNonce?: u64;\n}\n\nexport function accountInfoToTokenSwapState(\n  address: PublicKey,\n  tokenSwapAccountInfo: AccountInfo<Buffer>,\n): TokenSwapState {\n  const programId = tokenSwapAccountInfo.owner;\n\n  // The layout difference only affects fields we do not actively use\n  const tokenSwapData = (\n    programId.equals(STEP_TOKEN_SWAP_PROGRAM_ID)\n      ? StepTokenSwapLayout.decode(tokenSwapAccountInfo.data)\n      : TokenSwapLayout.decode(tokenSwapAccountInfo.data)\n  ) as TokenSwapLayout | StepTokenSwapLayout;\n\n  if (!tokenSwapData.isInitialized) {\n    throw new Error(`Invalid token swap state`);\n  }\n\n  const [authority] = findProgramAddressSync([address.toBuffer()], programId);\n\n  const poolToken = new PublicKey(tokenSwapData.tokenPool);\n  const feeAccount = new PublicKey(tokenSwapData.feeAccount);\n  const tokenAccountA = new PublicKey(tokenSwapData.tokenAccountA);\n  const tokenAccountB = new PublicKey(tokenSwapData.tokenAccountB);\n  const mintA = new PublicKey(tokenSwapData.mintA);\n  const mintB = new PublicKey(tokenSwapData.mintB);\n  const tokenProgramId = new PublicKey(tokenSwapData.tokenProgramId);\n\n  const tradeFeeNumerator = tokenSwapData.tradeFeeNumerator;\n  const tradeFeeDenominator = tokenSwapData.tradeFeeDenominator;\n  const ownerTradeFeeNumerator = tokenSwapData.ownerTradeFeeNumerator;\n  const ownerTradeFeeDenominator = tokenSwapData.ownerTradeFeeDenominator;\n  const ownerWithdrawFeeNumerator = tokenSwapData.ownerWithdrawFeeNumerator;\n  const ownerWithdrawFeeDenominator = tokenSwapData.ownerWithdrawFeeDenominator;\n\n  const curveType = tokenSwapData.curveType;\n  const curveParameters = tokenSwapData.curveParameters;\n\n  const poolNonce = 'poolNonce' in tokenSwapData ? tokenSwapData.poolNonce : undefined;\n\n  return {\n    address,\n    programId,\n    tokenProgramId,\n    poolToken,\n    feeAccount,\n    authority,\n    tokenAccountA,\n    tokenAccountB,\n    mintA,\n    mintB,\n    tradeFeeNumerator,\n    tradeFeeDenominator,\n    ownerTradeFeeNumerator,\n    ownerTradeFeeDenominator,\n    ownerWithdrawFeeNumerator,\n    ownerWithdrawFeeDenominator,\n    curveType,\n    curveParameters,\n    poolNonce,\n  };\n}\n","import { AccountInfo, PublicKey } from '@solana/web3.js';\nimport Decimal from 'decimal.js';\nimport { AccountInfoMap, Amm, mapAddressToAccountInfos, Quote, QuoteParams, SwapParams } from '../amm';\nimport { createTokenSwapInstruction } from '../jupiterInstruction';\nimport { accountInfoToTokenSwapState, TokenSwapState } from './tokenSwapLayout';\nimport { deserializeAccount } from '../../utils/deserializeAccount';\nimport { Fraction, TokenSwapConstantProduct, TokenSwapStable } from '@jup-ag/math';\nimport JSBI from 'jsbi';\nimport { AccountInfo as TokenAccountInfo } from '@solana/spl-token';\nimport { ZERO_FRACTION } from '../../constants';\nimport { STEP_TOKEN_SWAP_PROGRAM_ID } from './splTokenSwapPools';\n\nenum CurveType {\n  ConstantProduct = 0,\n  Stable = 2,\n}\n\n// Abstract any SPL token swap based AMM\nexport class SplTokenSwapAmm implements Amm {\n  private tokenSwapState: TokenSwapState;\n  private curveType: CurveType;\n\n  private tokenAccounts: TokenAccountInfo[] = [];\n  calculator: TokenSwapConstantProduct | TokenSwapStable | undefined;\n\n  constructor(address: PublicKey, swapStateAccountInfo: AccountInfo<Buffer>, public label: string) {\n    this.tokenSwapState = accountInfoToTokenSwapState(address, swapStateAccountInfo);\n\n    this.curveType = this.tokenSwapState.curveType;\n    if (!(this.curveType in CurveType)) {\n      throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);\n    }\n  }\n\n  get id() {\n    return this.tokenSwapState.address.toBase58();\n  }\n\n  getAccountsForUpdate(): PublicKey[] {\n    return [this.tokenSwapState.tokenAccountA, this.tokenSwapState.tokenAccountB];\n  }\n\n  update(accountInfoMap: AccountInfoMap): void {\n    const tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());\n\n    this.tokenAccounts = tokenAccountInfos.map((info) => {\n      const tokenAccount = deserializeAccount(info.data);\n      if (!tokenAccount) {\n        throw new Error('Invalid token account');\n      }\n      return tokenAccount;\n    });\n\n    if (this.tokenSwapState.curveType === CurveType.ConstantProduct) {\n      this.calculator = new TokenSwapConstantProduct(\n        this.tokenAccounts.map((tokenAccount) => {\n          return JSBI.BigInt(tokenAccount.amount.toString());\n        }),\n        new Fraction(\n          JSBI.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),\n          JSBI.BigInt(this.tokenSwapState.tradeFeeDenominator.toString()),\n        ),\n        new Fraction(\n          JSBI.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),\n          JSBI.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString()),\n        ),\n      );\n    } else if (this.tokenSwapState.curveType === CurveType.Stable) {\n      this.calculator = new TokenSwapStable(\n        JSBI.BigInt(this.tokenSwapState.curveParameters[0]),\n        this.tokenAccounts.map((tokenAccount) => {\n          return JSBI.BigInt(tokenAccount.amount.toString());\n        }),\n        new Fraction(\n          JSBI.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),\n          JSBI.BigInt(this.tokenSwapState.tradeFeeDenominator.toString()),\n        ),\n        new Fraction(\n          JSBI.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),\n          JSBI.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString()),\n        ),\n      );\n    }\n  }\n\n  getQuote({ sourceMint, amount }: QuoteParams): Quote {\n    if (this.tokenAccounts.length === 0) {\n      throw new Error('Unable to fetch accounts for specified tokens.');\n    }\n\n    if (this.calculator === undefined) {\n      throw new Error('Unable to fetch accounts for Curve calculator.');\n    }\n\n    let feePct = new Decimal(this.tokenSwapState.tradeFeeNumerator.toString())\n      .div(this.tokenSwapState.tradeFeeDenominator.toString())\n      .add(\n        new Decimal(this.tokenSwapState.ownerTradeFeeNumerator.toString()).div(\n          this.tokenSwapState.ownerTradeFeeDenominator.toString(),\n        ),\n      );\n\n    const outputIndex = this.tokenAccounts[0].mint.equals(sourceMint) ? 1 : 0;\n    let result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, outputIndex);\n\n    return {\n      notEnoughLiquidity: false,\n      inAmount: amount,\n      outAmount: JSBI.toNumber(result.expectedOutputAmount),\n      feeAmount: JSBI.toNumber(result.fees),\n      feeMint: sourceMint.toBase58(),\n      feePct: feePct.toNumber(),\n      priceImpactPct: result.priceImpact.toNumber(),\n    };\n  }\n\n  createSwapInstructions({\n    sourceMint,\n    sourceTokenAccount,\n    destinationTokenAccount,\n    userTransferAuthority,\n    amount,\n    minimumOutAmount,\n    platformFee,\n  }: SwapParams) {\n    return [\n      createTokenSwapInstruction(\n        this.tokenSwapState,\n        sourceMint,\n        sourceTokenAccount,\n        destinationTokenAccount,\n        userTransferAuthority,\n        amount,\n        minimumOutAmount,\n        platformFee,\n        this.tokenSwapState.programId.equals(STEP_TOKEN_SWAP_PROGRAM_ID),\n      ),\n    ];\n  }\n\n  get reserveTokenMints() {\n    return [this.tokenSwapState.mintA, this.tokenSwapState.mintB];\n  }\n}\n","import { findProgramAddressSync } from '@project-serum/anchor/dist/cjs/utils/pubkey';\nimport { struct, u8, u32 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/spl-token';\nimport { AccountInfo, PublicKey } from '@solana/web3.js';\nimport { uint64, publicKey } from '../../utils/layout';\n\nexport const FEE_DENOMINATOR = Math.pow(10, 10);\n\ninterface MercurialSwapLayout {\n  version: number;\n  isInitialized: number;\n  nonce: number;\n  amplificationCoefficient: u64;\n  feeNumerator: u64;\n  adminFeeNumerator: u64;\n  tokenAccountsLength: number;\n  precisionFactor: u64;\n  precisionMultiplierA: u64;\n  precisionMultiplierB: u64;\n  precisionMultiplierC: u64;\n  precisionMultiplierD: u64;\n  tokenAccountA: PublicKey;\n  tokenAccountB: PublicKey;\n  tokenAccountC: PublicKey;\n  tokenAccountD: PublicKey;\n}\n\nexport const MercurialSwapLayout = struct<MercurialSwapLayout>([\n  u8('version'),\n  u8('isInitialized'),\n  u8('nonce'),\n  uint64('amplificationCoefficient'),\n  uint64('feeNumerator'),\n  uint64('adminFeeNumerator'),\n  u32('tokenAccountsLength'),\n  uint64('precisionFactor'),\n  uint64('precisionMultiplierA'),\n  uint64('precisionMultiplierB'),\n  uint64('precisionMultiplierC'),\n  uint64('precisionMultiplierD'),\n  publicKey('tokenAccountA'),\n  publicKey('tokenAccountB'),\n  publicKey('tokenAccountC'),\n  publicKey('tokenAccountD'),\n]);\n\nexport interface MercurialSwapLayoutState {\n  programId: PublicKey;\n  authority: PublicKey;\n  isInitialized: boolean;\n  nonce: number;\n  ammId: PublicKey;\n  amplificationCoefficient: number;\n  feeNumerator: number;\n  tokenAccountsLength: number;\n  precisionFactor: number;\n  precisionMultipliers: number[];\n  tokenAccounts: PublicKey[];\n}\n\nexport const accountInfoToMercurialSwapLayout = (\n  address: PublicKey,\n  accountInfo: AccountInfo<Buffer>,\n): MercurialSwapLayoutState => {\n  const programId = accountInfo.owner;\n  const decoded = MercurialSwapLayout.decode(accountInfo.data);\n  const tokenAccountsLength = decoded.tokenAccountsLength;\n  const [authority] = findProgramAddressSync([address.toBuffer()], programId);\n\n  const precisionMultipliers = [\n    decoded.precisionMultiplierA.toNumber(),\n    decoded.precisionMultiplierB.toNumber(),\n    decoded.precisionMultiplierC.toNumber(),\n    decoded.precisionMultiplierD.toNumber(),\n  ].slice(0, tokenAccountsLength);\n\n  const tokenAccounts = [\n    decoded.tokenAccountA,\n    decoded.tokenAccountB,\n    decoded.tokenAccountC,\n    decoded.tokenAccountD,\n  ].slice(0, tokenAccountsLength);\n\n  return {\n    programId,\n    authority,\n    isInitialized: Boolean(decoded.isInitialized),\n    nonce: decoded.nonce,\n    ammId: address,\n    amplificationCoefficient: decoded.amplificationCoefficient.toNumber(),\n    feeNumerator: decoded.feeNumerator.toNumber(),\n    tokenAccountsLength,\n    precisionFactor: decoded.precisionFactor.toNumber(),\n    precisionMultipliers,\n    tokenAccounts,\n  };\n};\n","import { Fraction, Stable } from '@jup-ag/math';\nimport { AccountInfo, Connection, PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport JSBI from 'jsbi';\nimport { AccountInfoMap, Amm, mapAddressToAccountInfos, Quote, QuoteParams, SwapParams } from '../amm';\nimport { createMercurialExchangeInstruction } from '../jupiterInstruction';\nimport { deserializeAccount } from '../../utils/deserializeAccount';\nimport { ZERO_FRACTION } from '../../constants';\nimport { AccountInfo as TokenAccountInfo } from '@solana/spl-token';\nimport { accountInfoToMercurialSwapLayout, FEE_DENOMINATOR, MercurialSwapLayoutState } from './swapLayout';\n\ninterface MercurialParams {\n  tokenMints: string[];\n}\n\nexport class MercurialAmm implements Amm {\n  label = 'Mercurial';\n  swapLayout: MercurialSwapLayoutState;\n  private tokenAccounts: TokenAccountInfo[] = [];\n  private calculator: Stable | undefined;\n\n  static decodeSwapLayout = accountInfoToMercurialSwapLayout;\n\n  constructor(address: PublicKey, accountInfo: AccountInfo<Buffer>, private params: MercurialParams) {\n    this.swapLayout = accountInfoToMercurialSwapLayout(address, accountInfo);\n  }\n\n  get id() {\n    return this.swapLayout.ammId.toBase58();\n  }\n\n  getAccountsForUpdate(): PublicKey[] {\n    return this.swapLayout.tokenAccounts;\n  }\n\n  update(accountInfoMap: AccountInfoMap) {\n    let tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());\n\n    this.tokenAccounts = tokenAccountInfos\n      .map((info) => deserializeAccount(info.data))\n      .filter((x): x is TokenAccountInfo => x !== null);\n\n    this.calculator = new Stable(\n      JSBI.BigInt(this.swapLayout.amplificationCoefficient),\n      this.tokenAccounts.map((tokenAccount) => {\n        return JSBI.BigInt(tokenAccount.amount.toString());\n      }),\n      this.swapLayout.precisionMultipliers.map((precisionMultiplier) => JSBI.BigInt(precisionMultiplier)),\n      new Fraction(JSBI.BigInt(this.swapLayout.feeNumerator), JSBI.BigInt(FEE_DENOMINATOR)),\n    );\n  }\n\n  getQuote({ sourceMint, destinationMint, amount }: QuoteParams): Quote {\n    if (this.tokenAccounts.length === 0) {\n      throw new Error('Unable to fetch accounts for specified tokens.');\n    }\n\n    if (this.calculator === undefined) {\n      throw new Error('Unable to fetch accounts for Curve calculator.');\n    }\n\n    const inputIndex = this.tokenAccounts.findIndex((tokenAccount) => tokenAccount.mint.equals(sourceMint));\n    const outputIndex = this.tokenAccounts.findIndex((tokenAccount) => tokenAccount.mint.equals(destinationMint));\n    const result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, inputIndex, outputIndex);\n\n    const feePct = this.swapLayout.feeNumerator / FEE_DENOMINATOR;\n\n    return {\n      notEnoughLiquidity: false,\n      inAmount: amount,\n      outAmount: JSBI.toNumber(result.expectedOutputAmount),\n      feeAmount: JSBI.toNumber(result.fees),\n      feeMint: destinationMint.toBase58(),\n      feePct: feePct,\n      priceImpactPct: result.priceImpact.toNumber(),\n    };\n  }\n\n  createSwapInstructions({\n    sourceTokenAccount,\n    destinationTokenAccount,\n    userTransferAuthority,\n    amount,\n    minimumOutAmount,\n    platformFee,\n  }: SwapParams): TransactionInstruction[] {\n    return [\n      createMercurialExchangeInstruction(\n        this.swapLayout,\n        sourceTokenAccount,\n        destinationTokenAccount,\n        userTransferAuthority,\n        amount,\n        minimumOutAmount,\n        platformFee,\n      ),\n    ];\n  }\n\n  get reserveTokenMints() {\n    return this.params.tokenMints.map((tokenMint) => new PublicKey(tokenMint));\n  }\n}\n","import { Fraction, TokenSwapConstantProduct } from '@jup-ag/math';\nimport { AccountInfo, Connection, PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport JSBI from 'jsbi';\nimport { deserializeAccount } from '../../utils/deserializeAccount';\nimport { AccountInfoMap, Amm, mapAddressToAccountInfos, Quote, QuoteParams, SwapParams } from '../amm';\nimport { createCropperSwapInstruction } from '../jupiterInstruction';\n\nimport { AccountInfo as TokenAccountInfo } from '@solana/spl-token';\nimport { ZERO_FRACTION } from '../../constants';\nimport {\n  accountInfoToCropperPoolState,\n  CropperPoolState,\n  stateAccountInfoToCropperState,\n  CROPPER_STATE_ADDRESS,\n} from './swapLayout';\nimport Decimal from 'decimal.js';\n\ninterface CropperParams {\n  tokenAFeeAccount: PublicKey;\n  tokenBFeeAccount: PublicKey;\n  returnFeeNumerator: number;\n  fixedFeeNumerator: number;\n  feeDenominator: number;\n}\n\nexport class CropperAmm implements Amm {\n  label = 'Cropper' as const;\n  poolState: CropperPoolState;\n  private tokenAccounts: TokenAccountInfo[] = [];\n  private calculator: TokenSwapConstantProduct | undefined;\n  private feePct: Decimal;\n\n  // Hardcoded because no where to query this\n  static async getStateFromStateAccount(connection: Connection) {\n    const accountInfo = await connection.getAccountInfo(CROPPER_STATE_ADDRESS);\n\n    if (!accountInfo) {\n      throw new Error('State account not found');\n    }\n\n    return stateAccountInfoToCropperState(accountInfo);\n  }\n\n  static decodePoolState = accountInfoToCropperPoolState;\n\n  constructor(address: PublicKey, accountInfo: AccountInfo<Buffer>, private params: CropperParams) {\n    this.poolState = accountInfoToCropperPoolState(address, accountInfo);\n\n    this.feePct = new Decimal(this.params.fixedFeeNumerator)\n      .div(this.params.feeDenominator)\n      .add(new Decimal(this.params.returnFeeNumerator).div(this.params.feeDenominator));\n\n    this.params.tokenAFeeAccount = new PublicKey(this.params.tokenAFeeAccount);\n    this.params.tokenBFeeAccount = new PublicKey(this.params.tokenBFeeAccount);\n  }\n\n  get id() {\n    return this.poolState.ammId.toBase58();\n  }\n\n  getAccountsForUpdate(): PublicKey[] {\n    return [this.poolState.tokenAAccount, this.poolState.tokenBAccount];\n  }\n\n  update(accountInfoMap: AccountInfoMap): void {\n    const tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());\n\n    this.tokenAccounts = tokenAccountInfos.map((info) => {\n      const tokenAccount = deserializeAccount(info.data);\n      if (!tokenAccount) {\n        throw new Error('Invalid token account');\n      }\n      return tokenAccount;\n    });\n\n    this.calculator = new TokenSwapConstantProduct(\n      this.tokenAccounts.map((tokenAccount) => {\n        return JSBI.BigInt(tokenAccount.amount.toString());\n      }),\n      new Fraction(JSBI.BigInt(this.params.fixedFeeNumerator), JSBI.BigInt(this.params.feeDenominator)),\n      new Fraction(JSBI.BigInt(this.params.returnFeeNumerator), JSBI.BigInt(this.params.feeDenominator)),\n    );\n  }\n\n  getQuote({ sourceMint, amount }: QuoteParams): Quote {\n    if (this.tokenAccounts.length === 0) {\n      throw new Error('Unable to fetch accounts for specified tokens.');\n    }\n\n    if (this.calculator === undefined) {\n      throw new Error('Unable to fetch accounts for calculator.');\n    }\n\n    const outputIndex = this.tokenAccounts[0].mint.equals(sourceMint) ? 1 : 0;\n    let result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, outputIndex);\n\n    return {\n      notEnoughLiquidity: false,\n      inAmount: amount,\n      outAmount: JSBI.toNumber(result.expectedOutputAmount),\n      feeAmount: JSBI.toNumber(result.fees),\n      feeMint: sourceMint.toBase58(),\n      feePct: this.feePct.toNumber(),\n      priceImpactPct: result.priceImpact.toNumber(),\n    };\n  }\n\n  createSwapInstructions({\n    sourceMint,\n    sourceTokenAccount,\n    destinationTokenAccount,\n    userTransferAuthority,\n    amount,\n    minimumOutAmount,\n    platformFee,\n  }: SwapParams): TransactionInstruction[] {\n    const feeAccount = sourceMint.equals(this.poolState.mintA)\n      ? this.params.tokenAFeeAccount\n      : this.params.tokenBFeeAccount;\n\n    return [\n      createCropperSwapInstruction(\n        this.poolState,\n        sourceMint,\n        sourceTokenAccount,\n        destinationTokenAccount,\n        userTransferAuthority,\n        feeAccount,\n        amount,\n        minimumOutAmount,\n        platformFee,\n      ),\n    ];\n  }\n\n  get reserveTokenMints() {\n    return [this.poolState.mintA, this.poolState.mintB];\n  }\n}\n","import { struct, u8, Layout, blob } from '@solana/buffer-layout';\nimport { PublicKey, AccountInfo } from '@solana/web3.js';\nimport { u64 } from '@solana/spl-token';\nimport { publicKey, uint64 } from '../../utils/layout';\n\ninterface SenchaSwapLayout {\n  discriminator: any;\n  factory: PublicKey;\n  bump: number;\n  index: u64;\n  admin: PublicKey;\n  token0Reserves: PublicKey;\n  token0Mint: PublicKey;\n  token0Fees: PublicKey;\n  token1Reserves: PublicKey;\n  token1Mint: PublicKey;\n  token1Fees: PublicKey;\n  isPaused: number;\n  poolMint: PublicKey;\n  tradeFeeKbps: u64;\n  withdrawFeeKbps: u64;\n  adminTradeFeeKbps: u64;\n  adminWithdrawFeeKbps: u64;\n}\n\nexport const SenchaSwapLayout = struct<SenchaSwapLayout>([\n  blob(8, 'discriminator'),\n  publicKey('factory'),\n  u8('bump'),\n  uint64('index'),\n  publicKey('admin'),\n  publicKey('token0Reserves'),\n  publicKey('token0Mint'),\n  publicKey('token0Fees'),\n  publicKey('token1Reserves'),\n  publicKey('token1Mint'),\n  publicKey('token1Fees'),\n  u8('isPaused'),\n  publicKey('poolMint'),\n  uint64('tradeFeeKbps'),\n  uint64('withdrawFeeKbps'),\n  uint64('adminTradeFeeKbps'),\n  uint64('adminWithdrawFeeKbps'),\n]);\n\nexport interface SenchaPoolState {\n  programId: PublicKey;\n  isPaused: boolean;\n  bump: number;\n  ammId: PublicKey;\n  token0Reserves: PublicKey;\n  token1Reserves: PublicKey;\n  token0Mint: PublicKey;\n  token1Mint: PublicKey;\n  token0Fees: PublicKey;\n  token1Fees: PublicKey;\n  poolMint: PublicKey;\n  tradeFeeKbps: number;\n}\n\nexport const accountInfoToSenchaPoolState = (address: PublicKey, accountInfo: AccountInfo<Buffer>): SenchaPoolState => {\n  const programId = accountInfo.owner;\n  const decoded = SenchaSwapLayout.decode(accountInfo.data);\n\n  return {\n    programId,\n    isPaused: Boolean(decoded.isPaused),\n    bump: decoded.bump,\n    ammId: address,\n    token0Reserves: decoded.token0Reserves,\n    token1Reserves: decoded.token1Reserves,\n    token0Mint: decoded.token0Mint,\n    token1Mint: decoded.token1Mint,\n    token0Fees: decoded.token0Fees,\n    token1Fees: decoded.token1Fees,\n    poolMint: decoded.poolMint,\n    tradeFeeKbps: decoded.tradeFeeKbps.toNumber(),\n  };\n};\n","import { AccountInfo, PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { AccountInfoMap, Amm, mapAddressToAccountInfos, Quote, QuoteParams, SwapParams } from '../amm';\nimport { accountInfoToSenchaPoolState, SenchaPoolState } from './swapLayout';\nimport { AccountInfo as TokenAccountInfo } from '@solana/spl-token';\nimport { deserializeAccount } from '../../utils/deserializeAccount';\nimport { createSenchaSwapInstruction } from '../jupiterInstruction';\nimport { Fraction, TokenSwapConstantProduct, ZERO } from '@jup-ag/math';\nimport JSBI from 'jsbi';\nimport { ZERO_FRACTION } from '../../constants';\n\nexport class SenchaAmm implements Amm {\n  label = 'Sencha' as const;\n  poolState: SenchaPoolState;\n  private calculator: TokenSwapConstantProduct | undefined;\n  private tokenAccounts: TokenAccountInfo[] = [];\n\n  constructor(address: PublicKey, accountInfo: AccountInfo<Buffer>) {\n    this.poolState = accountInfoToSenchaPoolState(address, accountInfo);\n  }\n\n  get id() {\n    return this.poolState.ammId.toBase58();\n  }\n\n  getAccountsForUpdate(): PublicKey[] {\n    return [this.poolState.token0Reserves, this.poolState.token1Reserves];\n  }\n\n  update(accountInfoMap: AccountInfoMap): void {\n    const tokenAccountInfos = mapAddressToAccountInfos(accountInfoMap, this.getAccountsForUpdate());\n\n    this.tokenAccounts = tokenAccountInfos.map((info) => {\n      const tokenAccount = deserializeAccount(info.data);\n      if (!tokenAccount) {\n        throw new Error('Invalid token account');\n      }\n      return tokenAccount;\n    });\n\n    this.calculator = new TokenSwapConstantProduct(\n      this.tokenAccounts.map((tokenAccount) => {\n        return JSBI.BigInt(tokenAccount.amount.toString());\n      }),\n      new Fraction(\n        JSBI.BigInt(this.poolState.tradeFeeKbps),\n        JSBI.BigInt(10000000), // 100% = 10000000kbps\n      ),\n      new Fraction(ZERO, ZERO),\n      false,\n    );\n  }\n\n  getQuote({ sourceMint, amount }: QuoteParams): Quote {\n    if (this.tokenAccounts.length === 0) {\n      throw new Error('Unable to fetch accounts for specified tokens.');\n    }\n\n    if (this.calculator === undefined) {\n      throw new Error('Unable to fetch accounts for Curve calculator.');\n    }\n\n    const outputIndex = this.tokenAccounts[0].mint.equals(sourceMint) ? 1 : 0;\n    let result = this.calculator.exchange(JSBI.BigInt(amount), ZERO_FRACTION, outputIndex);\n\n    let feePct = this.poolState.tradeFeeKbps / 10000000; // 100% kbps\n\n    return {\n      notEnoughLiquidity: false,\n      inAmount: amount,\n      outAmount: JSBI.toNumber(result.expectedOutputAmount),\n      feeAmount: JSBI.toNumber(result.fees),\n      feeMint: sourceMint.toBase58(),\n      feePct,\n      priceImpactPct: result.priceImpact.toNumber(),\n    };\n  }\n\n  createSwapInstructions({\n    sourceMint,\n    sourceTokenAccount,\n    destinationTokenAccount,\n    userTransferAuthority,\n    amount,\n    minimumOutAmount,\n    platformFee,\n  }: SwapParams): TransactionInstruction[] {\n    return [\n      createSenchaSwapInstruction(\n        this.poolState,\n        sourceMint,\n        sourceTokenAccount,\n        destinationTokenAccount,\n        userTransferAuthority,\n        amount,\n        minimumOutAmount,\n        platformFee,\n      ),\n    ];\n  }\n\n  get reserveTokenMints() {\n    return [this.poolState.token0Mint, this.poolState.token1Mint];\n  }\n}\n","import { AccountInfo, Cluster, Connection, PublicKey } from '@solana/web3.js';\nimport { isValidRoute, MarketInfo } from './market';\nimport { MARKETS_URL, WRAPPED_SOL_MINT } from '../constants';\nimport { RaydiumAmm } from './raydium/raydiumAmm';\nimport fetch from 'cross-fetch';\nimport { MarketMeta, TokenRouteSegments } from './types';\nimport { Amm } from './amm';\nimport { SerumAmm } from './serum/serumAmm';\nimport { ammFactory } from './ammFactory';\nimport { getTokenSwapPools } from './spl-token-swap/splTokenSwapPools';\nimport { getSaberWrappedDecimalsAmms, SaberAddDecimalsAmm } from './saber/saberAddDecimalsAmm';\nimport { SplitTradeAmm } from './split-trade/splitTradeAmm';\nimport { getTwoPermutations } from '../utils/getTwoPermutations';\n\nexport interface TransactionFeeInfo {\n  signatureFee: number;\n  openOrdersDeposits: number[];\n  ataDeposit: number;\n  ataDepositLength: number;\n}\n\nexport interface RouteInfo {\n  marketInfos: MarketInfo[];\n  inAmount: number;\n  outAmount: number;\n  outAmountWithSlippage: number;\n  priceImpactPct: number;\n  getDepositAndFee: () => Promise<TransactionFeeInfo | undefined>;\n}\n\ntype MarketsCache = Array<\n  Omit<AccountInfo<Buffer>, 'data' | 'owner'> & {\n    data: [string, 'base64'];\n    owner: string;\n    pubkey: string;\n  }\n>;\n\ntype KeyedAccountInfo = AccountInfo<Buffer> & {\n  pubkey: PublicKey;\n  // api can pass some extra params\n  params?: any;\n};\n\nexport async function getAllAmms(connection: Connection, cluster: Cluster, marketUrl?: string): Promise<Amm[]> {\n  const marketsCache = (await (await fetch(marketUrl || MARKETS_URL[cluster])).json()) as MarketsCache;\n\n  const marketCacheToAccountInfo = (marketsCache: MarketsCache): Array<KeyedAccountInfo> => {\n    return marketsCache.map((market) => {\n      const {\n        data: [accountInfo, format],\n        pubkey,\n        ...rest\n      } = market;\n      return {\n        ...rest,\n        pubkey: new PublicKey(pubkey),\n        data: Buffer.from(accountInfo, format),\n        owner: new PublicKey(rest.owner),\n      };\n    });\n  };\n\n  // We add market accounts infos that do not come from the API yet\n  // TODO: Move to market cache\n  const tokenSwapPools = getTokenSwapPools(cluster);\n\n  const extraKeys = tokenSwapPools;\n  const extraMarketKeyedAccountInfos = (await connection.getMultipleAccountsInfo(extraKeys)).reduce(\n    (acc, accountInfo, index) => {\n      if (accountInfo) {\n        acc.push({\n          ...accountInfo,\n          pubkey: extraKeys[index],\n        });\n      }\n      return acc;\n    },\n    new Array<KeyedAccountInfo>(),\n  );\n\n  const marketKeyedAccountInfos = marketCacheToAccountInfo(marketsCache).concat(extraMarketKeyedAccountInfos);\n\n  const amms = marketKeyedAccountInfos.reduce((acc, keyedAccountInfo) => {\n    const amm = ammFactory(keyedAccountInfo.pubkey, keyedAccountInfo, keyedAccountInfo.params);\n    // Amm might not be recognized by the current version of the frontend\n    // or be in a state we don't want\n    if (amm) {\n      acc.push(amm);\n    }\n    return acc;\n  }, new Array<Amm>());\n\n  const naturalAmms = amms.slice();\n  amms.push(...getSaberWrappedDecimalsAmms());\n\n  // Add the split trade Amms\n  // This is very inefficient and slow\n  ammCrossProtocolPairs(naturalAmms, (firstAmm, secondAmm) => {\n    const splitTradeAmm = SplitTradeAmm.create(firstAmm, secondAmm);\n    if (splitTradeAmm) {\n      amms.push(splitTradeAmm);\n    }\n  });\n\n  return amms;\n}\n\nfunction ammCrossProtocolPairs(arr: Amm[], func: (a: Amm, b: Amm) => void) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    for (let j = i; j < arr.length - 1; j++) {\n      // Don't pair amm with same label\n      if (arr[i].label !== arr[j].label) {\n        func(arr[i], arr[j + 1]);\n      }\n    }\n  }\n}\n\nexport function getTokenRouteSegments(amms: Amm[]): TokenRouteSegments {\n  const tokenRouteSegments = new Map<string, Map<string, MarketMeta[]>>();\n\n  amms.forEach((amm) => {\n    const reserveTokenMintPermutations = getTwoPermutations(amm.reserveTokenMints);\n    reserveTokenMintPermutations.forEach(([firstReserveMint, secondReserveMint]) => {\n      addSegment(firstReserveMint.toBase58(), secondReserveMint.toBase58(), amm, tokenRouteSegments);\n    });\n  });\n\n  return tokenRouteSegments;\n}\n\nfunction addSegment(inMint: string, outMint: string, amm: Amm, tokenRouteSegments: TokenRouteSegments) {\n  let segments = tokenRouteSegments.get(inMint);\n\n  if (!segments) {\n    segments = new Map<string, MarketMeta[]>([[outMint, []]]);\n    tokenRouteSegments.set(inMint, segments);\n  }\n\n  let marketMetas = segments.get(outMint);\n  if (!marketMetas) {\n    marketMetas = [];\n    segments.set(outMint, marketMetas);\n  }\n\n  marketMetas.push({ amm });\n}\n\nexport type Route = {\n  marketMetas: MarketMeta[];\n  intermediateMint?: PublicKey;\n};\n\nexport function computeRoutes(\n  inputMint: PublicKey,\n  outputMint: PublicKey,\n  tokenRouteSegments: TokenRouteSegments,\n): Route[] {\n  const routes: Route[] = [];\n  const firstSegment = tokenRouteSegments?.get(inputMint.toBase58());\n\n  const simpleRoutes = firstSegment?.get(outputMint.toBase58()) ?? [];\n\n  // Direct trade\n  simpleRoutes.forEach((simpleRoute) => {\n    // dont do direct decimal saber\n    if (!(simpleRoute.amm instanceof SaberAddDecimalsAmm)) {\n      routes.push({ marketMetas: [simpleRoute] });\n    }\n  });\n\n  const secondSegment = tokenRouteSegments?.get(outputMint.toBase58());\n\n  for (const [mint, marketMetas] of firstSegment?.entries() ?? []) {\n    const intersectionMarketMetas = secondSegment?.get(mint) ?? [];\n    for (const marketMeta of marketMetas) {\n      for (const intersectionMarketMeta of intersectionMarketMetas) {\n        if (isValidRoute(marketMeta.amm, intersectionMarketMeta.amm)) {\n          routes.push({\n            marketMetas: [marketMeta, intersectionMarketMeta],\n            intermediateMint: new PublicKey(mint),\n          });\n        }\n      }\n    }\n  }\n\n  return routes;\n}\n\nexport function computeRouteMap(tokenRouteSegments: TokenRouteSegments): Map<string, string[]> {\n  const routeMap = new Map<string, string[]>();\n\n  for (const [tokenMint, firstLevelOutputs] of tokenRouteSegments) {\n    const validOutputMints = new Set<string>();\n\n    for (const [firstLevelOutputMint, firstLevelMarketMetas] of firstLevelOutputs) {\n      validOutputMints.add(firstLevelOutputMint);\n\n      // add the single level output as possible valid mints as well\n      const secondLevelOutputs = tokenRouteSegments.get(firstLevelOutputMint) ?? [];\n      for (const [secondLevelOutputMint, secondLevelMarketMetas] of secondLevelOutputs) {\n        // Prevent output mint == input mint when routing\n        if (secondLevelOutputMint === tokenMint) {\n          continue;\n        }\n\n        for (const firstLevelMarketMeta of firstLevelMarketMetas) {\n          for (const secondLevelMarketMeta of secondLevelMarketMetas) {\n            if (isValidRoute(firstLevelMarketMeta.amm, secondLevelMarketMeta.amm)) {\n              validOutputMints.add(secondLevelOutputMint);\n              break;\n            }\n          }\n        }\n      }\n    }\n    routeMap.set(tokenMint, Array.from(validOutputMints));\n  }\n\n  return routeMap;\n}\n\nexport function isSplitSetupRequired(marketInfos: MarketInfo[]): boolean {\n  if (marketInfos.length === 1) {\n    const amm = marketInfos[0].marketMeta.amm;\n    if (amm instanceof SplitTradeAmm && amm.shouldSplitSetup) {\n      return true;\n    }\n  } else {\n    const [firstMarket, secondMarket] = marketInfos.map((marketInfo) => marketInfo.marketMeta.amm);\n\n    if (firstMarket instanceof RaydiumAmm || secondMarket instanceof RaydiumAmm) {\n      return true;\n    } else if (firstMarket instanceof SerumAmm && secondMarket instanceof SerumAmm) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function getNumberOfTransactionForRoute(marketInfos: MarketInfo[]): number {\n  if (isSplitSetupRequired(marketInfos)) {\n    const [firstMarketInfo, secondMarketInfo] = marketInfos;\n\n    const hasSOL = [(firstMarketInfo.inputMint, firstMarketInfo.outputMint, secondMarketInfo.outputMint)].some((item) =>\n      item.equals(WRAPPED_SOL_MINT),\n    );\n\n    return hasSOL ? 3 : 2;\n  }\n  return 1;\n}\n\n// We cannot add platform fee to all possible routing due to transaction size limit\nexport function isPlatformFeeSupported(marketInfos: MarketMeta[]): boolean {\n  if (marketInfos.length > 1) {\n    const [firstMarket, secondMarket] = marketInfos.map((marketInfo) => marketInfo.amm);\n\n    if (firstMarket instanceof RaydiumAmm && secondMarket instanceof RaydiumAmm) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function getRouteInfoUniqueId(routeInfo: RouteInfo) {\n  return routeInfo.marketInfos.map((marketInfo) => `${marketInfo.marketMeta.amm.id}-${marketInfo.inputMint}`).join('-');\n}\n","import { InstructionCache } from './types';\nimport { RouteInfo } from './routes';\nimport { SetupInstructions } from '..';\n\nexport const getCacheMintKey = (marketInfos: RouteInfo['marketInfos']) => {\n  return `${marketInfos[0]?.inputMint}-${marketInfos[0]?.outputMint}-${marketInfos[1]?.outputMint}-${marketInfos.map(\n    (item) => item.marketMeta.amm.id,\n  )}`;\n};\n\nexport const getInstructionCache = ({\n  instructionCache,\n  walletPublicKey,\n  cacheKey,\n}: {\n  instructionCache: InstructionCache;\n  walletPublicKey: string;\n  cacheKey: string;\n}) => {\n  return instructionCache.get(walletPublicKey)?.get(cacheKey);\n};\n\nexport const setInstructionCache = ({\n  instructionCache,\n  instructionResult,\n  walletPublicKey,\n  cacheKey,\n}: {\n  instructionCache: InstructionCache;\n  instructionResult: SetupInstructions;\n  walletPublicKey: string;\n  cacheKey: string;\n}) => {\n  const walletCache =\n    instructionCache.get(walletPublicKey) || (new Map() as NonNullable<ReturnType<InstructionCache['get']>>);\n\n  walletCache.set(cacheKey, instructionResult);\n\n  instructionCache.set(walletPublicKey, walletCache);\n};\n\nexport const deleteInstructionCache = ({\n  instructionCache,\n  walletPublicKey,\n}: {\n  instructionCache: InstructionCache;\n  walletPublicKey: string;\n}) => {\n  instructionCache.get(walletPublicKey)?.clear();\n};\n","import { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { Connection, PublicKey, SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { WRAPPED_SOL_MINT } from '../constants';\nimport { getEmptyInstruction, Instruction } from './instruction';\n\n// Leverage the existing ATA when present\nexport async function createAndCloseWSOLAccount(\n  connection: Connection,\n  owner: PublicKey,\n  amount: number,\n): Promise<Instruction & { address: PublicKey }> {\n  const result = getEmptyInstruction();\n  result.instructions = [];\n\n  const toAccount = await Token.getAssociatedTokenAddress(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    WRAPPED_SOL_MINT,\n    owner,\n  );\n\n  const info = await connection.getAccountInfo(toAccount);\n\n  if (info === null) {\n    result.instructions.push(\n      Token.createAssociatedTokenAccountInstruction(\n        ASSOCIATED_TOKEN_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        WRAPPED_SOL_MINT,\n        toAccount,\n        owner,\n        owner,\n      ),\n    );\n  }\n\n  // Fund account and sync\n  result.instructions.push(\n    SystemProgram.transfer({\n      fromPubkey: owner,\n      toPubkey: toAccount,\n      lamports: amount,\n    }),\n  );\n  result.instructions.push(\n    // This is not exposed by the types, but indeed it exists\n    (Token as any).createSyncNativeInstruction(TOKEN_PROGRAM_ID, toAccount),\n  );\n\n  result.cleanupInstructions = [Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, toAccount, owner, owner, [])];\n\n  return {\n    address: toAccount,\n    ...result,\n  };\n}\n\nexport async function findOrCreateAssociatedAccountByMint(\n  connection: Connection,\n  payer: PublicKey,\n  owner: PublicKey,\n  mintAddress: PublicKey | string,\n  unwrapSOL: boolean,\n): Promise<Instruction & { address: PublicKey }> {\n  const mint = typeof mintAddress === 'string' ? new PublicKey(mintAddress) : mintAddress;\n  const toAccount = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint, owner);\n  const cleanupInstructions: TransactionInstruction[] = [];\n  const instructions: TransactionInstruction[] = [];\n\n  const info = await connection.getAccountInfo(toAccount);\n  if (info === null) {\n    instructions.push(\n      Token.createAssociatedTokenAccountInstruction(\n        ASSOCIATED_TOKEN_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        mint,\n        toAccount,\n        owner,\n        payer,\n      ),\n    );\n  }\n\n  // We close it when wrapped SOL\n  if (mint.equals(WRAPPED_SOL_MINT) && unwrapSOL) {\n    cleanupInstructions.push(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, toAccount, owner, owner, []));\n  }\n\n  return {\n    address: toAccount,\n    instructions: instructions,\n    cleanupInstructions,\n    signers: [],\n  };\n}\n","import { Connection, PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { isPlatformFeeSupported, RouteInfo } from './routes';\nimport { getEmptyInstruction, Instruction } from '../utils/instruction';\nimport { findOrCreateAssociatedAccountByMint } from '../utils/token';\nimport { createSetTokenLedgerInstruction } from './jupiterInstruction';\nimport { Owner } from '../utils/Owner';\nimport { PlatformFee } from './types';\nimport { QuoteMintToReferrer } from '..';\n\nasync function routeToInstructions(\n  user: Owner,\n  openOrdersAddresses: (PublicKey | undefined)[],\n  userSourceTokenAccountAddress: PublicKey,\n  userIntermediaryTokenAccountAddress: PublicKey | undefined,\n  userDestinationTokenAccountAddress: PublicKey,\n  routeInfo: RouteInfo,\n  platformFee: PlatformFee | undefined,\n  quoteMintToReferrer: QuoteMintToReferrer,\n): Promise<Instruction> {\n  const outAmountWithSlippage = routeInfo.outAmountWithSlippage;\n  const inputAmount = routeInfo.inAmount;\n\n  const legs = routeInfo.marketInfos.length;\n  if (legs == 2 && !userIntermediaryTokenAccountAddress) {\n    throw new Error('Missing intermediary token account');\n  }\n\n  const userTokenAccountAddresses =\n    legs === 1\n      ? [userSourceTokenAccountAddress, userDestinationTokenAccountAddress]\n      : [userSourceTokenAccountAddress, userIntermediaryTokenAccountAddress!, userDestinationTokenAccountAddress];\n\n  let instructions: TransactionInstruction[] = [];\n\n  const platformFeeSupported = isPlatformFeeSupported(routeInfo.marketInfos.map((mi) => mi.marketMeta));\n\n  if (legs > 1) {\n    instructions.push(createSetTokenLedgerInstruction(userIntermediaryTokenAccountAddress!));\n  }\n\n  for (const [index, marketInfo] of routeInfo.marketInfos.entries()) {\n    const amm = marketInfo.marketMeta.amm;\n    const legInputAmount = index === 0 ? inputAmount : null;\n    const legOutAmountWithSlippage = index === legs - 1 ? outAmountWithSlippage : 0;\n    const legPlatformFee = index === legs - 1 && platformFeeSupported ? platformFee : undefined;\n\n    const [source, destination] = userTokenAccountAddresses.slice(index);\n\n    instructions.push(\n      ...amm.createSwapInstructions({\n        sourceMint: marketInfo.inputMint,\n        destinationMint: marketInfo.outputMint,\n        sourceTokenAccount: source,\n        destinationTokenAccount: destination,\n        userTransferAuthority: user.publicKey,\n        amount: legInputAmount,\n        minimumOutAmount: legOutAmountWithSlippage,\n        openOrdersAddress: openOrdersAddresses[index],\n        platformFee: legPlatformFee,\n        quoteMintToReferrer,\n      }),\n    );\n  }\n\n  const { signers, cleanupInstructions } = getEmptyInstruction();\n\n  if (user.isKeyPair && user.signer) {\n    signers.push(user.signer);\n  }\n  return {\n    signers,\n    cleanupInstructions,\n    instructions,\n  };\n}\n\nexport const routeAtaInstructions = async (\n  connection: Connection,\n  marketInfos: RouteInfo['marketInfos'],\n  userPublicKey: PublicKey,\n  unwrapSOL: boolean,\n) => {\n  const getUserIntermediateTokenAccountAddress = async () => {\n    const userIntermediateTokenAccountAddress =\n      marketInfos.length === 2\n        ? await findOrCreateAssociatedAccountByMint(\n            connection,\n            userPublicKey,\n            userPublicKey,\n            marketInfos[0].outputMint,\n            unwrapSOL,\n          )\n        : undefined;\n    return userIntermediateTokenAccountAddress;\n  };\n\n  const getUserDestinationTokenAccountAddress = async () => {\n    return await findOrCreateAssociatedAccountByMint(\n      connection,\n      userPublicKey,\n      userPublicKey,\n      marketInfos.length === 2 ? marketInfos[1].outputMint : marketInfos[0].outputMint,\n      unwrapSOL,\n    );\n  };\n\n  const [userIntermediaryTokenAccountResult, userDestinationTokenAccountResult] = await Promise.all([\n    getUserIntermediateTokenAccountAddress(),\n    getUserDestinationTokenAccountAddress(),\n  ]);\n\n  return {\n    userIntermediaryTokenAccountResult,\n    userDestinationTokenAccountResult,\n  };\n};\n\nexport default routeToInstructions;\n","import { Connection, PublicKey } from '@solana/web3.js';\nimport { SerumMarket } from '../market';\nimport { getEmptyInstruction, Instruction } from '../../utils/instruction';\nimport { wait } from '../../utils/wait';\nimport { createOpenOrdersInstruction } from '../jupiterInstruction';\n\nexport type MarketToOpenOrdersAddress = Map<string, PublicKey>;\n\nexport async function getOrCreateOpenOrdersAddress(\n  connection: Connection,\n  user: PublicKey,\n  serumMarket: SerumMarket,\n  marketToOpenOrdersAddress?: MarketToOpenOrdersAddress,\n): Promise<(Instruction & { address: PublicKey }) | undefined> {\n  const result = getEmptyInstruction();\n\n  const marketAddress = serumMarket.address.toString();\n\n  if (marketToOpenOrdersAddress) {\n    // check existing map\n    let openOrdersAddress = marketToOpenOrdersAddress.get(marketAddress);\n\n    if (openOrdersAddress) {\n      let openOrdersAccountInfo = null;\n\n      // We verify if it indeed exists, with low commitment to pick it up, to address the unsafe behaviour below\n      openOrdersAccountInfo = await connection.getAccountInfo(openOrdersAddress, 'processed');\n\n      if (openOrdersAccountInfo) {\n        return {\n          ...result,\n          address: openOrdersAddress,\n        };\n      }\n    }\n  }\n\n  const [newOpenOrdersAddress, ix] = createOpenOrdersInstruction(serumMarket, user);\n\n  const newOpenOrdersAddressInfo = await connection.getAccountInfo(newOpenOrdersAddress);\n\n  if (!newOpenOrdersAddressInfo) {\n    result.instructions = [ix];\n  }\n\n  // This is unsafe, since we don't know yet if it has succeeded\n  marketToOpenOrdersAddress?.set(serumMarket.address.toString(), newOpenOrdersAddress);\n\n  return {\n    ...result,\n    address: newOpenOrdersAddress,\n  };\n}\n","import { Signer, Transaction, TransactionInstruction, TransactionSignature } from '@solana/web3.js';\n\nexport const getEmptyInstruction: () => Instruction = () => ({\n  instructions: [],\n  cleanupInstructions: [],\n  signers: [],\n});\n\nexport type Instruction = {\n  instructions: TransactionInstruction[];\n  cleanupInstructions: TransactionInstruction[];\n  signers: Signer[];\n};\n\nexport type TransactionPayload = {\n  transaction: Transaction;\n  signers: Signer[];\n  execute: () => Promise<TransactionSignature>;\n};\n","import { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { Connection, FeeCalculator, PublicKey } from '@solana/web3.js';\nimport type { SerumOpenOrdersMap } from '..';\nimport { deserializeAccount } from '../utils/deserializeAccount';\nimport { getCacheMintKey, getInstructionCache, setInstructionCache } from './cache';\nimport { RouteInfo, TransactionFeeInfo } from './routes';\nimport { routeAtaInstructions } from './routeToInstructions';\nimport { getOrCreateOpenOrdersAddress } from './serum/openOrders';\nimport { SerumAmm } from './serum/serumAmm';\nimport { SplitTradeAmm } from './split-trade/splitTradeAmm';\nimport { InstructionCache, PlatformFeeAndAccounts, SetupInstructions } from './types';\n\nconst calculateTransactionDepositAndFee = ({\n  intermediate,\n  destination,\n  openOrders,\n  feeCalculator,\n}: SetupInstructions & {\n  feeCalculator: FeeCalculator;\n}): TransactionFeeInfo => {\n  const SERUM_OPEN_ACCOUNT_LAMPORTS = 23352760;\n  const OPEN_TOKEN_ACCOUNT_LAMPORTS = 2039280;\n  const openOrdersDeposits = openOrders\n    .filter((ooi) => ooi && ooi.instructions.length > 0)\n    .map(() => SERUM_OPEN_ACCOUNT_LAMPORTS);\n  const ataDepositLength = [destination, intermediate].filter(\n    (item) => item?.instructions.length && item.cleanupInstructions.length === 0,\n  ).length;\n  const ataDeposit = ataDepositLength * OPEN_TOKEN_ACCOUNT_LAMPORTS;\n\n  return {\n    signatureFee:\n      ([destination.signers, intermediate?.signers, openOrders?.some((oo) => oo?.signers)].filter(Boolean).flat()\n        .length +\n        1) *\n      feeCalculator.lamportsPerSignature,\n    openOrdersDeposits,\n    ataDeposit,\n    ataDepositLength: ataDepositLength,\n  };\n};\n\nexport const getDepositAndFeeFromInstructions = async ({\n  connection,\n  marketInfos,\n  userPublicKey,\n  feeCalculator,\n  instructionCache,\n  serumOpenOrdersPromise,\n  unwrapSOL,\n}: {\n  connection: Connection;\n  userPublicKey: PublicKey;\n  feeCalculator: FeeCalculator;\n  marketInfos: RouteInfo['marketInfos'];\n  instructionCache: InstructionCache;\n  /* promise because we can choose not to await it when we dont need it */\n  serumOpenOrdersPromise: Promise<SerumOpenOrdersMap>;\n  unwrapSOL: boolean;\n}) => {\n  const cacheKey = getCacheMintKey(marketInfos);\n\n  const walletPublicKey = userPublicKey.toBase58();\n\n  const routeCache = getInstructionCache({\n    instructionCache,\n    walletPublicKey,\n    cacheKey,\n  });\n\n  if (routeCache) {\n    const { destination, intermediate, openOrders } = routeCache;\n    return calculateTransactionDepositAndFee({\n      intermediate,\n      destination,\n      openOrders,\n      feeCalculator,\n    });\n  }\n\n  const openOrdersInstructionsPromise = Promise.all(\n    marketInfos.map(async (marketInfo) => {\n      const amm = marketInfo.marketMeta.amm;\n      if (amm instanceof SerumAmm || amm instanceof SplitTradeAmm) {\n        if (!amm.market) return;\n        return await getOrCreateOpenOrdersAddress(connection, userPublicKey, amm.market, await serumOpenOrdersPromise);\n      }\n      return;\n    }),\n  );\n\n  const promise = routeAtaInstructions(connection, marketInfos, userPublicKey, unwrapSOL).then(\n    ({ userIntermediaryTokenAccountResult, userDestinationTokenAccountResult }) => {\n      return openOrdersInstructionsPromise.then((openOrdersInstructions) => ({\n        intermediate: userIntermediaryTokenAccountResult,\n        destination: userDestinationTokenAccountResult,\n        openOrders: openOrdersInstructions,\n      }));\n    },\n  );\n\n  const instructionResult = await promise;\n\n  setInstructionCache({\n    cacheKey,\n    instructionCache,\n    instructionResult,\n    walletPublicKey,\n  });\n\n  return calculateTransactionDepositAndFee({\n    ...instructionResult,\n    feeCalculator,\n  });\n};\n\nexport const NO_PLATFORM_FEE: PlatformFeeAndAccounts = {\n  feeBps: 0,\n  feeAccounts: new Map<string, PublicKey>(),\n};\n\nexport async function getPlatformFeeAccounts(\n  connection: Connection,\n  feeAccountOwner: PublicKey,\n): Promise<Map<string, PublicKey>> {\n  const tokenAccounts = (\n    await connection.getTokenAccountsByOwner(feeAccountOwner, {\n      programId: TOKEN_PROGRAM_ID,\n    })\n  ).value;\n\n  const feeAccounts = tokenAccounts.reduce((acc, tokenAccount) => {\n    const deserializedtokenAccount = deserializeAccount(tokenAccount.account.data);\n    if (deserializedtokenAccount) {\n      acc.set(deserializedtokenAccount.mint.toBase58(), tokenAccount.pubkey);\n    }\n    return acc;\n  }, new Map<string, PublicKey>());\n\n  return feeAccounts;\n}\n","import {\n  Connection,\n  PublicKey,\n  Transaction,\n  TransactionCtorFields,\n  Signer,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport { Instruction, TransactionPayload } from './instruction';\nimport { Owner } from './Owner';\n\nexport class TransactionBuilder {\n  private connection: Connection;\n  private feePayer: PublicKey;\n  private instructions: Instruction[];\n  private owner: Owner;\n\n  constructor(connection: Connection, feePayer: PublicKey, owner: Owner) {\n    this.connection = connection;\n    this.feePayer = feePayer;\n    this.instructions = [];\n    this.owner = owner;\n  }\n\n  addInstruction(instruction: Instruction): TransactionBuilder {\n    this.instructions.push(instruction);\n    return this;\n  }\n\n  async build(recentBlockHash?: string): Promise<TransactionPayload> {\n    if (!recentBlockHash) {\n      recentBlockHash = (await this.connection.getRecentBlockhash('singleGossip')).blockhash;\n    }\n\n    const txFields: TransactionCtorFields = {\n      recentBlockhash: recentBlockHash,\n      feePayer: this.feePayer,\n    };\n\n    let instructions: TransactionInstruction[] = [];\n    let cleanupInstructions: TransactionInstruction[] = [];\n    let signers: Signer[] = [];\n    this.instructions.forEach((curr) => {\n      instructions = instructions.concat(curr.instructions);\n      cleanupInstructions = cleanupInstructions.concat(curr.cleanupInstructions);\n      signers = signers.concat(curr.signers);\n    });\n\n    const transaction = new Transaction(txFields);\n    instructions.concat(cleanupInstructions).forEach((ix) => transaction.add(ix));\n    transaction.feePayer = this.feePayer;\n\n    return {\n      transaction: transaction,\n      signers: signers,\n      execute: this.owner.isKeyPair\n        ? () => {\n            return this.connection.sendTransaction(transaction, signers);\n          }\n        : async () => {\n            throw new Error('Please use a Keypair for the owner parameter to enable the execute function');\n          },\n    };\n  }\n}\n","import { Keypair, PublicKey, Signer } from '@solana/web3.js';\n\ntype _Owner = Keypair | PublicKey;\n\nexport class Owner {\n  private readonly _owner: _Owner;\n\n  constructor(owner: _Owner) {\n    this._owner = owner;\n  }\n\n  get publicKey(): PublicKey {\n    if (Owner.isKeyPair(this._owner)) {\n      return this._owner.publicKey;\n    }\n\n    return this._owner;\n  }\n\n  get signer(): Signer | undefined {\n    return Owner.isKeyPair(this._owner) ? this._owner : undefined;\n  }\n\n  get isKeyPair(): boolean {\n    return Owner.isKeyPair(this._owner);\n  }\n\n  get isPublicKey(): boolean {\n    return Owner.isPublicKey(this._owner);\n  }\n\n  static isKeyPair(owner: _Owner): owner is Keypair {\n    return (owner as Keypair).secretKey !== undefined;\n  }\n\n  static isPublicKey(owner: _Owner): owner is PublicKey {\n    return !Owner.isKeyPair(owner);\n  }\n}\n","export class TransactionError extends Error {\n  constructor(m: string) {\n    super(m);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, Error.prototype);\n  }\n\n  // transaction id\n  txid?: string;\n}\n","import {\n  ConfirmedTransactionMeta,\n  Connection,\n  PublicKey,\n  Transaction,\n  TransactionResponse,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport promiseRetry from 'promise-retry';\nimport { WRAPPED_SOL_MINT } from '../constants';\nimport { TransactionError } from '../lib/error';\n\nfunction diffTokenBalance(accountKeyIndex: number, meta: ConfirmedTransactionMeta): number | undefined {\n  const postBalance = meta.postTokenBalances?.find(\n    (postTokenBalance) => postTokenBalance.accountIndex === accountKeyIndex,\n  )?.uiTokenAmount.amount;\n  const preBalance = meta.preTokenBalances?.find((preTokenBalance) => preTokenBalance.accountIndex === accountKeyIndex)\n    ?.uiTokenAmount.amount;\n\n  // When token account is created it isn't present in preBalance\n  if (!postBalance) return;\n  return Math.abs(parseInt(postBalance) - (preBalance !== undefined ? parseInt(preBalance) : 0));\n}\n\nexport function extractTokenBalanceChangeFromTransaction(\n  transactionResult: TransactionResponse,\n  tokenAccountAddress: PublicKey,\n): number | undefined {\n  const message = transactionResult.transaction.message;\n  const meta = transactionResult.meta;\n  if (!meta) {\n    return;\n  }\n  const index = message.accountKeys.findIndex((p) => p.equals(tokenAccountAddress));\n\n  return diffTokenBalance(index, meta);\n}\n\nexport function extractWrappedSOLChangeFromTransaction(transactionResult: TransactionResponse): number | undefined {\n  const meta = transactionResult.meta;\n  if (!meta) {\n    return;\n  }\n  const index = meta.preTokenBalances?.find(\n    (preTokenBalance) => preTokenBalance.mint === WRAPPED_SOL_MINT.toString(),\n  )?.accountIndex;\n\n  if (!index) return;\n\n  return diffTokenBalance(index, meta);\n}\n\nexport function extractSOLChangeFromTransaction(transactionResult: TransactionResponse): number | undefined {\n  const meta = transactionResult.meta;\n  if (!meta) {\n    return;\n  }\n  const index = meta.postTokenBalances?.find(\n    (postTokenBalance) => postTokenBalance.mint === WRAPPED_SOL_MINT.toString(),\n  )?.accountIndex;\n\n  if (!index) return;\n\n  return diffTokenBalance(index, meta);\n}\n\nexport function getWritableKeys(transaction: Transaction) {\n  return [\n    ...new Set(\n      transaction.instructions\n        .map((inst) => inst.keys.filter((key) => key.isWritable).map((k) => k.pubkey))\n        .reduce((acc, el) => acc.concat(el)),\n    ).values(),\n  ];\n}\n\nexport function getTokenBalanceChangesFromTransactionResponse(\n  inputMint: PublicKey,\n  outputMint: PublicKey,\n  sourceAddress: PublicKey,\n  destinationAddress: PublicKey,\n  transactionResponse: TransactionResponse | null,\n) {\n  let sourceTokenBalanceChange: number | undefined;\n  let destinationTokenBalanceChange: number | undefined;\n\n  if (transactionResponse) {\n    sourceTokenBalanceChange =\n      inputMint.toBase58() === WRAPPED_SOL_MINT.toString()\n        ? extractWrappedSOLChangeFromTransaction(transactionResponse)\n        : extractTokenBalanceChangeFromTransaction(transactionResponse, sourceAddress);\n    destinationTokenBalanceChange =\n      outputMint.toBase58() === WRAPPED_SOL_MINT.toString()\n        ? extractSOLChangeFromTransaction(transactionResponse)\n        : extractTokenBalanceChangeFromTransaction(transactionResponse, destinationAddress);\n  }\n\n  if (!(sourceTokenBalanceChange && destinationTokenBalanceChange)) {\n    throw new Error('Cannot find source or destination token account balance change');\n  }\n\n  return [sourceTokenBalanceChange, destinationTokenBalanceChange];\n}\n\nexport function getConfirmTransaction(connection: Connection, txid: TransactionSignature) {\n  return promiseRetry(\n    async (retry) => {\n      const txResult = await connection.getTransaction(txid, {\n        commitment: 'confirmed',\n      });\n      if (!txResult) {\n        const error = new TransactionError('Transaction was not confirmed');\n        error.txid = txid;\n\n        retry(error);\n        return txResult;\n      }\n      return txResult;\n    },\n    {\n      retries: 30,\n      minTimeout: 500,\n    },\n  );\n}\n","import { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport {\n  AccountInfo,\n  Cluster,\n  Connection,\n  FeeCalculator,\n  Keypair,\n  PublicKey,\n  Transaction,\n  TransactionResponse,\n  TransactionSignature,\n} from '@solana/web3.js';\n\nimport { OpenOrders } from '@project-serum/serum';\nimport {\n  computeRouteMap,\n  computeRoutes,\n  getAllAmms,\n  getTokenRouteSegments,\n  isSplitSetupRequired,\n  RouteInfo,\n} from './routes';\nimport { MarketInfo } from './market';\nimport { DEVNET_SERUM_DEX_PROGRAM, JUPITER_WALLET, MAINNET_SERUM_DEX_PROGRAM, WRAPPED_SOL_MINT } from '../constants';\nimport { getDepositAndFeeFromInstructions, NO_PLATFORM_FEE } from './fee';\nimport { deleteInstructionCache, getCacheMintKey, getInstructionCache } from './cache';\nimport routeToInstructions, { routeAtaInstructions } from './routeToInstructions';\nimport { getOrCreateOpenOrdersAddress } from './serum/openOrders';\nimport { createAndCloseWSOLAccount } from '../utils/token';\nimport { getEmptyInstruction } from '../utils/instruction';\nimport { TransactionBuilder } from '../utils/TransactionBuilder';\nimport { Owner } from '../utils/Owner';\nimport { getConfirmTransaction, getTokenBalanceChangesFromTransactionResponse } from '../utils/transactionHelpers';\nimport {\n  createCreateTokenLedgerInstruction,\n  createOpenOrdersInstruction,\n  createRaydiumSwapInstruction,\n  createMercurialExchangeInstruction,\n  createSerumSwapInstruction,\n  createSetTokenLedgerInstruction,\n} from './jupiterInstruction';\nimport { fetchRoutes, computeRouteInfos } from './computeRouteInfos';\nimport type { SignerWalletAdapter } from '@solana/wallet-adapter-base';\nimport { TransactionError } from './error';\nimport { InstructionCache, TokenRouteSegments, PlatformFeeAndAccounts, QuoteMintToReferrer } from './types';\nimport { SerumAmm } from './serum/serumAmm';\nimport { SaberAmm } from './saber/saberAmm';\nimport { SplTokenSwapAmm } from './spl-token-swap/splTokenSwapAmm';\nimport { MercurialAmm } from './mercurial/mercurialAmm';\nimport { AldrinAmm } from './aldrin/aldrinAmm';\nimport { RaydiumAmm } from './raydium/raydiumAmm';\nimport { CropperAmm } from './cropper/cropperAmm';\nimport { SenchaAmm } from './sencha/senchaAmm';\nimport { SplitTradeAmm } from './split-trade/splitTradeAmm';\nimport { TokenMintAddress } from './types';\nimport { getPlatformFeeAccounts } from './fee';\n\nexport type SerumOpenOrdersMap = Map<string, PublicKey>;\nexport { MarketInfo } from './market';\nexport { getPlatformFeeAccounts } from './fee';\nexport * from './types';\nexport { RouteInfo, TransactionFeeInfo, getRouteInfoUniqueId } from './routes';\nexport { AldrinAmm, RaydiumAmm, SerumAmm, SaberAmm, SplTokenSwapAmm, MercurialAmm, CropperAmm, SenchaAmm };\n\nexport type SwapResult =\n  | {\n      txid: string;\n      inputAddress: PublicKey;\n      outputAddress: PublicKey;\n      inputAmount: number | undefined;\n      outputAmount: number | undefined;\n    }\n  | {\n      error?: TransactionError;\n    };\n\ntype InputMintAndOutputMint = string;\n\ntype JupiterLoadArgs = {\n  connection: Connection;\n  cluster: Cluster;\n  user?: PublicKey | Keypair;\n  platformFeeAndAccounts?: PlatformFeeAndAccounts;\n  quoteMintToReferrer?: Map<TokenMintAddress, PublicKey>;\n  routeCacheDuration?: number;\n  wrapUnwrapSOL?: boolean;\n  marketUrl?: string;\n};\n\nexport class Jupiter {\n  /* promise because we can choose not to await it when we dont need it */\n  private serumOpenOrdersPromise: Promise<SerumOpenOrdersMap> | undefined = undefined;\n  private instructionCache: InstructionCache = new Map();\n  private user: Keypair | PublicKey | undefined;\n  private routeCache = new Map<InputMintAndOutputMint, { fetchTimestamp: number }>();\n\n  constructor(\n    private connection: Connection,\n    private cluster: Cluster,\n    public tokenRouteSegments: TokenRouteSegments,\n    private feeCalculator: FeeCalculator,\n    private platformFeeAndAccounts: PlatformFeeAndAccounts,\n    /** Referrer account to collect Serum referrer fees for each given quote mint, the referrer fee is 20% of the Serum protocol fee */\n    private quoteMintToReferrer: QuoteMintToReferrer,\n    /** route cache duration in ms */\n    private routeCacheDuration: number = 0,\n    /** When set to true (default) native SOL is wrapped and wSOL unwrapped in each swap, otherwise it assumes wSOL is funded when it exists */\n    private wrapUnwrapSOL: boolean = true,\n  ) {}\n\n  /**\n   * load performs the necessary async scaffolding of the Jupiter object\n   */\n  static async load({\n    connection,\n    cluster,\n    user,\n    platformFeeAndAccounts = NO_PLATFORM_FEE,\n    quoteMintToReferrer,\n    routeCacheDuration = 0,\n    wrapUnwrapSOL = true,\n    // @internal,\n    marketUrl,\n  }: JupiterLoadArgs) {\n    const [\n      tokenRouteSegments,\n      {\n        value: { feeCalculator },\n      },\n      defaultQuoteMintToReferrer,\n    ] = await Promise.all([\n      Jupiter.fetchTokenRouteSegments(connection, cluster, marketUrl),\n      connection.getRecentBlockhashAndContext('processed'),\n      getPlatformFeeAccounts(connection, new PublicKey(JUPITER_WALLET)),\n    ]);\n\n    const jupiter = new Jupiter(\n      connection,\n      cluster,\n      tokenRouteSegments,\n      feeCalculator,\n      platformFeeAndAccounts,\n      quoteMintToReferrer || defaultQuoteMintToReferrer,\n      routeCacheDuration,\n      wrapUnwrapSOL,\n    );\n    if (user) jupiter.setUserPublicKey(user);\n    return jupiter;\n  }\n\n  getPublicKeysToUpdate() {\n    const publicKeys = new Set<string>();\n    this.tokenRouteSegments.forEach((tokenRouteSegment) => {\n      Array.from(tokenRouteSegment.values()).forEach((marketInfos) => {\n        marketInfos.forEach(({ amm }) => {\n          amm.getAccountsForUpdate().forEach((account) => {\n            publicKeys.add(account.toBase58());\n          });\n        });\n      });\n    });\n\n    return Array.from(publicKeys);\n  }\n\n  async computeRoutes(\n    inputMint: PublicKey,\n    outputMint: PublicKey,\n    inputAmount: number,\n    slippage: number,\n    shouldFetchRoutes: boolean = false,\n    /* external accountInfosMap that allow external fetching  */\n    externalAccountInfosMap?: Map<string, AccountInfo<Buffer>>,\n    feeBps: number = 0,\n  ) {\n    const getDepositAndFees = async (marketInfos: MarketInfo[]) => {\n      if (this.user && this.serumOpenOrdersPromise) {\n        const owner = new Owner(this.user);\n        return getDepositAndFeeFromInstructions({\n          connection: this.connection,\n          feeCalculator: this.feeCalculator!,\n          instructionCache: this.instructionCache,\n          marketInfos: marketInfos,\n          serumOpenOrdersPromise: this.serumOpenOrdersPromise,\n          userPublicKey: owner.publicKey,\n          unwrapSOL: this.wrapUnwrapSOL,\n        });\n      }\n    };\n\n    // Platform fee can only be applied when fee account exists\n    const platformFeeBps =\n      feeBps ||\n      (this.platformFeeAndAccounts.feeAccounts.get(outputMint.toBase58()) ? this.platformFeeAndAccounts.feeBps : 0);\n\n    const now = new Date().getTime();\n\n    // do sort so that it's always the same order for the same inputMint and outputMint and vice versa\n    const inputMintAndOutputMint = [inputMint.toBase58(), outputMint.toBase58()]\n      .sort((a, b) => a.localeCompare(b))\n      .join('');\n\n    const routeCache = this.routeCache.get(inputMintAndOutputMint);\n\n    const routes = computeRoutes(inputMint, outputMint, this.tokenRouteSegments);\n\n    if (routeCache) {\n      const { fetchTimestamp } = routeCache;\n      if (now - fetchTimestamp > this.routeCacheDuration) {\n        shouldFetchRoutes = true;\n      }\n    } else {\n      shouldFetchRoutes = true;\n    }\n\n    if (shouldFetchRoutes) {\n      await fetchRoutes(this.connection, routes, externalAccountInfosMap);\n\n      this.routeCache.set(inputMintAndOutputMint, {\n        fetchTimestamp: new Date().getTime(),\n      });\n    }\n\n    try {\n      const routesInfos = computeRouteInfos({\n        routes,\n        amount: inputAmount,\n        inputMint,\n        outputMint,\n        getDepositAndFeeForRoute: getDepositAndFees,\n        slippage,\n        platformFeeBps,\n      });\n      return {\n        routesInfos,\n        /* indicate if the result is fetched or get from cache */\n        cached: !shouldFetchRoutes,\n      };\n    } catch (e) {\n      throw e;\n    } finally {\n      // clear cache if it is expired\n      this.routeCache.forEach(({ fetchTimestamp }, key) => {\n        if (fetchTimestamp - now > this.routeCacheDuration) {\n          this.routeCache.delete(key);\n        }\n      });\n    }\n  }\n\n  setUserPublicKey(userPublicKey: Keypair | PublicKey) {\n    this.user = userPublicKey;\n    const owner = new Owner(this.user);\n    this.serumOpenOrdersPromise = Jupiter.findSerumOpenOrdersForOwner({\n      connection: this.connection,\n      cluster: this.cluster,\n      userPublicKey: owner.publicKey,\n    });\n  }\n\n  /**\n   * The token route segments contains all the routes and the market meta information.\n   */\n  static async fetchTokenRouteSegments(connection: Connection, cluster: Cluster, marketUrl?: string) {\n    const amms = await getAllAmms(connection, cluster, marketUrl);\n\n    const tokenRouteSegments = getTokenRouteSegments(amms);\n\n    return tokenRouteSegments;\n  }\n\n  /**\n   * This generate a routeMap which represents every possible output token mint for a given input token mint.\n   * For example, we have SOL to USDC and this pairs have many routings like\n   * SOL => USDT\n   * USDT => USDC\n   * SOL => USDC\n   *\n   * From here we know that we can have 2 different routing of SOL => USDC.\n   * We do single level routing map but for all coins which result in the route map below:\n   * SOL => USDT, USDC\n   * USDT => SOL\n   * USDC => SOL, USDT\n   *\n   * From this route map we can map out all possible route from one to another by checking the intersection.\n   */\n  getRouteMap() {\n    return computeRouteMap(this.tokenRouteSegments);\n  }\n\n  /**\n   * Query existing open order account, this query is slow.\n   * We suggest to fetch this in the background.\n   */\n  static findSerumOpenOrdersForOwner = async ({\n    userPublicKey,\n    cluster,\n    connection,\n  }: {\n    userPublicKey: PublicKey;\n    cluster: Cluster;\n    connection: Connection;\n  }) => {\n    const newMarketToOpenOrdersAddress: SerumOpenOrdersMap = new Map();\n\n    if (userPublicKey) {\n      const programId = cluster === 'mainnet-beta' ? MAINNET_SERUM_DEX_PROGRAM : DEVNET_SERUM_DEX_PROGRAM;\n\n      const allOpenOrders = await OpenOrders.findForOwner(connection, userPublicKey, programId);\n\n      allOpenOrders.forEach((openOrders) => {\n        newMarketToOpenOrdersAddress.set(openOrders.market.toString(), openOrders.address);\n      });\n    }\n    return newMarketToOpenOrdersAddress;\n  };\n\n  public exchange: (params: { route: RouteInfo; userPublicKey?: PublicKey; feeAccount?: PublicKey }) => Promise<{\n    transactions: {\n      setupTransaction?: Transaction;\n      swapTransaction: Transaction;\n      cleanupTransaction?: Transaction;\n    };\n    execute: (params?: {\n      wallet?: Pick<SignerWalletAdapter, 'sendTransaction' | 'signAllTransactions' | 'signTransaction'>;\n      confirmationWaiterFactory?: (txid: TransactionSignature, totalTxs: number) => Promise<TransactionResponse | null>;\n    }) => Promise<SwapResult>;\n  }> = async ({ route, userPublicKey, feeAccount }) => {\n    const { connection, serumOpenOrdersPromise } = this;\n    const user: PublicKey | Keypair | undefined = userPublicKey || this.user;\n    if (!user) {\n      throw new Error('user not found');\n    }\n\n    const owner = new Owner(user);\n\n    const lastMarketInfoIndex = route.marketInfos.length - 1;\n    const inputMint = route.marketInfos[0].inputMint;\n    const outputMint = route.marketInfos[lastMarketInfoIndex].outputMint;\n\n    const cacheKey = getCacheMintKey(route.marketInfos);\n\n    let instructions = getInstructionCache({\n      instructionCache: this.instructionCache,\n      walletPublicKey: owner.publicKey.toBase58(),\n      cacheKey,\n    });\n\n    if (!instructions) {\n      const [ataInstructions, openOrdersInstructions] = await Promise.all([\n        routeAtaInstructions(connection, route.marketInfos, owner.publicKey, this.wrapUnwrapSOL),\n        Promise.all(\n          route.marketInfos.map(async ({ marketMeta: { amm } }) => {\n            if (amm instanceof SerumAmm || amm instanceof SplitTradeAmm) {\n              if (!amm.market) return;\n              return await getOrCreateOpenOrdersAddress(\n                connection,\n                owner.publicKey,\n                amm.market,\n                await serumOpenOrdersPromise,\n              );\n            }\n            return;\n          }),\n        ),\n      ]);\n\n      instructions = {\n        intermediate: ataInstructions.userIntermediaryTokenAccountResult,\n        destination: ataInstructions.userDestinationTokenAccountResult,\n        openOrders: openOrdersInstructions,\n      };\n    }\n\n    const sourceInstruction =\n      inputMint.equals(WRAPPED_SOL_MINT) && this.wrapUnwrapSOL\n        ? await createAndCloseWSOLAccount(connection, owner.publicKey, route.inAmount)\n        : {\n            ...getEmptyInstruction(),\n            address: await Token.getAssociatedTokenAddress(\n              ASSOCIATED_TOKEN_PROGRAM_ID,\n              TOKEN_PROGRAM_ID,\n              inputMint,\n              owner.publicKey,\n            ),\n          };\n\n    // Construct platform fee\n    feeAccount = feeAccount || this.platformFeeAndAccounts.feeAccounts.get(outputMint.toBase58());\n\n    const platformFee = feeAccount\n      ? {\n          feeBps:\n            this.platformFeeAndAccounts.feeBps ||\n            Math.floor(route.marketInfos[lastMarketInfoIndex].platformFee.pct * 100),\n          feeAccount,\n        }\n      : undefined;\n\n    const preparedInstructions = await routeToInstructions(\n      owner,\n      instructions.openOrders.map((oo) => oo?.address),\n      sourceInstruction.address,\n      instructions.intermediate?.address,\n      instructions.destination.address,\n      route,\n      platformFee,\n      this.quoteMintToReferrer,\n    );\n\n    const splitSetupRequired = isSplitSetupRequired(route.marketInfos);\n\n    const setupTransactionBuilder = new TransactionBuilder(connection, owner.publicKey, owner);\n\n    const transactionBuilder = new TransactionBuilder(connection, owner.publicKey, owner);\n\n    const cleanupTransactionBuilder = new TransactionBuilder(connection, owner.publicKey, owner);\n\n    if (splitSetupRequired) {\n      if (instructions.openOrders) {\n        instructions.openOrders.forEach((openOrders) => {\n          if (openOrders) {\n            setupTransactionBuilder.addInstruction(openOrders);\n          }\n        });\n      }\n\n      if (instructions.intermediate) {\n        setupTransactionBuilder.addInstruction({\n          ...instructions.intermediate,\n          cleanupInstructions: [],\n        });\n      }\n\n      setupTransactionBuilder.addInstruction({\n        ...sourceInstruction,\n        cleanupInstructions: [],\n      });\n\n      cleanupTransactionBuilder\n        .addInstruction({\n          ...getEmptyInstruction(),\n          cleanupInstructions: sourceInstruction.cleanupInstructions,\n        })\n        .addInstruction({\n          ...getEmptyInstruction(),\n          cleanupInstructions: instructions.intermediate?.cleanupInstructions ?? [],\n        });\n\n      // if source address the same as destination address, then we don't need to setup or cleanup twice, mainly SOL-SOL\n      if (!sourceInstruction.address.equals(instructions.destination.address)) {\n        setupTransactionBuilder.addInstruction({\n          ...instructions.destination,\n          cleanupInstructions: [],\n        });\n\n        cleanupTransactionBuilder.addInstruction({\n          ...getEmptyInstruction(),\n          cleanupInstructions: instructions.destination.cleanupInstructions,\n        });\n      }\n    } else {\n      if (instructions.openOrders) {\n        instructions.openOrders.forEach((openOrders) => {\n          if (openOrders) {\n            transactionBuilder.addInstruction(openOrders);\n          }\n        });\n      }\n\n      if (instructions.intermediate) {\n        transactionBuilder.addInstruction(instructions.intermediate);\n      }\n\n      transactionBuilder.addInstruction(sourceInstruction);\n\n      // if source address the same as destination address, then we don't need to setup or cleanup twice, mainly SOL-SOL\n      if (!sourceInstruction.address.equals(instructions.destination.address)) {\n        transactionBuilder.addInstruction(instructions.destination);\n      }\n    }\n\n    transactionBuilder.addInstruction(preparedInstructions);\n\n    const recentBlockHash = (await this.connection.getRecentBlockhash('singleGossip')).blockhash;\n\n    const { transaction: setupTransaction } = await setupTransactionBuilder.build(recentBlockHash);\n\n    const { transaction } = await transactionBuilder.build(recentBlockHash);\n\n    const { transaction: cleanupTransaction } = await cleanupTransactionBuilder.build(recentBlockHash);\n\n    // Is this horrible? Yes.\n    const [setupTransactionObject, swapTransactionObject, cleanupTransactionObject] = ((): [\n      one: Transaction | undefined,\n      two: Transaction,\n      three: Transaction | undefined,\n    ] => {\n      if (setupTransaction.instructions.length && cleanupTransaction.instructions.length) {\n        return [setupTransaction, transaction, cleanupTransaction] as [\n          one: Transaction | undefined,\n          two: Transaction,\n          three: Transaction | undefined,\n        ];\n      } else if (setupTransaction.instructions.length) {\n        const [first, second] = [setupTransaction, transaction];\n\n        return [first, second, undefined];\n      } else if (cleanupTransaction.instructions.length) {\n        const [second, third] = [transaction, cleanupTransaction];\n\n        return [undefined, second, third];\n      } else {\n        return [undefined, transaction, undefined];\n      }\n    })();\n\n    return {\n      transactions: {\n        setupTransaction: setupTransactionObject,\n        swapTransaction: swapTransactionObject,\n        cleanupTransaction: cleanupTransactionObject,\n      },\n      execute: async ({\n        wallet,\n        confirmationWaiterFactory,\n      }: {\n        wallet?: Pick<SignerWalletAdapter, 'sendTransaction' | 'signAllTransactions' | 'signTransaction'>;\n        confirmationWaiterFactory?: (\n          txid: TransactionSignature,\n          totalTxs: number,\n        ) => Promise<TransactionResponse | null>;\n      } = {}) => {\n        let txid: TransactionSignature = '';\n        try {\n          const transactions = [setupTransactionObject, swapTransactionObject, cleanupTransactionObject].filter(\n            Boolean,\n          ) as Transaction[];\n\n          const totalTxs = transactions.length;\n\n          if (owner.isKeyPair && owner.signer) {\n            transactions.forEach((transaction) => {\n              transaction.sign(owner.signer!);\n            });\n          } else {\n            if (!wallet) {\n              throw new Error('Signer wallet not found');\n            }\n            if (totalTxs > 1) {\n              await wallet.signAllTransactions(transactions);\n            } else {\n              await wallet.signTransaction(transactions[0]);\n            }\n          }\n\n          let setupError;\n\n          if (setupTransactionObject) {\n            try {\n              const setupTxid = await connection.sendRawTransaction(setupTransactionObject.serialize(), {\n                skipPreflight: true,\n              });\n\n              if (confirmationWaiterFactory) {\n                await confirmationWaiterFactory(setupTxid, totalTxs);\n              } else {\n                await getConfirmTransaction(connection, setupTxid);\n              }\n            } catch (e) {\n              setupError = e;\n              throw setupError;\n            }\n          }\n\n          try {\n            const txid = await connection.sendRawTransaction(swapTransactionObject.serialize(), {\n              skipPreflight: true,\n            });\n\n            let transactionResponse: TransactionResponse | null = null;\n            if (confirmationWaiterFactory) {\n              transactionResponse = await confirmationWaiterFactory(txid, totalTxs);\n            }\n\n            if (!transactionResponse) {\n              transactionResponse = await getConfirmTransaction(connection, txid);\n            }\n\n            const [sourceTokenBalanceChange, destinationTokenBalanceChange] =\n              getTokenBalanceChangesFromTransactionResponse(\n                inputMint,\n                outputMint,\n                sourceInstruction.address,\n                instructions!.destination.address,\n                transactionResponse,\n              );\n\n            return {\n              txid,\n              inputAddress: sourceInstruction.address,\n              outputAddress: instructions!.destination.address,\n              inputAmount: sourceTokenBalanceChange,\n              outputAmount: destinationTokenBalanceChange,\n            };\n          } catch (e) {\n            throw e;\n          } finally {\n            if (cleanupTransactionObject && !setupError) {\n              const cleanupTxId = await connection.sendRawTransaction(cleanupTransactionObject.serialize(), {\n                skipPreflight: true,\n              });\n              await confirmationWaiterFactory?.(cleanupTxId, totalTxs);\n            }\n          }\n        } catch (e) {\n          const transactionError = e as TransactionError;\n          if (txid) {\n            transactionError.txid = txid;\n          }\n\n          return {\n            error: transactionError,\n          };\n        } finally {\n          const hasOpenOrders = instructions?.openOrders.some((oo) => oo?.instructions.length);\n          if (\n            hasOpenOrders ||\n            instructions?.intermediate?.instructions.length ||\n            instructions?.destination.instructions.length\n          ) {\n            deleteInstructionCache({\n              instructionCache: this.instructionCache,\n              walletPublicKey: owner.publicKey.toBase58(),\n            });\n          }\n          this.routeCache.clear();\n        }\n      },\n    };\n  };\n\n  static createCreateTokenLedgerInstruction = createCreateTokenLedgerInstruction;\n  static createOpenOrdersInstruction = createOpenOrdersInstruction;\n  static createRaydiumSwapInstruction = createRaydiumSwapInstruction;\n  static createMercurialExchangeInstruction = createMercurialExchangeInstruction;\n  static createSerumSwapInstruction = createSerumSwapInstruction;\n  static createSetTokenLedgerInstruction = createSetTokenLedgerInstruction;\n}\n","import { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport { chunkedGetMultipleAccountInfos } from '../utils/chunkedGetMultipleAccountInfos';\nimport { MarketInfo } from './market';\nimport { isPlatformFeeSupported, Route, RouteInfo, TransactionFeeInfo } from './routes';\n\nconst PLATFORM_FEE_DENOMINATOR = 10000;\n\nexport async function fetchRoutes(\n  connection: Connection,\n  routes: Route[],\n  extraAccountInfosMap?: Map<string, AccountInfo<Buffer>>,\n): Promise<Route[]> {\n  await routeBatchFetcher(connection, routes, extraAccountInfosMap);\n\n  return routes;\n}\n\ninterface GetQuotesParams {\n  routes: Route[];\n  amount: number;\n  inputMint: PublicKey;\n  outputMint: PublicKey;\n  platformFeeBps: number;\n  slippage: number;\n  getDepositAndFeeForRoute: (marketInfos: RouteInfo['marketInfos']) => Promise<TransactionFeeInfo | undefined>;\n}\n\nexport const computeRouteInfos = ({\n  routes,\n  amount,\n  inputMint,\n  outputMint,\n  platformFeeBps,\n  slippage,\n  getDepositAndFeeForRoute,\n}: GetQuotesParams) => {\n  const routesInfo: RouteInfo[] = routes\n    .map((route) => {\n      const { marketMetas, intermediateMint } = route;\n\n      // Chain all marketMetas\n      let marketInfos: MarketInfo[] = [];\n      let intermediateAmount = amount;\n      let outAmountWithSlippage = amount;\n      const platformFeeSupported = isPlatformFeeSupported(marketMetas);\n      const tokenMints: PublicKey[] = [inputMint, outputMint];\n      // TODO: Avoid this hack with a smarter data structure\n      if (intermediateMint) {\n        tokenMints.splice(1, 0, intermediateMint);\n      }\n\n      const legs = marketMetas.length;\n      for (const [i, marketMeta] of marketMetas.entries()) {\n        try {\n          const sourceMint = tokenMints[i];\n          const destinationMint = tokenMints[i + 1];\n          const quote = marketMeta.amm.getQuote({\n            sourceMint,\n            destinationMint,\n            amount: intermediateAmount,\n          });\n\n          // Platform fee applicable only on last leg\n          const platformFee =\n            legs - 1 === i && platformFeeSupported\n              ? {\n                  amount: Math.floor((quote.outAmount * platformFeeBps) / PLATFORM_FEE_DENOMINATOR),\n                  mint: destinationMint.toBase58(),\n                  pct: platformFeeBps / 100,\n                }\n              : { amount: 0, mint: destinationMint.toBase58(), pct: 0 };\n\n          const outAmountAfterFees = Math.max(0, quote.outAmount - platformFee.amount);\n\n          const legOutAmountWithSlippage = Math.round(outAmountAfterFees * (1 - slippage / 100));\n\n          marketInfos.push({\n            marketMeta,\n            inputMint: sourceMint,\n            outputMint: destinationMint,\n            notEnoughLiquidity: quote.notEnoughLiquidity,\n            minInAmount: quote.minInAmount,\n            minOutAmount: quote.minOutAmount,\n            inAmount: quote.inAmount,\n            outAmount: outAmountAfterFees,\n            priceImpactPct: quote.priceImpactPct,\n            lpFee: {\n              amount: quote.feeAmount,\n              mint: quote.feeMint,\n              pct: quote.feePct,\n            },\n            platformFee,\n          });\n\n          intermediateAmount = outAmountAfterFees;\n          outAmountWithSlippage = legOutAmountWithSlippage;\n        } catch (e: any) {\n          // we supress this error because it is not too critical and it's serum specific\n          if (e.message === 'Number can only safely store up to 53 bits') {\n            return undefined;\n          }\n          throw e;\n        }\n      }\n\n      return {\n        marketInfos,\n        getDepositAndFee: () => getDepositAndFeeForRoute(marketInfos),\n        inAmount: marketInfos[0].inAmount,\n        outAmount: intermediateAmount,\n        outAmountWithSlippage: outAmountWithSlippage,\n        priceImpactPct:\n          1 -\n          marketInfos.reduce((priceFactor, marketInfo) => {\n            priceFactor *= 1 - marketInfo.priceImpactPct;\n            return priceFactor;\n          }, 1),\n      };\n    })\n    .filter((item): item is RouteInfo => item !== undefined)\n    .sort((a, b) => b.outAmount - a.outAmount); // sort based on which one have better output\n\n  return routesInfo;\n};\n\nasync function routeBatchFetcher(\n  connection: Connection,\n  routes: Route[],\n  externalAccountInfosMap?: Map<string, AccountInfo<Buffer>>,\n) {\n  const hasExternalAccountInfosMap = Boolean(externalAccountInfosMap);\n  const accountInfosMap = externalAccountInfosMap || new Map();\n\n  // dont fetch if externalAccountInfosMap is given\n  if (!hasExternalAccountInfosMap) {\n    externalAccountInfosMap = new Map();\n    const accountsToFetchSet = new Set<string>();\n\n    routes.forEach(({ marketMetas }) => {\n      return marketMetas.forEach(({ amm }) => {\n        amm.getAccountsForUpdate().forEach((account) => {\n          // Only add accountInfos that is not in the Map\n          accountsToFetchSet.add(account.toBase58());\n        });\n      });\n    });\n\n    const accountsToFetch = Array.from(accountsToFetchSet);\n\n    if (accountsToFetch.length > 0) {\n      const accountInfos = await chunkedGetMultipleAccountInfos(\n        connection,\n        accountsToFetch.map((account) => new PublicKey(account)),\n      );\n\n      accountInfos.forEach((item, index) => {\n        const publicKey = accountsToFetch[index];\n        if (item) {\n          accountInfosMap.set(publicKey, item);\n        }\n      });\n    }\n  }\n\n  routes.forEach(({ marketMetas }) => {\n    marketMetas.forEach(({ amm }) => {\n      amm.update(accountInfosMap);\n    });\n  });\n}\n","import { Connection, PublicKey } from '@solana/web3.js';\nimport { chunks } from './chunks';\n\nexport async function chunkedGetMultipleAccountInfos(\n  connection: Connection,\n  pks: PublicKey[],\n  chunkSize: number = 100,\n) {\n  return (await Promise.all(chunks(pks, chunkSize).map((chunk) => connection.getMultipleAccountsInfo(chunk)))).flat();\n}\n","export function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply<number, T[], T[][]>(0, new Array(Math.ceil(array.length / size))).map((_, index) =>\n    array.slice(index * size, (index + 1) * size),\n  );\n}\n","import { AccountInfo, PublicKey } from '@solana/web3.js';\nimport {\n  ALDRIN_SWAP_V2_PROGRAM_ID,\n  ALDRIN_SWAP_PROGRAM_ID,\n  DEVNET_SERUM_DEX_PROGRAM,\n  MAINNET_SERUM_DEX_PROGRAM,\n  RAYDIUM_AMM_V4_PROGRAM_ID,\n  CROPPER_PROGRAM_ID,\n  SENCHA_PROGRAM_ID,\n  MERCURIAL_SWAP_PROGRAM_ID,\n} from '../constants';\nimport { Amm } from './amm';\nimport { SerumMarket, StableSwap } from './market';\nimport { SWAP_PROGRAM_ID as SABER_SWAP_PROGRAM_ID } from '@saberhq/stableswap-sdk';\nimport { SaberAmm } from './saber/saberAmm';\nimport { SerumAmm } from './serum/serumAmm';\nimport { findProgramAddressSync } from '@project-serum/anchor/dist/cjs/utils/pubkey';\nimport { AldrinAmm } from './aldrin/aldrinAmm';\nimport { PROGRAM_ID_TO_LABEL } from './spl-token-swap/splTokenSwapPools';\nimport { SplTokenSwapAmm } from './spl-token-swap/splTokenSwapAmm';\nimport { MercurialAmm } from './mercurial/mercurialAmm';\nimport { RaydiumAmm } from './raydium/raydiumAmm';\nimport { CropperAmm } from './cropper/cropperAmm';\nimport { SenchaAmm } from './sencha/senchaAmm';\n\nexport function ammFactory(address: PublicKey, accountInfo: AccountInfo<Buffer>, params?: any): Amm | undefined {\n  const programId = new PublicKey(accountInfo.owner);\n\n  if (programId.equals(MAINNET_SERUM_DEX_PROGRAM) || programId.equals(DEVNET_SERUM_DEX_PROGRAM)) {\n    const decoded = SerumMarket.getLayout(programId).decode(accountInfo.data);\n    if (!decoded.accountFlags.initialized || !decoded.accountFlags.market) {\n      throw new Error('Invalid market');\n    }\n    const serumMarket = new SerumMarket(decoded, 0, 0, {}, programId);\n    return new SerumAmm(serumMarket);\n  } else if (programId.equals(RAYDIUM_AMM_V4_PROGRAM_ID)) {\n    const raydiumAmm = new RaydiumAmm(address, accountInfo);\n    if (raydiumAmm.status === 1) {\n      return raydiumAmm;\n    }\n  } else if (programId.equals(MERCURIAL_SWAP_PROGRAM_ID)) {\n    return new MercurialAmm(address, accountInfo, params);\n  } else if (programId.equals(SABER_SWAP_PROGRAM_ID)) {\n    const stableSwap = StableSwap.loadWithData(\n      address,\n      accountInfo.data,\n      findProgramAddressSync([address.toBuffer()], SABER_SWAP_PROGRAM_ID)[0],\n    );\n\n    return new SaberAmm(stableSwap);\n  } else if (programId.equals(ALDRIN_SWAP_PROGRAM_ID) || programId.equals(ALDRIN_SWAP_V2_PROGRAM_ID)) {\n    return new AldrinAmm(address, accountInfo, params);\n  } else if ([...PROGRAM_ID_TO_LABEL.keys()].includes(programId.toBase58())) {\n    const label = PROGRAM_ID_TO_LABEL.get(accountInfo.owner.toBase58()) ?? 'Unknown';\n    return new SplTokenSwapAmm(address, accountInfo, label);\n  } else if (programId.equals(CROPPER_PROGRAM_ID)) {\n    return new CropperAmm(address, accountInfo, params);\n  } else if (programId.equals(SENCHA_PROGRAM_ID)) {\n    return new SenchaAmm(address, accountInfo);\n  }\n  // Not supported by frontend\n  return;\n}\n"],"names":["IDL","version","name","instructions","accounts","isMut","isSigner","args","type","option","defined","kind","fields","types","variants","errors","code","msg","WRAPPED_SOL_MINT","PublicKey","MAINNET_SERUM_DEX_PROGRAM","DEVNET_SERUM_DEX_PROGRAM","MARKETS_URL","devnet","testnet","RAYDIUM_AMM_V4_PROGRAM_ID","ALDRIN_SWAP_PROGRAM_ID","ALDRIN_SWAP_V2_PROGRAM_ID","SABER_ADD_DECIMALS_PROGRAM_ID","CROPPER_PROGRAM_ID","SENCHA_PROGRAM_ID","ZERO_FRACTION","Fraction","JSBI","BigInt","JUPITER_WALLET","MERCURIAL_SWAP_PROGRAM_ID","PublicKeyLayout","Layout","constructor","property","layout","blob","span","getSpan","b","offset","this","decode","encode","src","toBuffer","publicKey","U64Layout","u64","toArrayLike","Buffer","uint64","uint128","CropperTokenSwapLayout","struct","u8","CropperStateLayout","CROPPER_STATE_ADDRESS","accountInfoToCropperPoolState","address","accountInfo","programId","owner","decoded","data","authority","findProgramAddressSync","isInitialized","Boolean","nonce","ammId","serumProgramId","tokenProgramId","tokenAAccount","tokenBAccount","serumMarket","poolMint","mintA","mintB","Side","Bid","bid","Ask","ask","JUPITER_PROGRAM_ID","JUPITER_PROGRAM","Program","TOKEN_LEDGER","from","stableSwapNPoolIntoMercurialExchange","swayLayout","sourceTokenAccount","destinationTokenAccount","user","swapProgram","swapState","tokenProgram","TOKEN_PROGRAM_ID","poolAuthority","userTransferAuthority","raydiumAmmToRaydiumSwap","raydiumAmm","userSourceTokenAccountAddress","userDestinationTokenAccountAddress","ammAuthority","Uint8Array","replace","serumMarketKeys","Error","ammOpenOrders","poolCoinTokenAccount","poolPcTokenAccount","serumBids","serumAsks","serumEventQueue","serumCoinVaultAccount","serumPcVaultAccount","serumVaultSigner","userSourceTokenAccount","userDestinationTokenAccount","userSourceOwner","marketIntoSerumSwap","market","openOrdersAddress","orderPayerTokenAccountAddress","coinWallet","pcWallet","vaultSigner","createProgramAddressSync","vaultSignerNonce","openOrders","requestQueue","eventQueue","bids","bidsAddress","asks","asksAddress","coinVault","baseVault","pcVault","quoteVault","orderPayerTokenAccount","dexProgram","rent","SYSVAR_RENT_PUBKEY","createMercurialExchangeInstruction","swapLayout","amount","minimumOutAmount","platformFee","remainingAccounts","swapTokenAccount","tokenAccounts","push","pubkey","isWritable","prepareRemainingAccounts","feeAccount","instruction","mercurialExchange","BN","feeBps","createSerumSwapInstruction","inputMint","referrer","side","equals","baseMintAddress","serumSwap","createTokenSwapInstruction","tokenSwapState","isStep","swapSource","swapDestination","tokenAccountA","tokenAccountB","stepTokenSwap","tokenSwap","tokenSwapProgram","swap","source","destination","poolToken","poolFee","createSenchaSwapInstruction","poolState","sourceMint","token0Mint","token0Reserves","token1Reserves","feesSource","feesDestination","token0Fees","token1Fees","senchaExchange","userAuthority","inputUserAccount","inputTokenAccount","inputFeesAccount","outputUserAccount","outputTokenAccount","outputFeesAccount","createCropperSwapInstruction","cropperTokenSwap","createRaydiumSwapInstruction","raydiumSwapV2","createAldrinSwapInstruction","userBaseTokenAccount","userQuoteTokenAccount","baseTokenMint","aldrinSwap","pool","poolSigner","baseTokenVault","quoteTokenVault","feePoolTokenAccount","walletAuthority","createAldrinV2SwapInstruction","curve","aldrinV2Swap","createRiskCheckAndFeeInstruction","riskCheckAndFee","tokenLedger","createSetTokenLedgerInstruction","tokenAccountAddress","setTokenLedger","tokenAccount","createOpenOrdersInstruction","createOpenOrders","payer","systemProgram","SystemProgram","saberPoolIntoSaberExchange","saberPool","sourceMintAddress","feesTokenAccount","state","tokenA","mint","tokenB","adminFeeAccount","reserve","config","swapProgramID","swapAccount","swapAuthority","clock","SYSVAR_CLOCK_PUBKEY","createSaberExchangeInstruction","saberExchange","createSaberAddDecimalsDepositInstruction","addDecimals","sourceTokenAccountAddress","destinationTokenAccountAddress","saberAddDecimalsDeposit","addDecimalsProgram","wrapper","wrapperMint","wrapperUnderlyingTokens","userUnderlyingTokens","userWrappedTokens","createSaberAddDecimalsWithdrawInstruction","saberAddDecimalsWithdraw","WrappedToken","multiplier","decimals","underlyingDecimals","getOutputAmount","inputAmount","calculateWithdrawOutputAmount","underlying","calculateDepositOutputAmount","toString","multiply","divide","SaberAddDecimalsAmm","wrappedToken","label","id","toBase58","getAccountsForUpdate","Array","update","_accountInfoMap","getQuote","notEnoughLiquidity","inAmount","outAmount","toNumber","feeAmount","feeMint","feePct","priceImpactPct","createSwapInstructions","reserveTokenMints","getTwoPermutations","array","reduce","acc","item","forEach","otherItem","mapAddressToAccountInfos","accountInfoMap","addresses","map","get","AMM_INFO_LAYOUT_V4","nu64","RaydiumAmm","ammAccountInfo","coinMint","pcMint","status","ammTargetOrders","coinReserve","pcReserve","swapFeeNumerator","swapFeeDenominator","coinMintAddress","pcMintAddress","poolCoinTokenAccountInfo","poolPcTokenAccountInfo","ammOpenOrdersAccountInfo","serumMarketMarketInfo","coinAmount","pcAmount","tokenAmountAccessor","OpenOrders","fromAccountInfo","decodedMarket","Market","getLayout","add","baseTokenTotal","sub","String","needTakePnlCoin","quoteTokenTotal","needTakePnlPc","tokenAccountInfo","fromBuffer","slice","inputReserve","outputReserve","inAmountBN","mul","div","inAmountAfterFee","numerator","denominator","outAmountWithoutPriceImpact","outAmountBN","Number","Decimal","STABLE_MARKET_ADDRESSES","SerumAmm","orderbooks","asksAccountInfo","bidsAccountInfo","Orderbook","destinationMint","outAmountMeta","fromAmount","fromMint","toMint","takerFeePct","includes","quoteMintAddress","orderBook","pcIn","coinOut","bestPrice","worstPrice","totalCost","totalCoins","availablePc","baseSizeLots","baseSizeLotsToNumber","quoteSizeLots","quoteSizeLotsToNumber","order","items","price","priceLotsToNumber","priceLots","sizeLots","orderCoinAmount","orderPcAmount","lotPrice","numberLotsCanBuy","Math","floor","minimum","in","ceil","out","round","forecastBuy","coinIn","pcOut","availableCoin","numberLotsCanSell","forecastSell","getOutAmountMeta","minInAmount","minOutAmount","quoteMintToReferrer","SplitTradeAmm","firstAmm","secondAmm","shouldSplitSetup","portion1","portion2","requiresSplitSetup","isSplitSupported","firstAmmTwoPermutations","secondAmmTwoPermutations","firstAmmTwoPermutation","secondAmmTwoPermutation","every","value","index","portion","sort","a","join","quoteParams","sourceMintString","bestSolution","firstQuote","undefined","secondQuote","p","firstAmount","secondAmount","firstAmmFee","secondAmmFee","swapParams","isValidRoute","ammA","ammB","deserializeAccount","length","AccountLayout","delegateOption","delegate","delegatedAmount","isFrozen","isNativeOption","rentExemptReserve","isNative","closeAuthority","closeAuthorityOption","SaberAmm","stableSwap","calculator","tokenAccountInfos","info","Stable","targetAmpFactor","ONE","fees","trade","asFraction","toFixed","inputIndex","outputIndex","result","exchange","expectedOutputAmount","priceImpact","ZERO","Percentage","number","fromFraction","toDecimalPlaces","num","denom","toDecimal","eq","p2","denomGcd","gcd","denomLcm","p1DenomAdjustment","p2DenomAdjustment","p1NumeratorAdjusted","p2NumeratorAdjusted","newNumerator","FEES_LAYOUT","POOL_FIELDS_COMMON","POOL_LAYOUT","POOL_V2_LAYOUT","STABLE_CURVE_LAYOUT","AldrinAmm","params","isV2","curveObject","curveType","quoteTokenMint","feeBaseAccount","feeQuoteAccount","traderFee","tradeFeeNumerator","tradeFeeDenominator","ownerFee","ownerTradeFeeNumerator","ownerTradeFeeDenominator","accountInfoToAldrinPoolState","amp","TokenSwapStable","TokenSwapConstantProduct","TOKEN_SWAP_POOLS","STEP_TOKEN_SWAP_PROGRAM_ID","PROGRAM_ID_TO_LABEL","Map","TokenSwapLayout","StepTokenSwapLayout","CurveType","SplTokenSwapAmm","swapStateAccountInfo","tokenSwapAccountInfo","tokenSwapData","tokenPool","ownerWithdrawFeeNumerator","ownerWithdrawFeeDenominator","curveParameters","poolNonce","accountInfoToTokenSwapState","ConstantProduct","FEE_DENOMINATOR","pow","MercurialSwapLayout","u32","accountInfoToMercurialSwapLayout","tokenAccountsLength","precisionMultipliers","precisionMultiplierA","precisionMultiplierB","precisionMultiplierC","precisionMultiplierD","tokenAccountC","tokenAccountD","amplificationCoefficient","feeNumerator","precisionFactor","MercurialAmm","filter","x","precisionMultiplier","findIndex","tokenMints","tokenMint","decodeSwapLayout","CropperAmm","connection","getAccountInfo","stateOwner","feeOwner","initialSupply","returnFeeNumerator","fixedFeeNumerator","feeDenominator","stateAccountInfoToCropperState","tokenAFeeAccount","tokenBFeeAccount","decodePoolState","SenchaSwapLayout","SenchaAmm","isPaused","bump","token1Mint","tradeFeeKbps","accountInfoToSenchaPoolState","isPlatformFeeSupported","marketInfos","firstMarket","secondMarket","marketInfo","amm","getCacheMintKey","_marketInfos$","_marketInfos$2","outputMint","_marketInfos$3","marketMeta","getInstructionCache","instructionCache","walletPublicKey","cacheKey","_instructionCache$get","async","findOrCreateAssociatedAccountByMint","mintAddress","unwrapSOL","toAccount","Token","getAssociatedTokenAddress","ASSOCIATED_TOKEN_PROGRAM_ID","cleanupInstructions","createAssociatedTokenAccountInstruction","createCloseAccountInstruction","signers","routeAtaInstructions","userPublicKey","userIntermediaryTokenAccountResult","userDestinationTokenAccountResult","Promise","all","getUserIntermediateTokenAccountAddress","getUserDestinationTokenAccountAddress","getOrCreateOpenOrdersAddress","marketToOpenOrdersAddress","marketAddress","openOrdersAccountInfo","newOpenOrdersAddress","ix","set","calculateTransactionDepositAndFee","intermediate","feeCalculator","openOrdersDeposits","ooi","ataDepositLength","ataDeposit","signatureFee","some","oo","flat","lamportsPerSignature","NO_PLATFORM_FEE","feeAccounts","getPlatformFeeAccounts","feeAccountOwner","getTokenAccountsByOwner","deserializedtokenAccount","account","TransactionBuilder","feePayer","addInstruction","recentBlockHash","getRecentBlockhash","blockhash","txFields","recentBlockhash","curr","concat","transaction","Transaction","execute","isKeyPair","sendTransaction","Owner","_owner","signer","isPublicKey","secretKey","TransactionError","m","txid","Object","setPrototypeOf","prototype","diffTokenBalance","accountKeyIndex","meta","postBalance","postTokenBalances","_meta$postTokenBalanc","find","postTokenBalance","accountIndex","_meta$postTokenBalanc2","uiTokenAmount","preBalance","preTokenBalances","_meta$preTokenBalance","preTokenBalance","_meta$preTokenBalance2","abs","parseInt","extractTokenBalanceChangeFromTransaction","transactionResult","message","accountKeys","getConfirmTransaction","promiseRetry","txResult","getTransaction","commitment","error","retry","retries","minTimeout","Jupiter","cluster","tokenRouteSegments","platformFeeAndAccounts","routeCacheDuration","wrapUnwrapSOL","serumOpenOrdersPromise","routeCache","route","lastMarketInfoIndex","ataInstructions","openOrdersInstructions","sourceInstruction","transfer","fromPubkey","toPubkey","lamports","createSyncNativeInstruction","createAndCloseWSOLAccount","pct","preparedInstructions","openOrdersAddresses","userIntermediaryTokenAccountAddress","routeInfo","outAmountWithSlippage","legs","userTokenAccountAddresses","platformFeeSupported","mi","entries","legInputAmount","legOutAmountWithSlippage","legPlatformFee","routeToInstructions","_instructions$interme","splitSetupRequired","isSplitSetupRequired","setupTransactionBuilder","transactionBuilder","cleanupTransactionBuilder","_instructions$interme3","setupTransaction","build","cleanupTransaction","setupTransactionObject","swapTransactionObject","cleanupTransactionObject","first","second","third","transactions","swapTransaction","wallet","confirmationWaiterFactory","totalTxs","sign","signAllTransactions","signTransaction","setupError","setupTxid","sendRawTransaction","serialize","skipPreflight","e","transactionResponse","sourceTokenBalanceChange","destinationTokenBalanceChange","sourceAddress","destinationAddress","_meta$preTokenBalance3","_meta$preTokenBalance4","extractWrappedSOLChangeFromTransaction","_meta$postTokenBalanc3","_meta$postTokenBalanc4","extractSOLChangeFromTransaction","getTokenBalanceChangesFromTransactionResponse","inputAddress","outputAddress","outputAmount","cleanupTxId","_instructions","_instructions2","_instructions2$interm","_instructions3","clear","deleteInstructionCache","marketUrl","defaultQuoteMintToReferrer","fetchTokenRouteSegments","getRecentBlockhashAndContext","jupiter","setUserPublicKey","getPublicKeysToUpdate","publicKeys","Set","tokenRouteSegment","values","slippage","shouldFetchRoutes","externalAccountInfosMap","getDepositAndFees","openOrdersInstructionsPromise","promise","then","instructionResult","walletCache","setInstructionCache","getDepositAndFeeFromInstructions","platformFeeBps","now","Date","getTime","inputMintAndOutputMint","localeCompare","routes","firstSegment","simpleRoute","marketMetas","secondSegment","intersectionMarketMetas","intersectionMarketMeta","intermediateMint","computeRoutes","fetchTimestamp","extraAccountInfosMap","hasExternalAccountInfosMap","accountInfosMap","accountsToFetchSet","accountsToFetch","pks","chunkSize","size","apply","_","chunk","getMultipleAccountsInfo","chunkedGetMultipleAccountInfos","routeBatchFetcher","fetchRoutes","routesInfos","getDepositAndFeeForRoute","intermediateAmount","splice","i","quote","outAmountAfterFees","max","lpFee","getDepositAndFee","priceFactor","computeRouteInfos","cached","key","delete","findSerumOpenOrdersForOwner","amms","firstReserveMint","secondReserveMint","inMint","outMint","segments","addSegment","getTokenRouteSegments","marketsCache","fetch","json","tokenSwapPools","getTokenSwapPools","extraKeys","extraMarketKeyedAccountInfos","marketKeyedAccountInfos","format","rest","marketCacheToAccountInfo","keyedAccountInfo","SerumMarket","accountFlags","initialized","SABER_SWAP_PROGRAM_ID","StableSwap","loadWithData","keys","ammFactory","naturalAmms","addDecimalsJson","addDecimalJson","arr","func","j","ammCrossProtocolPairs","splitTradeAmm","create","getAllAmms","getRouteMap","routeMap","firstLevelOutputs","validOutputMints","firstLevelOutputMint","firstLevelMarketMetas","secondLevelOutputs","secondLevelOutputMint","secondLevelMarketMetas","firstLevelMarketMeta","secondLevelMarketMeta","computeRouteMap","newMarketToOpenOrdersAddress","findForOwner","createCreateTokenLedgerInstruction","initializeTokenLedger"],"mappings":"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"}