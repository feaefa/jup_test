"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@solana/spl-token"),t=require("@solana/web3.js"),n=require("@project-serum/serum"),o=require("@saberhq/stableswap-sdk"),i=require("jsbi"),r=require("@project-serum/anchor"),s=require("@project-serum/anchor/dist/cjs/utils/pubkey"),a=require("bn.js"),u=require("@jup-ag/math"),c=require("@solana/buffer-layout"),m=require("decimal.js"),l=require("cross-fetch"),d=require("promise-retry");function p(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var g=p(i),f=p(a),h=p(m),A=p(l),w=p(d),k=[{wrapper:"2B5Qedoo95Pjpv9xVPw82bbmcGDGCNHroKpzQE2CNHRZ",underlying:"CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",underlyingDecimals:6,wrapperUnderlyingTokens:"3YCGgStAV9H7TdPYdBnRP8yoH4Zqdmyt7xo6KB4Wa8xt",mint:"C9xqJe3gMTUDKidZsZ6jJ7tL9zSLimDUKVpgUbLZnNbi",decimals:9},{wrapper:"2ffwMLE4dxSv59eYXhfhfuS81kz6gzf6DZjdBxRHZz9A",underlying:"AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",underlyingDecimals:6,wrapperUnderlyingTokens:"H5tnZcfHCzHueNnfd6foeBBUUW4g7qXKt6rKzT7wg6oP",mint:"FTT9rBBrYwcHam4qLvkzzzhrsihYMbZ3k6wJbdoahxAt",decimals:9},{wrapper:"3A85wiQg2REhBVxVS1CjDaS333TBNM2g37BbdNGSMheg",underlying:"CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",underlyingDecimals:8,wrapperUnderlyingTokens:"764FaQrrREvNTpaH2yXyrPZgVBaXA7AXM8vyCaevXitD",mint:"BtX7AfzEJLnU8KQR1AgHrhGH5s2AHUTbfjhUQP8BhPvi",decimals:10},{wrapper:"7hWjnVC6FNkmmgjq88LEnRycrKvxVB1MsJ6FQcrvxe4n",underlying:"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",underlyingDecimals:6,wrapperUnderlyingTokens:"B22gDMgN2tNWmvyzhb5tamJKanWcUUUw2zN3h3qjgQg8",mint:"9999j2A8sXUtHtDoQdk528oVzhaKBsXyRGZ67FKGoi7H",decimals:9},{wrapper:"93qsLbASEG8DmtSB2MEVaa25KvEm2afh5rzbaAJHLi5A",underlying:"7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",underlyingDecimals:8,wrapperUnderlyingTokens:"4fUL9yLbFZEuG32SaCjWqJXwDTBFNnipteBWxMvvFoC8",mint:"KNVfdSJyq1pRQk9AKKv1g5uyGuk6wpm4WG16Bjuwdma",decimals:9},{wrapper:"AnKLLfpMcceM6YXtJ9nGxYekVXqfWy8WNsMZXoQTCVQk",underlying:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",underlyingDecimals:6,wrapperUnderlyingTokens:"77XHXCWYQ76E9Q3uCuz1geTaxsqJZf9RfX5ZY7yyLDYt",mint:"JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",decimals:9},{wrapper:"D231Uoh24bXtUtWN51ZbFAFSBmGT3zuuEAHZNuCmtRjN",underlying:"CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",underlyingDecimals:8,wrapperUnderlyingTokens:"C39Wq6X98TLcrnYCMkcHQhwUurkQMUdibUCpf2fVBDsm",mint:"FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",decimals:9},{wrapper:"F9TsAsh5RirU3LqyTJECLQEGXnF4RQT7ckvexCP1KNTu",underlying:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",underlyingDecimals:6,wrapperUnderlyingTokens:"BSTjdztBrsptuxfz9JHS31Wc9CknpLeL1wqZjeVs1Ths",mint:"AEUT5uFm1D575FVCoQd5Yq891FJEqkncZUbBFoFcAhTV",decimals:9},{wrapper:"FCgoT8RpsopdM5QT6AB98NUfUnDnu7y865MFpRx93JrS",underlying:"EzfgjvkSwthhgHaceR3LnKXUoRkP6NUhfghdaHAj1tUv",underlyingDecimals:8,wrapperUnderlyingTokens:"5yugfArBAUZJJBUCRWPuiLyi6CWp1f67H9xgg3hcgSkx",mint:"FTT9GrHBVHvDeUTgLU8FxVJouGqg9uiWGmmjETdm32Sx",decimals:9},{wrapper:"FDGtFWVhEb1zxnaW2FzogeGDxLoAV7Cu9XdNYPEVwqt",underlying:"8wv2KAykQstNAj2oW6AHANGBiFKVFhvMiyyzzjhkmGvE",underlyingDecimals:6,wrapperUnderlyingTokens:"4R6PmC8BJcPDBsEMGpXpLCnFFkUZhEgZy6pMNtc2LqA4",mint:"KUANeD8EQvwpT1W7QZDtDqctLEh2FfSTy5pThE9CogT",decimals:9},{wrapper:"FPuYMuodknZuQKHA8Wp4PBbp52Qu8nK2oAuwedp2WfM3",underlying:"9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",underlyingDecimals:6,wrapperUnderlyingTokens:"GxpyQZi5VkZDSq5TUycMau11sCkQkVCa8xYhBgiPMsyK",mint:"UST98bfV6EASdTFQrRwCBczpehdMFwYCUdLT5tEbhpW",decimals:9},{wrapper:"G4gRGymKo7MGzGZup12JS39YVCvy8YMM6KY9AmcKi5iw",underlying:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",underlyingDecimals:6,wrapperUnderlyingTokens:"AQhP39mE4o6BYNwnwYqnz7ZobkPBSLpCg8WvEESq1viZ",mint:"88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",decimals:8},{wrapper:"GiLSv94Wwyd6suH57Fu6HjEKsMxhNGfEwKn9vT22me1p",underlying:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",underlyingDecimals:6,wrapperUnderlyingTokens:"3cjAWoyDcco8UVCN17keNUNHoyz37ctgDa7G6zkeb81Y",mint:"T8KdT8hDzNhbGx5sjpEUxepnbDB1TZoCa7vtC5JjsMw",decimals:8},{wrapper:"GpkFF2nPfjUcsavgDGscxaUEQ2hYJ563AXXtU8ohiZ7c",underlying:"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",underlyingDecimals:6,wrapperUnderlyingTokens:"6hYDFhZ5ddfzoqaAbzRHm8mzG2MQzYQV9295sQHsvNBV",mint:"SBTCB6pWqeDo6zGi9WVRMLCsKsN6JiR1RMUqvLtgSRv",decimals:8},{wrapper:"fvSvtHNFuDHrAN82YEyBApRs3U6vUGCLzKGMuPmCaF8",underlying:"2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk",underlyingDecimals:6,wrapperUnderlyingTokens:"4JWyJ4ZYsQ8uiYue2tTEqcHcFXrDuaQ1rsyjNFfrZm65",mint:"SL819j8K9FuFPL84UepVcFkEZqDUUvVzwDmJjCHySYj",decimals:8},{wrapper:"ACvLVgR3UKdDB3b1QapsbJsPXaUrBPdJGDfiFnMYMXoz",underlying:"F6v4wfAdJB8D8p77bMXZgYt8TDKsYxLYxH5AFhUkYx9W",underlyingDecimals:6,wrapperUnderlyingTokens:"AvqMJWHsZscPWTAUcj8dZi2ch6XQEHMpiCMprfFovaU",mint:"LUNGEjUXyP48nrC1GYY5o4eTAkwm4RdX8BxFUxWJBLB",decimals:9}];const S={version:"0.1.0",name:"jupiter",instructions:[{name:"mercurialExchange",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"poolAuthority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceTokenAccount",isMut:!0,isSigner:!1},{name:"destinationTokenAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberExchange",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapAuthority",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"feesTokenAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberAddDecimalsDeposit",accounts:[{name:"addDecimalsProgram",isMut:!1,isSigner:!1},{name:"wrapper",isMut:!1,isSigner:!1},{name:"wrapperMint",isMut:!0,isSigner:!1},{name:"wrapperUnderlyingTokens",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"userUnderlyingTokens",isMut:!0,isSigner:!1},{name:"userWrappedTokens",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberAddDecimalsWithdraw",accounts:[{name:"addDecimalsProgram",isMut:!1,isSigner:!1},{name:"wrapper",isMut:!1,isSigner:!1},{name:"wrapperMint",isMut:!0,isSigner:!1},{name:"wrapperUnderlyingTokens",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"userUnderlyingTokens",isMut:!0,isSigner:!1},{name:"userWrappedTokens",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"senchaExchange",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!0,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"inputFeesAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"outputFeesAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"serumSwap",accounts:[{name:"market",accounts:[{name:"market",isMut:!0,isSigner:!1},{name:"openOrders",isMut:!0,isSigner:!1},{name:"requestQueue",isMut:!0,isSigner:!1},{name:"eventQueue",isMut:!0,isSigner:!1},{name:"bids",isMut:!0,isSigner:!1},{name:"asks",isMut:!0,isSigner:!1},{name:"coinVault",isMut:!0,isSigner:!1},{name:"pcVault",isMut:!0,isSigner:!1},{name:"vaultSigner",isMut:!1,isSigner:!1}]},{name:"authority",isMut:!1,isSigner:!0},{name:"orderPayerTokenAccount",isMut:!0,isSigner:!1},{name:"coinWallet",isMut:!0,isSigner:!1},{name:"pcWallet",isMut:!0,isSigner:!1},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"side",type:{defined:"Side"}},{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"tokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"stepTokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"cropperTokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"raydiumSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"ammId",isMut:!0,isSigner:!1},{name:"ammAuthority",isMut:!1,isSigner:!1},{name:"ammOpenOrders",isMut:!0,isSigner:!1},{name:"ammTargetOrders",isMut:!0,isSigner:!1},{name:"poolCoinTokenAccount",isMut:!0,isSigner:!1},{name:"poolPcTokenAccount",isMut:!0,isSigner:!1},{name:"serumProgramId",isMut:!1,isSigner:!1},{name:"serumMarket",isMut:!0,isSigner:!1},{name:"serumBids",isMut:!0,isSigner:!1},{name:"serumAsks",isMut:!0,isSigner:!1},{name:"serumEventQueue",isMut:!0,isSigner:!1},{name:"serumCoinVaultAccount",isMut:!0,isSigner:!1},{name:"serumPcVaultAccount",isMut:!0,isSigner:!1},{name:"serumVaultSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userSourceOwner",isMut:!1,isSigner:!0}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"raydiumSwapV2",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"ammId",isMut:!0,isSigner:!1},{name:"ammAuthority",isMut:!1,isSigner:!1},{name:"ammOpenOrders",isMut:!0,isSigner:!1},{name:"poolCoinTokenAccount",isMut:!0,isSigner:!1},{name:"poolPcTokenAccount",isMut:!0,isSigner:!1},{name:"serumProgramId",isMut:!1,isSigner:!1},{name:"serumMarket",isMut:!0,isSigner:!1},{name:"serumBids",isMut:!0,isSigner:!1},{name:"serumAsks",isMut:!0,isSigner:!1},{name:"serumEventQueue",isMut:!0,isSigner:!1},{name:"serumCoinVaultAccount",isMut:!0,isSigner:!1},{name:"serumPcVaultAccount",isMut:!0,isSigner:!1},{name:"serumVaultSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userSourceOwner",isMut:!1,isSigner:!0}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"aldrinSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"side",type:{defined:"Side"}},{name:"platformFeeBps",type:"u8"}]},{name:"aldrinV2Swap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"curve",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"side",type:{defined:"Side"}},{name:"platformFeeBps",type:"u8"}]},{name:"riskCheckAndFee",accounts:[{name:"tokenLedger",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"initializeTokenLedger",accounts:[{name:"tokenLedger",isMut:!0,isSigner:!1},{name:"payer",isMut:!1,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"setTokenLedger",accounts:[{name:"tokenLedger",isMut:!0,isSigner:!1},{name:"tokenAccount",isMut:!1,isSigner:!1}],args:[]},{name:"createOpenOrders",accounts:[{name:"openOrders",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"market",isMut:!1,isSigner:!1}],args:[]}],accounts:[{name:"tokenLedger",type:{kind:"struct",fields:[{name:"tokenAccount",type:"publicKey"},{name:"amount",type:"u64"}]}}],types:[{name:"Swap",type:{kind:"struct",fields:[{name:"tokens",type:"u64"},{name:"minTokens",type:"u64"},{name:"side",type:{defined:"Side"}}]}},{name:"Swap",type:{kind:"struct",fields:[{name:"tokens",type:"u64"},{name:"minTokens",type:"u64"},{name:"side",type:{defined:"Side"}}]}},{name:"Deposit",type:{kind:"struct",fields:[{name:"amount",type:"u64"}]}},{name:"Withdraw",type:{kind:"struct",fields:[{name:"maxBurnAmount",type:"u64"}]}},{name:"Direction",type:{kind:"enum",variants:[{name:"LeftToRight"},{name:"RightToLeft"}]}},{name:"Side",type:{kind:"enum",variants:[{name:"Bid"},{name:"Ask"}]}}],errors:[{code:6e3,name:"SlippageToleranceExceeded",msg:"Slippage tolerance exceeded"},{code:6001,name:"InvalidTokenLedger",msg:"Invalid token ledger"},{code:6002,name:"MissingTokenLedger",msg:"Missing token ledger"},{code:6003,name:"MissingMercurialExchangeTokenAccount",msg:"Missing mercurial exchange token account"},{code:6004,name:"LedgerTokenAccountDoesNotMatch",msg:"Ledger token account does not match"},{code:6005,name:"MissingPlatformFeeAccount",msg:"Missing platform fee account"},{code:6006,name:"InvalidCalculation",msg:"Invalid calculation"}]},y=new t.PublicKey("So11111111111111111111111111111111111111112"),M=new t.PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),T=new t.PublicKey("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY"),v={devnet:"https://api.jup.ag/api/markets/cache/devnet","mainnet-beta":"https://cache.jup.ag/markets?v=3",testnet:"https://api.jup.ag/api/markets/cache/devnet"},b=new t.PublicKey("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),P=new t.PublicKey("AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6"),B=new t.PublicKey("CURVGoZn8zycx6FXwwevgBTB2gVvdbGTEpvMJDbgs2t4"),F=new t.PublicKey("DecZY86MU5Gj7kppfUCEmd4LbXXuyZH1yHaP2NTqdiZB"),I=new t.PublicKey("CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh"),N=new t.PublicKey("SCHAtsf8mbjyjiv4LkhLKutTf6JnZAbdJKFkXQNMFHZ"),D=new u.Fraction(g.default.BigInt(0),g.default.BigInt(1)),O=new t.PublicKey("BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9"),E=new t.PublicKey("MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky");class K extends c.Layout{constructor(e){const t=c.blob(32);super(t.span,e),this.layout=void 0,this.layout=t}getSpan(e,t){return this.layout.getSpan(e,t)}decode(e,n){return new t.PublicKey(this.layout.decode(e,n))}encode(e,t,n){return this.layout.encode(e.toBuffer(),t,n)}}const R=e=>new K(e);class C extends c.Layout{constructor(e=8,t){const n=c.blob(e);super(n.span,t),this.layout=void 0,this.layout=n}getSpan(e,t){return this.layout.getSpan(e,t)}decode(t,n){return new e.u64(this.layout.decode(t,n),10,"le")}encode(e,t,n){return this.layout.encode(e.toArrayLike(Buffer,"le",this.layout.span),t,n)}}const U=e=>new C(8,e),q=e=>new C(16,e),L=c.struct([c.u8("version"),c.u8("isInitialized"),c.u8("nonce"),R("ammId"),R("serumProgramId"),R("serumMarket"),R("tokenProgramId"),R("tokenAAccount"),R("tokenBAccount"),R("poolMint"),R("mintA"),R("mintB")]),x=c.struct([c.u8("isInitialized"),R("stateOwner"),R("feeOwner"),U("initialSupply"),U("returnFeeNumerator"),U("fixedFeeNumerator"),U("feeDenominator"),c.u8("curveType"),c.blob(32,"curveParameters")]),V=new t.PublicKey("3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq"),W=(e,t)=>{const n=t.owner,o=L.decode(t.data),[i]=s.findProgramAddressSync([e.toBuffer()],n);return{programId:n,authority:i,version:o.version,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:o.ammId,serumProgramId:o.serumProgramId,tokenProgramId:o.tokenProgramId,tokenAAccount:o.tokenAAccount,tokenBAccount:o.tokenBAccount,serumMarket:o.serumMarket,poolMint:o.poolMint,mintA:o.mintA,mintB:o.mintB}},G={Bid:{bid:{}},Ask:{ask:{}}},Q=new t.PublicKey("JUP2jxvXaqu7NQY1GmNF4m1vodw12LVXYxbFL2uJvfo"),z=new r.Program(S,Q,{}),[_]=s.findProgramAddressSync([Buffer.from("token_ledger")],Q);function j(t,n,o,i){return{swapProgram:E,swapState:t.ammId,tokenProgram:e.TOKEN_PROGRAM_ID,poolAuthority:t.authority,userTransferAuthority:i,sourceTokenAccount:n,destinationTokenAccount:o}}function Y(t,n,o,i){const[r]=s.findProgramAddressSync([new Uint8Array(Buffer.from("amm authority".replace("Â "," "),"utf-8"))],b);if(!t.serumMarketKeys)throw Error("RaydiumAmm is missing serumMarketKeys");return{swapProgram:b,tokenProgram:e.TOKEN_PROGRAM_ID,ammId:t.ammId,ammAuthority:r,ammOpenOrders:t.ammOpenOrders,poolCoinTokenAccount:t.poolCoinTokenAccount,poolPcTokenAccount:t.poolPcTokenAccount,serumProgramId:t.serumProgramId,serumMarket:t.serumMarket,serumBids:t.serumMarketKeys.serumBids,serumAsks:t.serumMarketKeys.serumAsks,serumEventQueue:t.serumMarketKeys.serumEventQueue,serumCoinVaultAccount:t.serumMarketKeys.serumCoinVaultAccount,serumPcVaultAccount:t.serumMarketKeys.serumPcVaultAccount,serumVaultSigner:t.serumMarketKeys.serumVaultSigner,userSourceTokenAccount:n,userDestinationTokenAccount:o,userSourceOwner:i}}function H(n,o,i,r,a,u){const c=s.createProgramAddressSync([n.address.toBuffer(),n.decoded.vaultSignerNonce.toArrayLike(Buffer,"le",8)],n.programId);return{market:{market:n.address,openOrders:o,requestQueue:n.decoded.requestQueue,eventQueue:n.decoded.eventQueue,bids:n.bidsAddress,asks:n.asksAddress,coinVault:n.decoded.baseVault,pcVault:n.decoded.quoteVault,vaultSigner:c},authority:u,orderPayerTokenAccount:i,coinWallet:r,pcWallet:a,dexProgram:n.programId,tokenProgram:e.TOKEN_PROGRAM_ID,rent:t.SYSVAR_RENT_PUBKEY}}function Z(e,t,n,o,i,r,s){var u;const c=[];for(const t of e.tokenAccounts)c.push({pubkey:t,isSigner:!1,isWritable:!0});return c.push(...le(i,null==s?void 0:s.feeAccount)),z.instruction.mercurialExchange(i?new a.BN(i):i,new a.BN(r),null!==(u=null==s?void 0:s.feeBps)&&void 0!==u?u:0,{accounts:j(e,t,n,o),remainingAccounts:c})}function X(e,t,n,o,i,r,s,u,c,m){var l;const{side:d,coinWallet:p,pcWallet:g}=t.equals(e.baseMintAddress)?{side:G.Ask,coinWallet:o,pcWallet:i}:{side:G.Bid,coinWallet:i,pcWallet:o};let f=le(s,null==c?void 0:c.feeAccount);return m&&f.push({pubkey:m,isSigner:!1,isWritable:!0}),z.instruction.serumSwap(d,s?new a.BN(s):s,new a.BN(u),null!==(l=null==c?void 0:c.feeBps)&&void 0!==l?l:0,{accounts:H(e,n,o,p,g,r),remainingAccounts:f})}function J(t,n,o,i,r,s,u,c,m){var l;const[d,p]=n.equals(t.mintA)?[t.tokenAccountA,t.tokenAccountB]:[t.tokenAccountB,t.tokenAccountA];return(m?z.instruction.stepTokenSwap:z.instruction.tokenSwap)(s?new a.BN(s):s,new a.BN(u),null!==(l=null==c?void 0:c.feeBps)&&void 0!==l?l:0,{accounts:{tokenSwapProgram:t.programId,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.address,authority:t.authority,userTransferAuthority:r,source:o,swapSource:d,swapDestination:p,destination:i,poolMint:t.poolToken,poolFee:t.feeAccount},remainingAccounts:le(s,null==c?void 0:c.feeAccount)})}function $(t,n,o,i,r,s,u,c){var m;const[l,d]=n.equals(t.token0Mint)?[t.token0Reserves,t.token1Reserves]:[t.token1Reserves,t.token0Reserves],[p,g]=n.equals(t.token0Mint)?[t.token0Fees,t.token1Fees]:[t.token1Fees,t.token0Fees];return z.instruction.senchaExchange(s?new a.BN(s):s,new a.BN(u),null!==(m=null==c?void 0:c.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:t.programId,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.ammId,userAuthority:r,inputUserAccount:o,inputTokenAccount:l,inputFeesAccount:p,outputUserAccount:i,outputTokenAccount:d,outputFeesAccount:g},remainingAccounts:le(s,null==c?void 0:c.feeAccount)})}function ee(t,n,o,i,r,s,u,c,m){var l;const[d,p]=n.equals(t.mintA)?[t.tokenAAccount,t.tokenBAccount]:[t.tokenBAccount,t.tokenAAccount];return z.instruction.cropperTokenSwap(u?new a.BN(u):u,new a.BN(c),null!==(l=null==m?void 0:m.feeBps)&&void 0!==l?l:0,{accounts:{tokenSwapProgram:t.programId,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.ammId,swapState:V,authority:t.authority,userTransferAuthority:r,source:o,swapSource:d,swapDestination:p,destination:i,poolMint:t.poolMint,poolFee:s},remainingAccounts:le(u,null==m?void 0:m.feeAccount)})}function te(e,t,n,o,i,r,s){var u;return z.instruction.raydiumSwapV2(i?new a.BN(i):i,new a.BN(r),null!==(u=null==s?void 0:s.feeBps)&&void 0!==u?u:0,{accounts:Y(e,t,n,o),remainingAccounts:le(i,null==s?void 0:s.feeAccount)})}function ne(t,n,o,i,r,s,u,c){var m;const[l,d,p]=n.equals(t.baseTokenMint)?[G.Ask,o,i]:[G.Bid,i,o];return z.instruction.aldrinSwap(s?new a.BN(s):s,new a.BN(u),l,null!==(m=null==c?void 0:c.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:P,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:r,userBaseTokenAccount:d,userQuoteTokenAccount:p,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:le(s,null==c?void 0:c.feeAccount)})}function oe(t,n,o,i,r,s,u,c,m){var l;const[d,p,g]=n.equals(t.baseTokenMint)?[G.Ask,o,i]:[G.Bid,i,o];return z.instruction.aldrinV2Swap(u?new a.BN(u):u,new a.BN(c),d,null!==(l=null==m?void 0:m.feeBps)&&void 0!==l?l:0,{accounts:{swapProgram:B,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:s,userBaseTokenAccount:p,userQuoteTokenAccount:g,curve:r,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:le(u,null==m?void 0:m.feeAccount)})}function ie(t,n,o,i){var r;const s=[];return null!=i&&i.feeAccount&&s.push({pubkey:i.feeAccount,isSigner:!1,isWritable:!0}),z.instruction.riskCheckAndFee(new a.BN(o),null!==(r=null==i?void 0:i.feeBps)&&void 0!==r?r:0,{accounts:{tokenLedger:_,userDestinationTokenAccount:t,userTransferAuthority:n,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:s})}function re(e){return z.instruction.setTokenLedger({accounts:{tokenLedger:_,tokenAccount:e}})}function se(e,n){const[o]=s.findProgramAddressSync([Buffer.from("open_orders"),e.publicKey.toBuffer(),n.toBuffer()],Q);return[o,z.instruction.createOpenOrders({accounts:{openOrders:o,payer:n,dexProgram:e.programId,systemProgram:t.SystemProgram.programId,rent:t.SYSVAR_RENT_PUBKEY,market:e.publicKey}})]}function ae(n,o,i,r,s){const a=o.equals(n.state.tokenA.mint)?n.state.tokenB.adminFeeAccount:n.state.tokenA.adminFeeAccount,[u,c]=o.equals(n.state.tokenA.mint)?[n.state.tokenA.reserve,n.state.tokenB.reserve]:[n.state.tokenB.reserve,n.state.tokenA.reserve];return{swapProgram:n.config.swapProgramID,tokenProgram:e.TOKEN_PROGRAM_ID,swap:n.config.swapAccount,swapAuthority:n.config.authority,userAuthority:s,clock:t.SYSVAR_CLOCK_PUBKEY,inputUserAccount:i,inputTokenAccount:u,outputUserAccount:r,outputTokenAccount:c,feesTokenAccount:a}}function ue(e,t,n,o,i,r,s,u){var c;const m=le(r,null==u?void 0:u.feeAccount);return z.instruction.saberExchange(r?new a.BN(r):r,new a.BN(s),null!==(c=null==u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:ae(e,t,n,o,i),remainingAccounts:m})}function ce(t,n,o,i,r,s,u){var c;const m=le(r,null==u?void 0:u.feeAccount);return z.instruction.saberAddDecimalsDeposit(r?new a.BN(r):r,new a.BN(s),null!==(c=null==u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{addDecimalsProgram:F,wrapper:t.wrapper,wrapperMint:t.mint,wrapperUnderlyingTokens:t.wrapperUnderlyingTokens,owner:i,userUnderlyingTokens:n,userWrappedTokens:o,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:m})}function me(t,n,o,i,r,s,u){var c;const m=le(r,null==u?void 0:u.feeAccount);return z.instruction.saberAddDecimalsWithdraw(r?new a.BN(r):r,new a.BN(s),null!==(c=null==u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{addDecimalsProgram:F,wrapper:t.wrapper,wrapperMint:t.mint,wrapperUnderlyingTokens:t.wrapperUnderlyingTokens,owner:i,userUnderlyingTokens:o,userWrappedTokens:n,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:m})}function le(e,t){const n=[];return null===e&&n.push({pubkey:_,isSigner:!1,isWritable:!0}),t&&n.push({pubkey:t,isSigner:!1,isWritable:!0}),n}class de{constructor(e){this.addDecimals=void 0,this.addDecimals=e}get multiplier(){return 10**(this.addDecimals.decimals-this.addDecimals.underlyingDecimals)}getOutputAmount(e,t){if(this.addDecimals.mint.equals(t))return this.calculateWithdrawOutputAmount(e);if(this.addDecimals.underlying.equals(t))return this.calculateDepositOutputAmount(e);throw new Error(`unknown input token: ${t.toString()}`)}calculateDepositOutputAmount(e){return g.default.multiply(g.default.BigInt(e),g.default.BigInt(this.multiplier))}calculateWithdrawOutputAmount(e){return g.default.divide(g.default.BigInt(e),g.default.BigInt(this.multiplier))}}class pe{constructor(e){this.wrappedToken=void 0,this.label="Saber (Decimals)",this.wrappedToken=e}get id(){return this.wrappedToken.addDecimals.wrapper.toBase58()}getAccountsForUpdate(){return new Array}update(e){}getQuote({sourceMint:e,amount:t}){return{notEnoughLiquidity:!1,inAmount:t,outAmount:g.default.toNumber(this.wrappedToken.getOutputAmount(t,e)),feeAmount:0,feeMint:e.toBase58(),feePct:0,priceImpactPct:0}}createSwapInstructions({sourceMint:e,sourceTokenAccount:t,destinationTokenAccount:n,userTransferAuthority:o,amount:i,minimumOutAmount:r,platformFee:s}){return this.wrappedToken.addDecimals.underlying.equals(e)?[ce(this.wrappedToken.addDecimals,t,n,o,i,r,s)]:[me(this.wrappedToken.addDecimals,t,n,o,i,r,s)]}get reserveTokenMints(){return[this.wrappedToken.addDecimals.underlying,this.wrappedToken.addDecimals.mint]}}function ge(e){return e.reduce(((t,n)=>(e.forEach((e=>{n!==e&&t.push([n,e])})),t)),new Array)}const fe=(e,t)=>t.map((t=>{const n=e.get(t.toString());if(!n)throw new Error(`Account info ${t.toBase58()} missing`);return n})),he=c.struct([c.nu64("status"),c.nu64("nonce"),c.nu64("orderNum"),c.nu64("depth"),c.nu64("coinDecimals"),c.nu64("pcDecimals"),c.nu64("state"),c.nu64("resetFlag"),c.nu64("minSize"),c.nu64("volMaxCutRatio"),c.nu64("amountWaveRatio"),c.nu64("coinLotSize"),c.nu64("pcLotSize"),c.nu64("minPriceMultiplier"),c.nu64("maxPriceMultiplier"),c.nu64("systemDecimalsValue"),c.nu64("minSeparateNumerator"),c.nu64("minSeparateDenominator"),c.nu64("tradeFeeNumerator"),c.nu64("tradeFeeDenominator"),c.nu64("pnlNumerator"),c.nu64("pnlDenominator"),c.nu64("swapFeeNumerator"),c.nu64("swapFeeDenominator"),c.nu64("needTakePnlCoin"),c.nu64("needTakePnlPc"),c.nu64("totalPnlPc"),c.nu64("totalPnlCoin"),q("poolTotalDepositPc"),q("poolTotalDepositCoin"),q("swapCoinInAmount"),q("swapPcOutAmount"),c.nu64("swapCoin2PcFee"),q("swapPcInAmount"),q("swapCoinOutAmount"),c.nu64("swapPc2CoinFee"),R("poolCoinTokenAccount"),R("poolPcTokenAccount"),R("coinMintAddress"),R("pcMintAddress"),R("lpMintAddress"),R("ammOpenOrders"),R("serumMarket"),R("serumProgramId"),R("ammTargetOrders"),R("poolWithdrawQueue"),R("poolTempLpTokenAccount"),R("ammOwner"),R("pnlOwner")]);class Ae{constructor(n,o){this.ammId=void 0,this.ammAccountInfo=void 0,this.label="Raydium",this.coinMint=void 0,this.pcMint=void 0,this.status=void 0,this.serumProgramId=void 0,this.serumMarket=void 0,this.ammOpenOrders=void 0,this.ammTargetOrders=void 0,this.poolCoinTokenAccount=void 0,this.poolPcTokenAccount=void 0,this.serumMarketKeys=void 0,this.coinReserve=void 0,this.pcReserve=void 0,this.swapFeeNumerator=void 0,this.swapFeeDenominator=void 0,this.ammId=n,this.ammAccountInfo=o;const i=he.decode(o.data);this.status=i.status,this.coinMint=new t.PublicKey(i.coinMintAddress),this.pcMint=new t.PublicKey(i.pcMintAddress),this.poolCoinTokenAccount=new t.PublicKey(i.poolCoinTokenAccount),this.poolPcTokenAccount=new t.PublicKey(i.poolPcTokenAccount),this.swapFeeNumerator=new e.u64(i.swapFeeNumerator),this.swapFeeDenominator=new e.u64(i.swapFeeDenominator),this.serumProgramId=new t.PublicKey(i.serumProgramId),this.serumMarket=new t.PublicKey(i.serumMarket),this.ammOpenOrders=new t.PublicKey(i.ammOpenOrders),this.ammTargetOrders=new t.PublicKey(i.ammTargetOrders)}get id(){return this.ammId.toBase58()}getAccountsForUpdate(){return[this.ammId,this.poolCoinTokenAccount,this.poolPcTokenAccount,this.ammOpenOrders,this.serumMarket]}update(t){const[o,i,r,a,u]=fe(t,this.getAccountsForUpdate());this.ammAccountInfo=o;const[c,m]=[Ae.tokenAmountAccessor(i),Ae.tokenAmountAccessor(r)],l=n.OpenOrders.fromAccountInfo(this.ammOpenOrders,a,a.owner),d=n.Market.getLayout(this.serumProgramId).decode(u.data),p=s.createProgramAddressSync([this.serumMarket.toBuffer(),d.vaultSignerNonce.toArrayLike(Buffer,"le",8)],this.serumProgramId);this.serumMarketKeys={serumBids:d.bids,serumAsks:d.asks,serumEventQueue:d.eventQueue,serumCoinVaultAccount:d.baseVault,serumPcVaultAccount:d.quoteVault,serumVaultSigner:p};const g=he.decode(this.ammAccountInfo.data);this.coinReserve=c.add(l.baseTokenTotal).sub(new e.u64(String(g.needTakePnlCoin))),this.pcReserve=m.add(l.quoteTokenTotal).sub(new e.u64(String(g.needTakePnlPc)))}static tokenAmountAccessor(t){return e.u64.fromBuffer(t.data.slice(64,72))}getQuote({sourceMint:e,amount:t}){if(!this.coinReserve||!this.pcReserve)throw new Error("Pool token accounts balances not refreshed or empty");const{coinReserve:n,pcReserve:o}=this,[i,r]=this.coinMint.equals(e)?[n,o]:[o,n],s=new f.default(String(t)),a=s.mul(this.swapFeeNumerator).div(this.swapFeeDenominator),u=s.sub(a),c=u.mul(r),m=i.add(u),l=u.mul(r).div(i),d=c.div(m);return{notEnoughLiquidity:!1,inAmount:t,outAmount:Number(d.toString()),feeAmount:Number(a.toString()),feeMint:e.toBase58(),feePct:Number(new h.default(this.swapFeeNumerator.toString()).div(this.swapFeeDenominator.toString()).toString()),priceImpactPct:Number(new h.default(l.sub(d).toString()).div(l.toString()).toString())}}createSwapInstructions({sourceTokenAccount:e,destinationTokenAccount:t,userTransferAuthority:n,amount:o,minimumOutAmount:i,platformFee:r}){return[te(this,e,t,n,o,i,r)]}get reserveTokenMints(){return[this.coinMint,this.pcMint]}}const we=["77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS","5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z"];class ke{constructor(e){this.market=void 0,this.label="Serum",this.orderbooks=void 0,this.market=e}get id(){return this.market.address.toBase58()}getAccountsForUpdate(){return[this.market.asksAddress,this.market.bidsAddress]}update(e){const[t,o]=fe(e,this.getAccountsForUpdate()),i=n.Orderbook.decode(this.market,t.data),r=n.Orderbook.decode(this.market,o.data);this.orderbooks={asks:i,bids:r}}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.orderbooks)throw new Error("Failed to find orderbooks");const o=function({market:e,asks:t,bids:n,fromAmount:o,fromMint:i,toMint:r}){const s=we.includes(e.address.toBase58())?1e-4:4e-4;return i.equals(e.quoteMintAddress)&&r.equals(e.baseMintAddress)?function(e,t,n,o){let i=0,r=0,s=0,a=0,u=0,c=n/(1+o);const m=e.baseSizeLotsToNumber(new f.default(1)),l=e.quoteSizeLotsToNumber(new f.default(1));for(const n of t.items(!1)){const t=e.priceLotsToNumber(n.priceLots);u+=e.baseSizeLotsToNumber(n.sizeLots),r||0===t||(r=t),s=t;const o=n.sizeLots.toNumber()*m,d=n.sizeLots.toNumber()*n.priceLots.toNumber()*l,p=n.priceLots.toNumber()*l;if(d>=c){const e=Math.floor(c/p);a+=e*p,i+=e*m,c-=e*p;break}a+=n.sizeLots.toNumber()*p,i+=o,c-=d}const d=r?(s-r)/r:0;return{side:"buy",notEnoughLiquidity:u<=i,minimum:{in:Math.ceil(m*r*(1+o)),out:m},inAmount:Math.ceil(a*(1+o)),outAmount:i,feeAmount:Math.round(a*o),priceImpactPct:d,feePct:o}}(e,t,o,s):function(e,t,n,o){let i=0,r=0,s=0,a=n,u=0;const c=e.baseSizeLotsToNumber(new f.default(1)),m=e.quoteSizeLotsToNumber(new f.default(1));for(const n of t.items(!0)){const t=e.priceLotsToNumber(n.priceLots);r||0===t||(r=t),s=t;const o=n.sizeLots.toNumber()*c,l=n.sizeLots.toNumber()*n.priceLots.toNumber()*m;if(a<=o){const e=Math.floor(a/c);i+=e*n.priceLots.toNumber()*m,a=0,u+=e*c;break}i+=l,a-=o,u+=o}i=Math.floor(i*(1-o));const l=r?(r-s)/r:0;return{side:"sell",notEnoughLiquidity:a>0,minimum:{in:c,out:Math.ceil(c*r*(1-o))},inAmount:u,outAmount:i,feeAmount:Math.round(i*o),priceImpactPct:l,feePct:o}}(e,n,o,s)}({market:this.market,asks:this.orderbooks.asks,bids:this.orderbooks.bids,fromMint:e,toMint:t,fromAmount:n});return{notEnoughLiquidity:o.notEnoughLiquidity,minInAmount:o.minimum.in,minOutAmount:o.minimum.out,inAmount:o.inAmount,outAmount:o.outAmount,feeAmount:o.feeAmount,feeMint:this.market.quoteMintAddress.toBase58(),feePct:o.feePct,priceImpactPct:o.priceImpactPct}}createSwapInstructions({sourceMint:e,sourceTokenAccount:t,destinationTokenAccount:n,userTransferAuthority:o,amount:i,minimumOutAmount:r,openOrdersAddress:s,platformFee:a,quoteMintToReferrer:u}){if(!s)throw new Error("Missing open orders");return[X(this.market,e,s,t,n,o,i,r,a,null==u?void 0:u.get(this.market.quoteMintAddress.toBase58()))]}get reserveTokenMints(){return[this.market.baseMintAddress,this.market.quoteMintAddress]}}class Se{constructor(e,t,n){this.firstAmm=void 0,this.secondAmm=void 0,this.reserveTokenMints=void 0,this.shouldSplitSetup=void 0,this.market=void 0,this.portion1=0,this.portion2=0,this.firstAmm=e,this.secondAmm=t,this.reserveTokenMints=n,this.shouldSplitSetup=function(e,t){return e instanceof Ae||t instanceof Ae||e instanceof ke&&t instanceof ke}(e,t),this.market=e instanceof ke?e.market:t instanceof ke?t.market:null}static create(e,t){if(!function(e,t){return!(e instanceof ke&&t instanceof Ae||e instanceof Ae&&t instanceof ke||e instanceof ke&&t instanceof ke)}(e,t))return;const n=ge(e.reserveTokenMints),o=ge(t.reserveTokenMints);for(const i of n)for(const n of o)if(i.every(((e,t)=>e.equals(n[t]))))return new Se(e,t,i)}get id(){return`${this.firstAmm.id}-${this.secondAmm.id}`}get label(){return[{label:this.firstAmm.label,portion:this.portion1},{label:this.secondAmm.label,portion:this.portion2}].sort(((e,t)=>t.portion-e.portion)).map((({label:e,portion:t})=>`${e} (${t}%)`)).join(" + ")}getAccountsForUpdate(){return[]}update(e){}getQuote(e){var t,n,o,i;const r=e.sourceMint.toBase58(),s=e.amount;let a={outAmount:0,portion:0,firstQuote:void 0,secondQuote:void 0};for(let t=100;t-=5;t>0){const n=Math.floor(s*t/100),o=s-n,i=this.firstAmm.getQuote({...e,amount:n}),r=this.secondAmm.getQuote({...e,amount:o}),u=i.outAmount+r.outAmount;if(u<a.outAmount)break;a={outAmount:u,portion:t,firstQuote:i,secondQuote:r}}if(!a.firstQuote||!a.secondQuote)throw new Error("Unreachable: There was no better solution than getting 0 outAmount");const{outAmount:u,portion:c,firstQuote:m,secondQuote:l}=a,d=c,p=100-d;this.portion1=d,this.portion2=p;let g={amount:m.feeAmount,mint:m.feeMint},f={amount:l.feeAmount,mint:l.feeMint};g.mint!==f.mint&&(g.mint!==r&&(g={amount:Math.floor(g.amount*s*d/100/a.outAmount),mint:r}),f.mint!==r&&(f={amount:Math.floor(f.amount*s*p/100/a.outAmount),mint:r}));const h=m.minInAmount||l.minInAmount?(null!==(t=m.minInAmount)&&void 0!==t?t:0)+(null!==(n=l.minInAmount)&&void 0!==n?n:0):void 0,A=m.minOutAmount||l.minOutAmount?(null!==(o=m.minOutAmount)&&void 0!==o?o:0)+(null!==(i=l.minOutAmount)&&void 0!==i?i:0):void 0;return{notEnoughLiquidity:!1,inAmount:e.amount,outAmount:u,minInAmount:h,minOutAmount:A,feeAmount:g.amount+f.amount,feeMint:g.mint,feePct:(d*m.feePct+p*l.feePct)/100,priceImpactPct:(d*m.priceImpactPct+p*l.priceImpactPct)/100}}createSwapInstructions(e){const t=e.amount,n=Math.floor(t*this.portion1/100),o=t-n;return[re(e.destinationTokenAccount),...this.firstAmm.createSwapInstructions({...e,amount:n,minimumOutAmount:0,platformFee:void 0}),...this.secondAmm.createSwapInstructions({...e,amount:o,minimumOutAmount:0,platformFee:void 0}),ie(e.destinationTokenAccount,e.userTransferAuthority,e.minimumOutAmount,e.platformFee)]}}const ye=(e,t)=>!(e instanceof pe&&t instanceof pe||e instanceof Se||t instanceof Se),Me=n=>{if(null==n||0==n.length)return;const o=e.AccountLayout.decode(n);return o.mint=new t.PublicKey(o.mint),o.owner=new t.PublicKey(o.owner),o.amount=e.u64.fromBuffer(o.amount),0===o.delegateOption?(o.delegate=null,o.delegatedAmount=new e.u64(0)):(o.delegate=new t.PublicKey(o.delegate),o.delegatedAmount=e.u64.fromBuffer(o.delegatedAmount)),o.isInitialized=0!==o.state,o.isFrozen=2===o.state,1===o.isNativeOption?(o.rentExemptReserve=e.u64.fromBuffer(o.isNative),o.isNative=!0):(o.rentExemptReserve=null,o.isNative=!1),o.closeAuthority=0===o.closeAuthorityOption?null:new t.PublicKey(o.closeAuthority),o};class Te{constructor(e){this.stableSwap=void 0,this.label="Saber",this.tokenAccounts=void 0,this.calculator=void 0,this.stableSwap=e}get id(){return this.stableSwap.config.swapAccount.toBase58()}getAccountsForUpdate(){return[this.stableSwap.state.tokenA.reserve,this.stableSwap.state.tokenB.reserve]}update(e){let t=fe(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=Me(e.data);if(!t)throw new Error("Invalid token account data");return t})),this.calculator=new u.Stable(g.default.BigInt(this.stableSwap.state.targetAmpFactor.toString()),this.tokenAccounts.map((e=>g.default.BigInt(e.amount.toString()))),[u.ONE,u.ONE],new u.Fraction(this.stableSwap.state.fees.trade.numerator,this.stableSwap.state.fees.trade.denominator))}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.tokenAccounts)throw new Error("Unable to fetch accounts for specified tokens.");if(void 0===this.calculator)throw new Error("Unable to fetch accounts for Curve calculator.");const o=new h.default(this.stableSwap.state.fees.trade.asFraction.toFixed(4)),[i,r]=this.tokenAccounts[0].mint.equals(e)?[0,1]:[1,0],s=this.calculator.exchange(g.default.BigInt(n),D,i,r);return{notEnoughLiquidity:!1,inAmount:n,outAmount:g.default.toNumber(s.expectedOutputAmount),feeAmount:g.default.toNumber(s.fees),feeMint:t.toBase58(),feePct:o.toNumber(),priceImpactPct:s.priceImpact.toNumber()}}createSwapInstructions({sourceMint:e,sourceTokenAccount:t,destinationTokenAccount:n,userTransferAuthority:o,amount:i,minimumOutAmount:r,platformFee:s}){return[ue(this.stableSwap,e,t,n,o,i,r,s)]}get reserveTokenMints(){return[this.stableSwap.state.tokenA.mint,this.stableSwap.state.tokenB.mint]}}const ve=new e.u64(0);class be{constructor(e,t){this.numerator=void 0,this.denominator=void 0,this.toString=()=>`${this.numerator.toString()}/${this.denominator.toString()}`,this.numerator=e,this.denominator=t}static fromDecimal(e){return be.fromFraction(e.toDecimalPlaces(1).mul(10).toNumber(),1e3)}static fromFraction(t,n){const o="number"==typeof t?new e.u64(t.toString()):t,i="number"==typeof n?new e.u64(n.toString()):n;return new be(o,i)}toDecimal(){return this.denominator.eq(ve)?new h.default(0):new h.default(this.numerator.toString()).div(new h.default(this.denominator.toString()))}add(t){const n=this.denominator.gcd(t.denominator),o=this.denominator.div(n).mul(t.denominator),i=o.div(this.denominator),r=o.div(t.denominator),s=this.numerator.mul(i),a=t.numerator.mul(r),u=s.add(a);return new be(new e.u64(u.toString()),new e.u64(o.toString()))}}const Pe=c.struct([U("tradeFeeNumerator"),U("tradeFeeDenominator"),U("ownerTradeFeeNumerator"),U("ownerTradeFeeDenominator"),U("ownerWithdrawFeeNumerator"),U("ownerWithdrawFeeDenominator")],"fees"),Be=[c.blob(8,"padding"),R("lpTokenFreezeVault"),R("poolMint"),R("baseTokenVault"),R("baseTokenMint"),R("quoteTokenVault"),R("quoteTokenMint"),R("poolSigner"),c.u8("poolSignerNonce"),R("authority"),R("initializerAccount"),R("feeBaseAccount"),R("feeQuoteAccount"),R("feePoolTokenAccount"),Pe],Fe=c.struct(Be),Ie=c.struct([...Be,c.u8("curveType"),R("curve")]),Ne=c.struct([c.blob(8,"padding"),U("amp")]);class De{constructor(e,t,n={}){this.params=void 0,this.label="Aldrin",this.poolState=void 0,this.tokenAccounts=[],this.calculator=void 0,this.params=n,this.poolState=function(e,t){const n=!!t.owner.equals(B),o=(n?Ie:Fe).decode(t.data),i="curveType"in o?{curveType:o.curveType,curve:o.curve}:{};return{isV2:n,address:e,poolMint:o.poolMint,baseTokenVault:o.baseTokenVault,baseTokenMint:o.baseTokenMint,quoteTokenVault:o.quoteTokenVault,quoteTokenMint:o.quoteTokenMint,poolSigner:o.poolSigner,feeBaseAccount:o.feeBaseAccount,feeQuoteAccount:o.feeQuoteAccount,feePoolTokenAccount:o.feePoolTokenAccount,fees:{traderFee:be.fromFraction(o.fees.tradeFeeNumerator,o.fees.tradeFeeDenominator),ownerFee:be.fromFraction(o.fees.ownerTradeFeeNumerator,o.fees.ownerTradeFeeDenominator)},...i}}(e,t)}static decodeStableCurveAmp(e){const{amp:t}=Ne.decode(e.data);return 2*t.toNumber()}get id(){return this.poolState.address.toBase58()}getAccountsForUpdate(){return[this.poolState.quoteTokenVault,this.poolState.baseTokenVault]}update(e){const t=fe(e,this.getAccountsForUpdate());if(this.tokenAccounts=t.map((e=>{const t=Me(e.data);if(!t)throw new Error("Invalid token account");return t})),this.poolState.curveType){if(1===this.poolState.curveType){const{amp:e}=this.params;if(!e)throw new Error("Amp is required for a stable curve");this.calculator=new u.TokenSwapStable(g.default.BigInt(e),this.tokenAccounts.map((e=>g.default.BigInt(e.amount.toString()))),new u.Fraction(g.default.BigInt(this.poolState.fees.traderFee.numerator.toString()),g.default.BigInt(this.poolState.fees.traderFee.denominator.toString())),new u.Fraction(g.default.BigInt(this.poolState.fees.ownerFee.numerator.toString()),g.default.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}}else this.calculator=new u.TokenSwapConstantProduct(this.tokenAccounts.map((e=>g.default.BigInt(e.amount.toString()))),new u.Fraction(g.default.BigInt(this.poolState.fees.traderFee.numerator.toString()),g.default.BigInt(this.poolState.fees.traderFee.denominator.toString())),new u.Fraction(g.default.BigInt(this.poolState.fees.ownerFee.numerator.toString()),g.default.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");if(void 0===this.calculator)throw new Error("Unable to fetch accounts for Curve calculator.");let n=new h.default(this.poolState.fees.traderFee.numerator.toString()).div(this.poolState.fees.traderFee.denominator.toString()).add(new h.default(this.poolState.fees.ownerFee.numerator.toString()).div(this.poolState.fees.ownerFee.denominator.toString()));const o=this.tokenAccounts[0].mint.equals(e)?1:0;let i=this.calculator.exchange(g.default.BigInt(t),D,o);return{notEnoughLiquidity:!1,inAmount:t,outAmount:g.default.toNumber(i.expectedOutputAmount),feeAmount:g.default.toNumber(i.fees),feeMint:e.toBase58(),feePct:n.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}createSwapInstructions({sourceMint:e,sourceTokenAccount:t,destinationTokenAccount:n,userTransferAuthority:o,amount:i,minimumOutAmount:r,platformFee:s}){if(this.poolState.isV2){if(!this.poolState.curve)throw new Error("Unable to fetch curve account.");return[oe(this.poolState,e,t,n,this.poolState.curve,o,i,r,s)]}return[ne(this.poolState,e,t,n,o,i,r,s)]}get reserveTokenMints(){return[this.poolState.baseTokenMint,this.poolState.quoteTokenMint]}}const Oe=[],Ee=new t.PublicKey("SSwpMgqNDsyV7mAgN9ady4bDVu5ySjmmXejXvy2vLt1"),Ke=new Map([["9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP","Orca"],[Ee.toBase58(),"Step"],["PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP","Penguin"]]),Re=c.struct([c.u8("version"),c.u8("isInitialized"),c.u8("bumpSeed"),R("tokenProgramId"),R("tokenAccountA"),R("tokenAccountB"),R("tokenPool"),R("mintA"),R("mintB"),R("feeAccount"),U("tradeFeeNumerator"),U("tradeFeeDenominator"),U("ownerTradeFeeNumerator"),U("ownerTradeFeeDenominator"),U("ownerWithdrawFeeNumerator"),U("ownerWithdrawFeeDenominator"),U("hostFeeNumerator"),U("hostFeeDenominator"),c.u8("curveType"),c.blob(32,"curveParameters")]),Ce=c.struct([c.u8("version"),c.u8("isInitialized"),c.u8("bumpSeed"),R("tokenProgramId"),R("tokenAccountA"),R("tokenAccountB"),R("tokenPool"),R("mintA"),R("mintB"),R("feeAccount"),U("tradeFeeNumerator"),U("tradeFeeDenominator"),U("ownerTradeFeeNumerator"),U("ownerTradeFeeDenominator"),U("ownerWithdrawFeeNumerator"),U("ownerWithdrawFeeDenominator"),c.u8("curveType"),c.blob(32,"curveParameters"),c.u8("poolNonce")]);var Ue;!function(e){e[e.ConstantProduct=0]="ConstantProduct",e[e.Stable=2]="Stable"}(Ue||(Ue={}));class qe{constructor(e,n,o){if(this.label=void 0,this.tokenSwapState=void 0,this.curveType=void 0,this.tokenAccounts=[],this.calculator=void 0,this.label=o,this.tokenSwapState=function(e,n){const o=n.owner,i=o.equals(Ee)?Ce.decode(n.data):Re.decode(n.data);if(!i.isInitialized)throw new Error("Invalid token swap state");const[r]=s.findProgramAddressSync([e.toBuffer()],o),a=new t.PublicKey(i.tokenPool),u=new t.PublicKey(i.feeAccount),c=new t.PublicKey(i.tokenAccountA),m=new t.PublicKey(i.tokenAccountB),l=new t.PublicKey(i.mintA),d=new t.PublicKey(i.mintB);return{address:e,programId:o,tokenProgramId:new t.PublicKey(i.tokenProgramId),poolToken:a,feeAccount:u,authority:r,tokenAccountA:c,tokenAccountB:m,mintA:l,mintB:d,tradeFeeNumerator:i.tradeFeeNumerator,tradeFeeDenominator:i.tradeFeeDenominator,ownerTradeFeeNumerator:i.ownerTradeFeeNumerator,ownerTradeFeeDenominator:i.ownerTradeFeeDenominator,ownerWithdrawFeeNumerator:i.ownerWithdrawFeeNumerator,ownerWithdrawFeeDenominator:i.ownerWithdrawFeeDenominator,curveType:i.curveType,curveParameters:i.curveParameters,poolNonce:"poolNonce"in i?i.poolNonce:void 0}}(e,n),this.curveType=this.tokenSwapState.curveType,!(this.curveType in Ue))throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`)}get id(){return this.tokenSwapState.address.toBase58()}getAccountsForUpdate(){return[this.tokenSwapState.tokenAccountA,this.tokenSwapState.tokenAccountB]}update(e){const t=fe(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=Me(e.data);if(!t)throw new Error("Invalid token account");return t})),this.tokenSwapState.curveType===Ue.ConstantProduct?this.calculator=new u.TokenSwapConstantProduct(this.tokenAccounts.map((e=>g.default.BigInt(e.amount.toString()))),new u.Fraction(g.default.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),g.default.BigInt(this.tokenSwapState.tradeFeeDenominator.toString())),new u.Fraction(g.default.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),g.default.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString()))):this.tokenSwapState.curveType===Ue.Stable&&(this.calculator=new u.TokenSwapStable(g.default.BigInt(this.tokenSwapState.curveParameters[0]),this.tokenAccounts.map((e=>g.default.BigInt(e.amount.toString()))),new u.Fraction(g.default.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),g.default.BigInt(this.tokenSwapState.tradeFeeDenominator.toString())),new u.Fraction(g.default.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),g.default.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString()))))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");if(void 0===this.calculator)throw new Error("Unable to fetch accounts for Curve calculator.");let n=new h.default(this.tokenSwapState.tradeFeeNumerator.toString()).div(this.tokenSwapState.tradeFeeDenominator.toString()).add(new h.default(this.tokenSwapState.ownerTradeFeeNumerator.toString()).div(this.tokenSwapState.ownerTradeFeeDenominator.toString()));const o=this.tokenAccounts[0].mint.equals(e)?1:0;let i=this.calculator.exchange(g.default.BigInt(t),D,o);return{notEnoughLiquidity:!1,inAmount:t,outAmount:g.default.toNumber(i.expectedOutputAmount),feeAmount:g.default.toNumber(i.fees),feeMint:e.toBase58(),feePct:n.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}createSwapInstructions({sourceMint:e,sourceTokenAccount:t,destinationTokenAccount:n,userTransferAuthority:o,amount:i,minimumOutAmount:r,platformFee:s}){return[J(this.tokenSwapState,e,t,n,o,i,r,s,this.tokenSwapState.programId.equals(Ee))]}get reserveTokenMints(){return[this.tokenSwapState.mintA,this.tokenSwapState.mintB]}}const Le=Math.pow(10,10),xe=c.struct([c.u8("version"),c.u8("isInitialized"),c.u8("nonce"),U("amplificationCoefficient"),U("feeNumerator"),U("adminFeeNumerator"),c.u32("tokenAccountsLength"),U("precisionFactor"),U("precisionMultiplierA"),U("precisionMultiplierB"),U("precisionMultiplierC"),U("precisionMultiplierD"),R("tokenAccountA"),R("tokenAccountB"),R("tokenAccountC"),R("tokenAccountD")]),Ve=(e,t)=>{const n=t.owner,o=xe.decode(t.data),i=o.tokenAccountsLength,[r]=s.findProgramAddressSync([e.toBuffer()],n),a=[o.precisionMultiplierA.toNumber(),o.precisionMultiplierB.toNumber(),o.precisionMultiplierC.toNumber(),o.precisionMultiplierD.toNumber()].slice(0,i),u=[o.tokenAccountA,o.tokenAccountB,o.tokenAccountC,o.tokenAccountD].slice(0,i);return{programId:n,authority:r,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:e,amplificationCoefficient:o.amplificationCoefficient.toNumber(),feeNumerator:o.feeNumerator.toNumber(),tokenAccountsLength:i,precisionFactor:o.precisionFactor.toNumber(),precisionMultipliers:a,tokenAccounts:u}};class We{constructor(e,t,n){this.params=void 0,this.label="Mercurial",this.swapLayout=void 0,this.tokenAccounts=[],this.calculator=void 0,this.params=n,this.swapLayout=Ve(e,t)}get id(){return this.swapLayout.ammId.toBase58()}getAccountsForUpdate(){return this.swapLayout.tokenAccounts}update(e){let t=fe(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>Me(e.data))).filter((e=>null!==e)),this.calculator=new u.Stable(g.default.BigInt(this.swapLayout.amplificationCoefficient),this.tokenAccounts.map((e=>g.default.BigInt(e.amount.toString()))),this.swapLayout.precisionMultipliers.map((e=>g.default.BigInt(e))),new u.Fraction(g.default.BigInt(this.swapLayout.feeNumerator),g.default.BigInt(Le)))}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");if(void 0===this.calculator)throw new Error("Unable to fetch accounts for Curve calculator.");const o=this.tokenAccounts.findIndex((t=>t.mint.equals(e))),i=this.tokenAccounts.findIndex((e=>e.mint.equals(t))),r=this.calculator.exchange(g.default.BigInt(n),D,o,i),s=this.swapLayout.feeNumerator/Le;return{notEnoughLiquidity:!1,inAmount:n,outAmount:g.default.toNumber(r.expectedOutputAmount),feeAmount:g.default.toNumber(r.fees),feeMint:t.toBase58(),feePct:s,priceImpactPct:r.priceImpact.toNumber()}}createSwapInstructions({sourceTokenAccount:e,destinationTokenAccount:t,userTransferAuthority:n,amount:o,minimumOutAmount:i,platformFee:r}){return[Z(this.swapLayout,e,t,n,o,i,r)]}get reserveTokenMints(){return this.params.tokenMints.map((e=>new t.PublicKey(e)))}}We.decodeSwapLayout=Ve;class Ge{static async getStateFromStateAccount(e){const t=await e.getAccountInfo(V);if(!t)throw new Error("State account not found");return(e=>{const t=x.decode(e.data);return{isInitialized:Boolean(t.isInitialized),stateOwner:t.stateOwner,feeOwner:t.feeOwner,initialSupply:t.initialSupply,returnFeeNumerator:t.returnFeeNumerator.toNumber(),fixedFeeNumerator:t.fixedFeeNumerator.toNumber(),feeDenominator:t.feeDenominator.toNumber(),curveType:t.curveType,curveParameters:t.curveParameters}})(t)}constructor(e,n,o){this.params=void 0,this.label="Cropper",this.poolState=void 0,this.tokenAccounts=[],this.calculator=void 0,this.feePct=void 0,this.params=o,this.poolState=W(e,n),this.feePct=new h.default(this.params.fixedFeeNumerator).div(this.params.feeDenominator).add(new h.default(this.params.returnFeeNumerator).div(this.params.feeDenominator)),this.params.tokenAFeeAccount=new t.PublicKey(this.params.tokenAFeeAccount),this.params.tokenBFeeAccount=new t.PublicKey(this.params.tokenBFeeAccount)}get id(){return this.poolState.ammId.toBase58()}getAccountsForUpdate(){return[this.poolState.tokenAAccount,this.poolState.tokenBAccount]}update(e){const t=fe(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=Me(e.data);if(!t)throw new Error("Invalid token account");return t})),this.calculator=new u.TokenSwapConstantProduct(this.tokenAccounts.map((e=>g.default.BigInt(e.amount.toString()))),new u.Fraction(g.default.BigInt(this.params.fixedFeeNumerator),g.default.BigInt(this.params.feeDenominator)),new u.Fraction(g.default.BigInt(this.params.returnFeeNumerator),g.default.BigInt(this.params.feeDenominator)))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");if(void 0===this.calculator)throw new Error("Unable to fetch accounts for calculator.");const n=this.tokenAccounts[0].mint.equals(e)?1:0;let o=this.calculator.exchange(g.default.BigInt(t),D,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:g.default.toNumber(o.expectedOutputAmount),feeAmount:g.default.toNumber(o.fees),feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}createSwapInstructions({sourceMint:e,sourceTokenAccount:t,destinationTokenAccount:n,userTransferAuthority:o,amount:i,minimumOutAmount:r,platformFee:s}){const a=e.equals(this.poolState.mintA)?this.params.tokenAFeeAccount:this.params.tokenBFeeAccount;return[ee(this.poolState,e,t,n,o,a,i,r,s)]}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}Ge.decodePoolState=W;const Qe=c.struct([c.blob(8,"discriminator"),R("factory"),c.u8("bump"),U("index"),R("admin"),R("token0Reserves"),R("token0Mint"),R("token0Fees"),R("token1Reserves"),R("token1Mint"),R("token1Fees"),c.u8("isPaused"),R("poolMint"),U("tradeFeeKbps"),U("withdrawFeeKbps"),U("adminTradeFeeKbps"),U("adminWithdrawFeeKbps")]);class ze{constructor(e,t){this.label="Sencha",this.poolState=void 0,this.calculator=void 0,this.tokenAccounts=[],this.poolState=((e,t)=>{const n=t.owner,o=Qe.decode(t.data);return{programId:n,isPaused:Boolean(o.isPaused),bump:o.bump,ammId:e,token0Reserves:o.token0Reserves,token1Reserves:o.token1Reserves,token0Mint:o.token0Mint,token1Mint:o.token1Mint,token0Fees:o.token0Fees,token1Fees:o.token1Fees,poolMint:o.poolMint,tradeFeeKbps:o.tradeFeeKbps.toNumber()}})(e,t)}get id(){return this.poolState.ammId.toBase58()}getAccountsForUpdate(){return[this.poolState.token0Reserves,this.poolState.token1Reserves]}update(e){const t=fe(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=Me(e.data);if(!t)throw new Error("Invalid token account");return t})),this.calculator=new u.TokenSwapConstantProduct(this.tokenAccounts.map((e=>g.default.BigInt(e.amount.toString()))),new u.Fraction(g.default.BigInt(this.poolState.tradeFeeKbps),g.default.BigInt(1e7)),new u.Fraction(u.ZERO,u.ZERO),!1)}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");if(void 0===this.calculator)throw new Error("Unable to fetch accounts for Curve calculator.");const n=this.tokenAccounts[0].mint.equals(e)?1:0;let o=this.calculator.exchange(g.default.BigInt(t),D,n),i=this.poolState.tradeFeeKbps/1e7;return{notEnoughLiquidity:!1,inAmount:t,outAmount:g.default.toNumber(o.expectedOutputAmount),feeAmount:g.default.toNumber(o.fees),feeMint:e.toBase58(),feePct:i,priceImpactPct:o.priceImpact.toNumber()}}createSwapInstructions({sourceMint:e,sourceTokenAccount:t,destinationTokenAccount:n,userTransferAuthority:o,amount:i,minimumOutAmount:r,platformFee:s}){return[$(this.poolState,e,t,n,o,i,r,s)]}get reserveTokenMints(){return[this.poolState.token0Mint,this.poolState.token1Mint]}}function _e(e){if(e.length>1){const[t,n]=e.map((e=>e.amm));if(t instanceof Ae&&n instanceof Ae)return!1}return!0}const je=e=>{var t,n,o;return`${null===(t=e[0])||void 0===t?void 0:t.inputMint}-${null===(n=e[0])||void 0===n?void 0:n.outputMint}-${null===(o=e[1])||void 0===o?void 0:o.outputMint}-${e.map((e=>e.marketMeta.amm.id))}`},Ye=({instructionCache:e,walletPublicKey:t,cacheKey:n})=>{var o;return null===(o=e.get(t))||void 0===o?void 0:o.get(n)};async function He(n,o,i,r,s){const a="string"==typeof r?new t.PublicKey(r):r,u=await e.Token.getAssociatedTokenAddress(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,a,i),c=[],m=[];return null===await n.getAccountInfo(u)&&m.push(e.Token.createAssociatedTokenAccountInstruction(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,a,u,i,o)),a.equals(y)&&s&&c.push(e.Token.createCloseAccountInstruction(e.TOKEN_PROGRAM_ID,u,i,i,[])),{address:u,instructions:m,cleanupInstructions:c,signers:[]}}const Ze=async(e,t,n,o)=>{const[i,r]=await Promise.all([(async()=>2===t.length?await He(e,n,n,t[0].outputMint,o):void 0)(),(async()=>await He(e,n,n,2===t.length?t[1].outputMint:t[0].outputMint,o))()]);return{userIntermediaryTokenAccountResult:i,userDestinationTokenAccountResult:r}};async function Xe(e,t,n,o){const i={instructions:[],cleanupInstructions:[],signers:[]},r=n.address.toString();if(o){let t=o.get(r);if(t){let n=null;if(n=await e.getAccountInfo(t,"processed"),n)return{...i,address:t}}}const[s,a]=se(n,t);return await e.getAccountInfo(s)||(i.instructions=[a]),null==o||o.set(n.address.toString(),s),{...i,address:s}}const Je=({intermediate:e,destination:t,openOrders:n,feeCalculator:o})=>{const i=n.filter((e=>e&&e.instructions.length>0)).map((()=>23352760)),r=[t,e].filter((e=>(null==e?void 0:e.instructions.length)&&0===e.cleanupInstructions.length)).length,s=2039280*r;return{signatureFee:([t.signers,null==e?void 0:e.signers,null==n?void 0:n.some((e=>null==e?void 0:e.signers))].filter(Boolean).flat().length+1)*o.lamportsPerSignature,openOrdersDeposits:i,ataDeposit:s,ataDepositLength:r}},$e={feeBps:0,feeAccounts:new Map};async function et(t,n){return(await t.getTokenAccountsByOwner(n,{programId:e.TOKEN_PROGRAM_ID})).value.reduce(((e,t)=>{const n=Me(t.account.data);return n&&e.set(n.mint.toBase58(),t.pubkey),e}),new Map)}class tt{constructor(e,t,n){this.connection=void 0,this.feePayer=void 0,this.instructions=void 0,this.owner=void 0,this.connection=e,this.feePayer=t,this.instructions=[],this.owner=n}addInstruction(e){return this.instructions.push(e),this}async build(e){e||(e=(await this.connection.getRecentBlockhash("singleGossip")).blockhash);const n={recentBlockhash:e,feePayer:this.feePayer};let o=[],i=[],r=[];this.instructions.forEach((e=>{o=o.concat(e.instructions),i=i.concat(e.cleanupInstructions),r=r.concat(e.signers)}));const s=new t.Transaction(n);return o.concat(i).forEach((e=>s.add(e))),s.feePayer=this.feePayer,{transaction:s,signers:r,execute:this.owner.isKeyPair?()=>this.connection.sendTransaction(s,r):async()=>{throw new Error("Please use a Keypair for the owner parameter to enable the execute function")}}}}class nt{constructor(e){this._owner=void 0,this._owner=e}get publicKey(){return nt.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return nt.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return nt.isKeyPair(this._owner)}get isPublicKey(){return nt.isPublicKey(this._owner)}static isKeyPair(e){return void 0!==e.secretKey}static isPublicKey(e){return!nt.isKeyPair(e)}}class ot extends Error{constructor(e){super(e),this.txid=void 0,Object.setPrototypeOf(this,Error.prototype)}}function it(e,t){var n,o,i,r;const s=null===(n=t.postTokenBalances)||void 0===n||null===(o=n.find((t=>t.accountIndex===e)))||void 0===o?void 0:o.uiTokenAmount.amount,a=null===(i=t.preTokenBalances)||void 0===i||null===(r=i.find((t=>t.accountIndex===e)))||void 0===r?void 0:r.uiTokenAmount.amount;if(s)return Math.abs(parseInt(s)-(void 0!==a?parseInt(a):0))}function rt(e,t){const n=e.meta;if(n)return it(e.transaction.message.accountKeys.findIndex((e=>e.equals(t))),n)}function st(e,t){return w.default((async n=>{const o=await e.getTransaction(t,{commitment:"confirmed"});if(!o){const e=new ot("Transaction was not confirmed");return e.txid=t,n(e),o}return o}),{retries:30,minTimeout:500})}class at{constructor(n,o,i,r,s,a,u=0,c=!0){this.connection=void 0,this.cluster=void 0,this.tokenRouteSegments=void 0,this.feeCalculator=void 0,this.platformFeeAndAccounts=void 0,this.quoteMintToReferrer=void 0,this.routeCacheDuration=void 0,this.wrapUnwrapSOL=void 0,this.serumOpenOrdersPromise=void 0,this.instructionCache=new Map,this.user=void 0,this.routeCache=new Map,this.exchange=async({route:n,userPublicKey:o,feeAccount:i})=>{var r;const{connection:s,serumOpenOrdersPromise:a}=this,u=o||this.user;if(!u)throw new Error("user not found");const c=new nt(u),m=n.marketInfos.length-1,l=n.marketInfos[0].inputMint,d=n.marketInfos[m].outputMint,p=je(n.marketInfos);let g=Ye({instructionCache:this.instructionCache,walletPublicKey:c.publicKey.toBase58(),cacheKey:p});if(!g){const[e,t]=await Promise.all([Ze(s,n.marketInfos,c.publicKey,this.wrapUnwrapSOL),Promise.all(n.marketInfos.map((async({marketMeta:{amm:e}})=>{if(e instanceof ke||e instanceof Se){if(!e.market)return;return await Xe(s,c.publicKey,e.market,await a)}})))]);g={intermediate:e.userIntermediaryTokenAccountResult,destination:e.userDestinationTokenAccountResult,openOrders:t}}const f=l.equals(y)&&this.wrapUnwrapSOL?await async function(n,o,i){const r={instructions:[],cleanupInstructions:[],signers:[]};r.instructions=[];const s=await e.Token.getAssociatedTokenAddress(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,y,o);return null===await n.getAccountInfo(s)&&r.instructions.push(e.Token.createAssociatedTokenAccountInstruction(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,y,s,o,o)),r.instructions.push(t.SystemProgram.transfer({fromPubkey:o,toPubkey:s,lamports:i})),r.instructions.push(e.Token.createSyncNativeInstruction(e.TOKEN_PROGRAM_ID,s)),r.cleanupInstructions=[e.Token.createCloseAccountInstruction(e.TOKEN_PROGRAM_ID,s,o,o,[])],{address:s,...r}}(s,c.publicKey,n.inAmount):{instructions:[],cleanupInstructions:[],signers:[],address:await e.Token.getAssociatedTokenAddress(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,l,c.publicKey)},h=(i=i||this.platformFeeAndAccounts.feeAccounts.get(d.toBase58()))?{feeBps:this.platformFeeAndAccounts.feeBps||Math.floor(100*n.marketInfos[m].platformFee.pct),feeAccount:i}:void 0,A=await async function(e,t,n,o,i,r,s,a){const u=r.outAmountWithSlippage,c=r.inAmount,m=r.marketInfos.length;if(2==m&&!o)throw new Error("Missing intermediary token account");const l=1===m?[n,i]:[n,o,i];let d=[];const p=_e(r.marketInfos.map((e=>e.marketMeta)));m>1&&d.push(re(o));for(const[n,o]of r.marketInfos.entries()){const i=o.marketMeta.amm,r=0===n?c:null,g=n===m-1?u:0,f=n===m-1&&p?s:void 0,[h,A]=l.slice(n);d.push(...i.createSwapInstructions({sourceMint:o.inputMint,destinationMint:o.outputMint,sourceTokenAccount:h,destinationTokenAccount:A,userTransferAuthority:e.publicKey,amount:r,minimumOutAmount:g,openOrdersAddress:t[n],platformFee:f,quoteMintToReferrer:a}))}const{signers:g,cleanupInstructions:f}={instructions:[],cleanupInstructions:[],signers:[]};return e.isKeyPair&&e.signer&&g.push(e.signer),{signers:g,cleanupInstructions:f,instructions:d}}(c,g.openOrders.map((e=>null==e?void 0:e.address)),f.address,null===(r=g.intermediate)||void 0===r?void 0:r.address,g.destination.address,n,h,this.quoteMintToReferrer),w=function(e){if(1===e.length){const t=e[0].marketMeta.amm;if(t instanceof Se&&t.shouldSplitSetup)return!0}else{const[t,n]=e.map((e=>e.marketMeta.amm));if(t instanceof Ae||n instanceof Ae)return!0;if(t instanceof ke&&n instanceof ke)return!0}return!1}(n.marketInfos),k=new tt(s,c.publicKey,c),S=new tt(s,c.publicKey,c),M=new tt(s,c.publicKey,c);var T,v;w?(g.openOrders&&g.openOrders.forEach((e=>{e&&k.addInstruction(e)})),g.intermediate&&k.addInstruction({...g.intermediate,cleanupInstructions:[]}),k.addInstruction({...f,cleanupInstructions:[]}),M.addInstruction({instructions:[],cleanupInstructions:[],signers:[],cleanupInstructions:f.cleanupInstructions}).addInstruction({instructions:[],cleanupInstructions:[],signers:[],cleanupInstructions:null!==(T=null===(v=g.intermediate)||void 0===v?void 0:v.cleanupInstructions)&&void 0!==T?T:[]}),f.address.equals(g.destination.address)||(k.addInstruction({...g.destination,cleanupInstructions:[]}),M.addInstruction({instructions:[],cleanupInstructions:[],signers:[],cleanupInstructions:g.destination.cleanupInstructions}))):(g.openOrders&&g.openOrders.forEach((e=>{e&&S.addInstruction(e)})),g.intermediate&&S.addInstruction(g.intermediate),S.addInstruction(f),f.address.equals(g.destination.address)||S.addInstruction(g.destination)),S.addInstruction(A);const b=(await this.connection.getRecentBlockhash("singleGossip")).blockhash,{transaction:P}=await k.build(b),{transaction:B}=await S.build(b),{transaction:F}=await M.build(b),[I,N,D]=(()=>{if(P.instructions.length&&F.instructions.length)return[P,B,F];if(P.instructions.length){const[e,t]=[P,B];return[e,t,void 0]}if(F.instructions.length){const[e,t]=[B,F];return[void 0,e,t]}return[void 0,B,void 0]})();return{transactions:{setupTransaction:I,swapTransaction:N,cleanupTransaction:D},execute:async({wallet:e,confirmationWaiterFactory:t}={})=>{try{const a=[I,N,D].filter(Boolean),u=a.length;if(c.isKeyPair&&c.signer)a.forEach((e=>{e.sign(c.signer)}));else{if(!e)throw new Error("Signer wallet not found");u>1?await e.signAllTransactions(a):await e.signTransaction(a[0])}let m;if(I)try{const e=await s.sendRawTransaction(I.serialize(),{skipPreflight:!0});t?await t(e,u):await st(s,e)}catch(e){throw m=e,m}try{const e=await s.sendRawTransaction(N.serialize(),{skipPreflight:!0});let n=null;t&&(n=await t(e,u)),n||(n=await st(s,e));const[o,i]=function(e,t,n,o,i){let r,s;if(i&&(r=e.toBase58()===y.toString()?function(e){var t,n;const o=e.meta;if(!o)return;const i=null===(t=o.preTokenBalances)||void 0===t||null===(n=t.find((e=>e.mint===y.toString())))||void 0===n?void 0:n.accountIndex;return i?it(i,o):void 0}(i):rt(i,n),s=t.toBase58()===y.toString()?function(e){var t,n;const o=e.meta;if(!o)return;const i=null===(t=o.postTokenBalances)||void 0===t||null===(n=t.find((e=>e.mint===y.toString())))||void 0===n?void 0:n.accountIndex;return i?it(i,o):void 0}(i):rt(i,o)),!r||!s)throw new Error("Cannot find source or destination token account balance change");return[r,s]}(l,d,f.address,g.destination.address,n);return{txid:e,inputAddress:f.address,outputAddress:g.destination.address,inputAmount:o,outputAmount:i}}catch(e){throw e}finally{if(D&&!m){const e=await s.sendRawTransaction(D.serialize(),{skipPreflight:!0});await(null==t?void 0:t(e,u))}}}catch(e){return{error:e}}finally{var n,o,i,r;((null===(n=g)||void 0===n?void 0:n.openOrders.some((e=>null==e?void 0:e.instructions.length)))||null!==(o=g)&&void 0!==o&&null!==(i=o.intermediate)&&void 0!==i&&i.instructions.length||null!==(r=g)&&void 0!==r&&r.destination.instructions.length)&&(({instructionCache:e,walletPublicKey:t})=>{var n;null===(n=e.get(t))||void 0===n||n.clear()})({instructionCache:this.instructionCache,walletPublicKey:c.publicKey.toBase58()}),this.routeCache.clear()}}}},this.connection=n,this.cluster=o,this.tokenRouteSegments=i,this.feeCalculator=r,this.platformFeeAndAccounts=s,this.quoteMintToReferrer=a,this.routeCacheDuration=u,this.wrapUnwrapSOL=c}static async load({connection:e,cluster:n,user:o,platformFeeAndAccounts:i=$e,quoteMintToReferrer:r,routeCacheDuration:s=0,wrapUnwrapSOL:a=!0,marketUrl:u}){const[c,{value:{feeCalculator:m}},l]=await Promise.all([at.fetchTokenRouteSegments(e,n,u),e.getRecentBlockhashAndContext("processed"),et(e,new t.PublicKey(O))]),d=new at(e,n,c,m,i,r||l,s,a);return o&&d.setUserPublicKey(o),d}getPublicKeysToUpdate(){const e=new Set;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((({amm:t})=>{t.getAccountsForUpdate().forEach((t=>{e.add(t.toBase58())}))}))}))})),Array.from(e)}async computeRoutes(e,n,o,i,r=!1,s,a=0){const u=async e=>{if(this.user&&this.serumOpenOrdersPromise){const t=new nt(this.user);return(async({connection:e,marketInfos:t,userPublicKey:n,feeCalculator:o,instructionCache:i,serumOpenOrdersPromise:r,unwrapSOL:s})=>{const a=je(t),u=n.toBase58(),c=Ye({instructionCache:i,walletPublicKey:u,cacheKey:a});if(c){const{destination:e,intermediate:t,openOrders:n}=c;return Je({intermediate:t,destination:e,openOrders:n,feeCalculator:o})}const m=Promise.all(t.map((async t=>{const o=t.marketMeta.amm;if(o instanceof ke||o instanceof Se){if(!o.market)return;return await Xe(e,n,o.market,await r)}}))),l=Ze(e,t,n,s).then((({userIntermediaryTokenAccountResult:e,userDestinationTokenAccountResult:t})=>m.then((n=>({intermediate:e,destination:t,openOrders:n}))))),d=await l;return(({instructionCache:e,instructionResult:t,walletPublicKey:n,cacheKey:o})=>{const i=e.get(n)||new Map;i.set(o,t),e.set(n,i)})({cacheKey:a,instructionCache:i,instructionResult:d,walletPublicKey:u}),Je({...d,feeCalculator:o})})({connection:this.connection,feeCalculator:this.feeCalculator,instructionCache:this.instructionCache,marketInfos:e,serumOpenOrdersPromise:this.serumOpenOrdersPromise,userPublicKey:t.publicKey,unwrapSOL:this.wrapUnwrapSOL})}},c=a||(this.platformFeeAndAccounts.feeAccounts.get(n.toBase58())?this.platformFeeAndAccounts.feeBps:0),m=(new Date).getTime(),l=[e.toBase58(),n.toBase58()].sort(((e,t)=>e.localeCompare(t))).join(""),d=this.routeCache.get(l),p=function(e,n,o){var i;const r=[],s=null==o?void 0:o.get(e.toBase58());(null!==(i=null==s?void 0:s.get(n.toBase58()))&&void 0!==i?i:[]).forEach((e=>{e.amm instanceof pe||r.push({marketMetas:[e]})}));const a=null==o?void 0:o.get(n.toBase58());for(const[e,n]of null!==(u=null==s?void 0:s.entries())&&void 0!==u?u:[]){var u,c;const o=null!==(c=null==a?void 0:a.get(e))&&void 0!==c?c:[];for(const i of n)for(const n of o)ye(i.amm,n.amm)&&r.push({marketMetas:[i,n],intermediateMint:new t.PublicKey(e)})}return r}(e,n,this.tokenRouteSegments);if(d){const{fetchTimestamp:e}=d;m-e>this.routeCacheDuration&&(r=!0)}else r=!0;r&&(await async function(e,n,o){return await async function(e,n,o){const i=Boolean(o),r=o||new Map;if(!i){o=new Map;const i=new Set;n.forEach((({marketMetas:e})=>e.forEach((({amm:e})=>{e.getAccountsForUpdate().forEach((e=>{i.add(e.toBase58())}))}))));const s=Array.from(i);s.length>0&&(await async function(e,t,n=100){return(await Promise.all((o=t,i=n,Array.apply(0,new Array(Math.ceil(o.length/i))).map(((e,t)=>o.slice(t*i,(t+1)*i)))).map((t=>e.getMultipleAccountsInfo(t))))).flat();var o,i}(e,s.map((e=>new t.PublicKey(e))))).forEach(((e,t)=>{e&&r.set(s[t],e)}))}n.forEach((({marketMetas:e})=>{e.forEach((({amm:e})=>{e.update(r)}))}))}(e,n,o),n}(this.connection,p,s),this.routeCache.set(l,{fetchTimestamp:(new Date).getTime()}));try{const t=(({routes:e,amount:t,inputMint:n,outputMint:o,platformFeeBps:i,slippage:r,getDepositAndFeeForRoute:s})=>e.map((e=>{const{marketMetas:a,intermediateMint:u}=e;let c=[],m=t,l=t;const d=_e(a),p=[n,o];u&&p.splice(1,0,u);const g=a.length;for(const[e,t]of a.entries())try{const n=p[e],o=p[e+1],s=t.amm.getQuote({sourceMint:n,destinationMint:o,amount:m}),a=g-1===e&&d?{amount:Math.floor(s.outAmount*i/1e4),mint:o.toBase58(),pct:i/100}:{amount:0,mint:o.toBase58(),pct:0},u=Math.max(0,s.outAmount-a.amount),f=Math.round(u*(1-r/100));c.push({marketMeta:t,inputMint:n,outputMint:o,notEnoughLiquidity:s.notEnoughLiquidity,minInAmount:s.minInAmount,minOutAmount:s.minOutAmount,inAmount:s.inAmount,outAmount:u,priceImpactPct:s.priceImpactPct,lpFee:{amount:s.feeAmount,mint:s.feeMint,pct:s.feePct},platformFee:a}),m=u,l=f}catch(e){if("Number can only safely store up to 53 bits"===e.message)return;throw e}return{marketInfos:c,getDepositAndFee:()=>s(c),inAmount:c[0].inAmount,outAmount:m,outAmountWithSlippage:l,priceImpactPct:1-c.reduce(((e,t)=>e*(1-t.priceImpactPct)),1)}})).filter((e=>void 0!==e)).sort(((e,t)=>t.outAmount-e.outAmount)))({routes:p,amount:o,inputMint:e,outputMint:n,getDepositAndFeeForRoute:u,slippage:i,platformFeeBps:c});return{routesInfos:t,cached:!r}}catch(e){throw e}finally{this.routeCache.forEach((({fetchTimestamp:e},t)=>{e-m>this.routeCacheDuration&&this.routeCache.delete(t)}))}}setUserPublicKey(e){this.user=e;const t=new nt(this.user);this.serumOpenOrdersPromise=at.findSerumOpenOrdersForOwner({connection:this.connection,cluster:this.cluster,userPublicKey:t.publicKey})}static async fetchTokenRouteSegments(e,i,r){return function(e){const t=new Map;return e.forEach((e=>{ge(e.reserveTokenMints).forEach((([n,o])=>{!function(e,t,n,o){let i=o.get(e);i||(i=new Map([[t,[]]]),o.set(e,i));let r=i.get(t);r||(r=[],i.set(t,r)),r.push({amm:n})}(n.toBase58(),o.toBase58(),e,t)}))})),t}(await async function(e,i,r){const a=await(await A.default(r||v[i])).json(),u=function(e){return"mainnet-beta"===e?Oe:[]}(i),c=u,m=(await e.getMultipleAccountsInfo(c)).reduce(((e,t,n)=>(t&&e.push({...t,pubkey:c[n]}),e)),new Array),l=(e=>e.map((e=>{const{data:[n,o],pubkey:i,...r}=e;return{...r,pubkey:new t.PublicKey(i),data:Buffer.from(n,o),owner:new t.PublicKey(r.owner)}})))(a).concat(m),d=l.reduce(((e,i)=>{const r=function(e,i,r){const a=new t.PublicKey(i.owner);if(a.equals(M)||a.equals(T)){const e=n.Market.getLayout(a).decode(i.data);if(!e.accountFlags.initialized||!e.accountFlags.market)throw new Error("Invalid market");const t=new n.Market(e,0,0,{},a);return new ke(t)}if(a.equals(b)){const t=new Ae(e,i);if(1===t.status)return t}else{if(a.equals(E))return new We(e,i,r);if(a.equals(o.SWAP_PROGRAM_ID)){const t=o.StableSwap.loadWithData(e,i.data,s.findProgramAddressSync([e.toBuffer()],o.SWAP_PROGRAM_ID)[0]);return new Te(t)}if(a.equals(P)||a.equals(B))return new De(e,i,r);if([...Ke.keys()].includes(a.toBase58())){var u;const t=null!==(u=Ke.get(i.owner.toBase58()))&&void 0!==u?u:"Unknown";return new qe(e,i,t)}if(a.equals(I))return new Ge(e,i,r);if(a.equals(N))return new ze(e,i)}}(i.pubkey,i,i.params);return r&&e.push(r),e}),new Array),p=d.slice();return d.push(...k.map((e=>{const n={wrapper:new t.PublicKey(e.wrapper),underlying:new t.PublicKey(e.underlying),underlyingDecimals:e.underlyingDecimals,wrapperUnderlyingTokens:new t.PublicKey(e.wrapperUnderlyingTokens),mint:new t.PublicKey(e.mint),decimals:e.decimals};return new pe(new de(n))}))),function(e,t){for(let n=0;n<e.length-1;n++)for(let o=n;o<e.length-1;o++)e[n].label!==e[o].label&&t(e[n],e[o+1])}(p,((e,t)=>{const n=Se.create(e,t);n&&d.push(n)})),d}(e,i,r))}getRouteMap(){return function(e){const t=new Map;for(const[o,i]of e){const r=new Set;for(const[t,s]of i){var n;r.add(t);const i=null!==(n=e.get(t))&&void 0!==n?n:[];for(const[e,t]of i)if(e!==o)for(const n of s)for(const o of t)if(ye(n.amm,o.amm)){r.add(e);break}}t.set(o,Array.from(r))}return t}(this.tokenRouteSegments)}}at.findSerumOpenOrdersForOwner=async({userPublicKey:e,cluster:t,connection:o})=>{const i=new Map;if(e){const r="mainnet-beta"===t?M:T;(await n.OpenOrders.findForOwner(o,e,r)).forEach((e=>{i.set(e.market.toString(),e.address)}))}return i},at.createCreateTokenLedgerInstruction=function(e){return z.instruction.initializeTokenLedger({accounts:{tokenLedger:_,payer:e,systemProgram:t.SystemProgram.programId,rent:t.SYSVAR_RENT_PUBKEY}})},at.createOpenOrdersInstruction=se,at.createRaydiumSwapInstruction=te,at.createMercurialExchangeInstruction=Z,at.createSerumSwapInstruction=X,at.createSetTokenLedgerInstruction=re,exports.AldrinAmm=De,exports.CropperAmm=Ge,exports.Jupiter=at,exports.MARKETS_URL=v,exports.MercurialAmm=We,exports.RaydiumAmm=Ae,exports.SaberAmm=Te,exports.SenchaAmm=ze,exports.SerumAmm=ke,exports.SplTokenSwapAmm=qe,exports.TOKEN_LIST_URL={devnet:"https://api.jup.ag/api/tokens/devnet",testnet:"https://api.jup.ag/api/markets/devnet","mainnet-beta":"https://cache.jup.ag/tokens"},exports.TransactionBuilder=tt,exports.getEmptyInstruction=()=>({instructions:[],cleanupInstructions:[],signers:[]}),exports.getPlatformFeeAccounts=et,exports.getRouteInfoUniqueId=function(e){return e.marketInfos.map((e=>`${e.marketMeta.amm.id}-${e.inputMint}`)).join("-")};
//# sourceMappingURL=core.cjs.production.min.js.map
