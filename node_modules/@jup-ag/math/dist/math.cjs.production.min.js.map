{"version":3,"file":"math.cjs.production.min.js","sources":["../src/utils.ts","../src/math/curve.ts","../src/amm/stable.ts","../src/amm/tokenswap-stable.ts","../src/amm/tokenswap-constant-product.ts","../src/fraction.ts"],"sourcesContent":["import JSBI from 'jsbi';\nimport Decimal from 'decimal.js';\n\nexport type SwapResult = {\n  priceImpact: Decimal;\n  fees: JSBI;\n  expectedOutputAmount: JSBI;\n  minOutputAmount: JSBI;\n};\n\nexport const ZERO = JSBI.BigInt(0);\nexport const ONE = JSBI.BigInt(1);\nexport const TWO = JSBI.BigInt(2);\n\nexport function abs(number: JSBI) {\n  if (JSBI.GE(number, ZERO)) {\n    return number;\n  }\n\n  return JSBI.unaryMinus(number);\n}\n\nexport function sumArray(numbers: JSBI[]) {\n  return numbers.reduce((prev, curr) => {\n    return JSBI.add(prev, curr);\n  }, ZERO);\n}\n\nexport function mulArray(numbers: JSBI[]) {\n  return numbers.reduce((prev, curr) => {\n    return JSBI.multiply(prev, curr);\n  }, ONE);\n}\n\nexport function ceilingDivision(dividend: JSBI, divisor: JSBI): [JSBI, JSBI] {\n  let quotient = JSBI.divide(dividend, divisor);\n  if (JSBI.equal(quotient, ZERO)) {\n    return [ZERO, divisor];\n  }\n\n  let remainder = JSBI.remainder(dividend, divisor);\n  if (JSBI.greaterThan(remainder, ZERO)) {\n    quotient = JSBI.add(quotient, ONE);\n    divisor = JSBI.divide(dividend, quotient);\n    remainder = JSBI.remainder(dividend, quotient);\n    if (JSBI.greaterThan(remainder, ZERO)) {\n      divisor = JSBI.add(divisor, ONE);\n    }\n  }\n\n  return [quotient, divisor];\n}\n\nexport function toDecimal(input: JSBI, shift = 0) {\n  return new Decimal(input.toString()).div(new Decimal(10).pow(shift));\n}\n","import JSBI from 'jsbi';\nimport { abs, mulArray, ONE, sumArray, TWO, ZERO } from '../utils';\nimport Decimal from 'decimal.js';\n\nexport class Curve {\n  private numberOfCurrencies: JSBI;\n  private amplificationFactor: JSBI;\n  private tokenAmounts: JSBI[];\n  private targetPrices: JSBI[];\n\n  constructor(numberOfCurrencies: JSBI, amplificationFactor: JSBI, tokenAmounts: JSBI[], targetPrices: JSBI[]) {\n    this.numberOfCurrencies = numberOfCurrencies;\n    this.amplificationFactor = amplificationFactor;\n    this.tokenAmounts = tokenAmounts;\n    this.targetPrices = targetPrices;\n  }\n\n  public exchange(inputIndex: number, outputIndex: number, amount: JSBI, minusOne: boolean = true) {\n    let xp = this.xp();\n    let dx = JSBI.multiply(amount, this.targetPrices[inputIndex]);\n    let x = JSBI.add(xp[inputIndex], dx);\n    let y = this.computeY(inputIndex, outputIndex, x);\n    let dy = JSBI.subtract(xp[outputIndex], y);\n\n    // This is a special condition on Curve stable algo. For TokenSwap, they don't seem to apply this minus one.\n    if (minusOne) {\n      dy = JSBI.subtract(dy, ONE);\n    }\n\n    return JSBI.divide(dy, this.targetPrices[outputIndex]);\n  }\n\n  public computeBaseY(inputIndex: number, outputIndex: number, amount: JSBI) {\n    let d = this.computeD();\n    let xp = this.xp();\n    let nn = JSBI.exponentiate(this.numberOfCurrencies, this.numberOfCurrencies);\n    let sum = sumArray(xp);\n    let product = mulArray(xp);\n    let k = JSBI.subtract(\n      JSBI.add(JSBI.multiply(JSBI.multiply(this.amplificationFactor, nn), sum), d),\n      JSBI.multiply(JSBI.multiply(this.amplificationFactor, d), nn),\n    );\n    let b = JSBI.multiply(JSBI.multiply(JSBI.multiply(this.amplificationFactor, nn), nn), product);\n    let c = JSBI.multiply(JSBI.multiply(nn, product), k);\n    let numerator = JSBI.add(b, JSBI.divide(c, xp[inputIndex]));\n    let denominator = JSBI.add(b, JSBI.divide(c, xp[outputIndex]));\n\n    // Convert to number since JSBI doesn't support log10\n    let inputFactor = Math.log10(JSBI.toNumber(this.targetPrices[inputIndex]));\n    let outputFactor = Math.log10(JSBI.toNumber(this.targetPrices[outputIndex]));\n    let factor = Math.abs(outputFactor - inputFactor);\n\n    if (inputFactor >= outputFactor) {\n      return JSBI.BigInt(\n        new Decimal(numerator.toString())\n          .mul(new Decimal(amount.toString()))\n          .div(new Decimal(denominator.toString()))\n          .mul(Math.pow(10, factor))\n          .floor()\n          .toString(),\n      );\n    } else {\n      return JSBI.BigInt(\n        new Decimal(numerator.toString())\n          .mul(new Decimal(amount.toString()))\n          .div(new Decimal(denominator.toString()))\n          .div(Math.pow(10, factor))\n          .floor()\n          .toString(),\n      );\n    }\n  }\n\n  private computeY(inputIndex: number, outputIndex: number, newTotalAmount: JSBI) {\n    let d = this.computeD();\n    let xx = this.xp();\n    xx[inputIndex] = newTotalAmount;\n    xx.splice(outputIndex, 1);\n\n    let ann = JSBI.multiply(this.amplificationFactor, this.numberOfCurrencies);\n    let c = d;\n\n    for (const y of xx) {\n      c = JSBI.divide(JSBI.multiply(c, d), JSBI.multiply(y, this.numberOfCurrencies));\n    }\n    c = JSBI.divide(JSBI.multiply(c, d), JSBI.multiply(this.numberOfCurrencies, ann));\n\n    let b = JSBI.subtract(JSBI.add(sumArray(xx), JSBI.divide(d, ann)), d);\n    let yPrev = ZERO;\n    let y = d;\n\n    while (JSBI.greaterThan(abs(JSBI.subtract(y, yPrev)), ONE)) {\n      yPrev = y;\n      y = JSBI.divide(JSBI.add(JSBI.exponentiate(y, TWO), c), JSBI.add(JSBI.multiply(TWO, y), b));\n    }\n\n    return y;\n  }\n\n  private computeD() {\n    let dPrev = ZERO;\n    let xp = this.xp();\n    let sum = sumArray(xp);\n    let d = sum;\n    let ann = JSBI.multiply(this.amplificationFactor, this.numberOfCurrencies);\n\n    while (JSBI.greaterThan(abs(JSBI.subtract(d, dPrev)), ONE)) {\n      let dP = d;\n      for (const x of xp) {\n        dP = JSBI.divide(JSBI.multiply(dP, d), JSBI.multiply(this.numberOfCurrencies, x));\n      }\n      dPrev = d;\n      let numerator = JSBI.multiply(JSBI.add(JSBI.multiply(ann, sum), JSBI.multiply(dP, this.numberOfCurrencies)), d);\n      let denominator = JSBI.add(\n        JSBI.multiply(JSBI.subtract(ann, ONE), d),\n        JSBI.multiply(JSBI.add(this.numberOfCurrencies, ONE), dP),\n      );\n      d = JSBI.divide(numerator, denominator);\n    }\n\n    return d;\n  }\n\n  private xp() {\n    return this.tokenAmounts.map((tokenAmount, index) => {\n      return JSBI.multiply(tokenAmount, this.targetPrices[index]);\n    });\n  }\n}\n","import JSBI from 'jsbi';\nimport { Curve } from '../math/curve';\nimport { SwapResult, toDecimal, ZERO } from '../utils';\nimport Decimal from 'decimal.js';\nimport { Fraction } from '..';\n\nexport class Stable {\n  private curve: Curve;\n\n  constructor(amp: JSBI, private tokenAmounts: JSBI[], private targetPrices: JSBI[], private traderFee: Fraction) {\n    this.curve = new Curve(JSBI.BigInt(this.tokenAmounts.length), amp, this.tokenAmounts, this.targetPrices);\n  }\n\n  public exchange(\n    inputTradeAmount: JSBI,\n    slippageTolerance: Fraction,\n    inputIndex: number,\n    outputIndex: number,\n  ): SwapResult {\n    let outputAmountWithoutFees = this.getOutputAmount(inputTradeAmount, inputIndex, outputIndex);\n    let fees = this.getFees(outputAmountWithoutFees);\n    let expectedOutputAmount = JSBI.subtract(outputAmountWithoutFees, fees);\n\n    return {\n      priceImpact: this.getPriceImpact(inputTradeAmount, expectedOutputAmount, inputIndex, outputIndex),\n      fees: fees,\n      expectedOutputAmount: expectedOutputAmount,\n      minOutputAmount: this.getMinimumOutputAmount(expectedOutputAmount, slippageTolerance),\n    };\n  }\n\n  private getPriceImpact(\n    inputTradeAmountJSBI: JSBI,\n    expectedOutputAmountJSBI: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): Decimal {\n    if (\n      JSBI.equal(inputTradeAmountJSBI, ZERO) ||\n      JSBI.equal(this.tokenAmounts[inputIndex], ZERO) ||\n      JSBI.equal(this.tokenAmounts[outputIndex], ZERO)\n    ) {\n      return new Decimal(0);\n    }\n\n    const noSlippageOutputAmount = toDecimal(\n      this.getOutputAmountWithNoSlippage(inputTradeAmountJSBI, inputIndex, outputIndex),\n    );\n    const expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);\n    const impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);\n\n    return impact;\n  }\n\n  private getFees(outputAmountWithoutFees: JSBI): JSBI {\n    return JSBI.equal(this.traderFee.numerator, ZERO)\n      ? ZERO\n      : JSBI.divide(JSBI.multiply(outputAmountWithoutFees, this.traderFee.numerator), this.traderFee.denominator);\n  }\n\n  private getMinimumOutputAmount(expectedOutputAmount: JSBI, slippageTolerance: Fraction): JSBI {\n    return JSBI.divide(\n      JSBI.multiply(expectedOutputAmount, JSBI.subtract(slippageTolerance.denominator, slippageTolerance.numerator)),\n      slippageTolerance.denominator,\n    );\n  }\n\n  private getOutputAmount(inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    return this.curve.exchange(inputIndex, outputIndex, inputTradeAmount);\n  }\n\n  private getOutputAmountWithNoSlippage(inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    return this.curve.computeBaseY(inputIndex, outputIndex, inputTradeAmount);\n  }\n}\n","import JSBI from 'jsbi';\nimport { Curve } from '../math/curve';\nimport { ONE, SwapResult, toDecimal, TWO, ZERO } from '../utils';\nimport Decimal from 'decimal.js';\nimport { Fraction } from '..';\n\nexport class TokenSwapStable {\n  private curve: Curve;\n\n  constructor(amp: JSBI, private tokenAmounts: JSBI[], private traderFee: Fraction, private ownerFee: Fraction) {\n    this.curve = new Curve(TWO, amp, this.tokenAmounts, [ONE, ONE]);\n  }\n\n  public exchange(inputTradeAmount: JSBI, slippageTolerance: Fraction, outputIndex: number): SwapResult {\n    let inputIndex = outputIndex === 0 ? 1 : 0;\n    let expectedOutputAmount = this.getExpectedOutputAmount(inputTradeAmount, inputIndex, outputIndex);\n\n    return {\n      priceImpact: this.getPriceImpact(inputTradeAmount, expectedOutputAmount, inputIndex, outputIndex),\n      fees: this.getFees(inputTradeAmount),\n      expectedOutputAmount,\n      minOutputAmount: this.getMinimumOutputAmount(expectedOutputAmount, slippageTolerance),\n    };\n  }\n\n  private getPriceImpact(\n    inputTradeAmountJSBI: JSBI,\n    expectedOutputAmountJSBI: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): Decimal {\n    if (\n      JSBI.equal(inputTradeAmountJSBI, ZERO) ||\n      JSBI.equal(this.tokenAmounts[inputIndex], ZERO) ||\n      JSBI.equal(this.tokenAmounts[outputIndex], ZERO)\n    ) {\n      return new Decimal(0);\n    }\n\n    const noSlippageOutputAmount = toDecimal(\n      this.getExpectedOutputAmountWithNoSlippage(inputTradeAmountJSBI, inputIndex, outputIndex),\n    );\n\n    const expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);\n    const impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);\n\n    return impact;\n  }\n\n  private getFees(inputTradeAmount: JSBI): JSBI {\n    const tradingFee = JSBI.equal(this.traderFee.numerator, ZERO)\n      ? ZERO\n      : JSBI.divide(JSBI.multiply(inputTradeAmount, this.traderFee.numerator), this.traderFee.denominator);\n\n    const ownerFee = JSBI.equal(this.ownerFee.numerator, ZERO)\n      ? ZERO\n      : JSBI.divide(JSBI.multiply(inputTradeAmount, this.ownerFee.numerator), this.ownerFee.denominator);\n\n    return JSBI.add(tradingFee, ownerFee);\n  }\n\n  private getExpectedOutputAmount(inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    const inputTradeAmountLessFees = this.getInputAmountLessFees(inputTradeAmount);\n\n    return this.getOutputAmount(inputTradeAmountLessFees, inputIndex, outputIndex);\n  }\n\n  private getExpectedOutputAmountWithNoSlippage(inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    const inputTradeAmountLessFees = this.getInputAmountLessFees(inputTradeAmount);\n\n    return this.getOutputAmountWithNoSlippage(inputTradeAmountLessFees, inputIndex, outputIndex);\n  }\n\n  private getMinimumOutputAmount(expectedOutputAmountJSBI: JSBI, slippageTolerance: Fraction): JSBI {\n    return JSBI.divide(\n      JSBI.multiply(\n        expectedOutputAmountJSBI,\n        JSBI.subtract(slippageTolerance.denominator, slippageTolerance.numerator),\n      ),\n      slippageTolerance.denominator,\n    );\n  }\n\n  private getInputAmountLessFees(inputTradeAmount: JSBI): JSBI {\n    return JSBI.subtract(inputTradeAmount, this.getFees(inputTradeAmount));\n  }\n\n  private getOutputAmount(inputTradeAmountLessFees: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    return this.curve.exchange(inputIndex, outputIndex, inputTradeAmountLessFees, false);\n  }\n\n  private getOutputAmountWithNoSlippage(inputTradeAmountLessFees: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    return this.curve.computeBaseY(inputIndex, outputIndex, inputTradeAmountLessFees);\n  }\n}\n","import JSBI from 'jsbi';\nimport { SwapResult, toDecimal, ZERO, ceilingDivision } from '../utils';\nimport Decimal from 'decimal.js';\nimport { Fraction } from '..';\n\nexport class TokenSwapConstantProduct {\n  constructor(\n    private tokenAmounts: JSBI[],\n    private traderFee: Fraction,\n    private ownerFee: Fraction,\n    private feesOnInput: boolean = true,\n  ) {}\n\n  public exchange(inputTradeAmount: JSBI, slippageTolerance: Fraction, outputIndex: number): SwapResult {\n    let inputIndex = outputIndex === 0 ? 1 : 0;\n    const newInputTradeAmount = this.feesOnInput ? this.getAmountLessFees(inputTradeAmount) : inputTradeAmount;\n\n    let expectedOutputAmount = this.getExpectedOutputAmount(newInputTradeAmount, inputIndex, outputIndex);\n\n    let fees = this.getFees(this.feesOnInput ? inputTradeAmount : expectedOutputAmount);\n\n    if (!this.feesOnInput) {\n      expectedOutputAmount = this.getAmountLessFees(expectedOutputAmount);\n    }\n\n    return {\n      priceImpact: this.getPriceImpact(newInputTradeAmount, expectedOutputAmount, inputIndex, outputIndex),\n      fees,\n      expectedOutputAmount,\n      minOutputAmount: this.getMinimumOutputAmount(expectedOutputAmount, slippageTolerance),\n    };\n  }\n\n  private getPriceImpact(\n    inputTradeAmountJSBI: JSBI,\n    expectedOutputAmountJSBI: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): Decimal {\n    if (\n      JSBI.equal(inputTradeAmountJSBI, ZERO) ||\n      JSBI.equal(this.tokenAmounts[inputIndex], ZERO) ||\n      JSBI.equal(this.tokenAmounts[outputIndex], ZERO)\n    ) {\n      return new Decimal(0);\n    }\n\n    const noSlippageOutputAmount = toDecimal(\n      this.getExpectedOutputAmountWithNoSlippage(inputTradeAmountJSBI, inputIndex, outputIndex),\n    );\n    const expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);\n    const impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);\n\n    return impact;\n  }\n\n  private getFees(inputTradeAmount: JSBI): JSBI {\n    const tradingFee = JSBI.equal(this.traderFee.numerator, ZERO)\n      ? ZERO\n      : JSBI.divide(JSBI.multiply(inputTradeAmount, this.traderFee.numerator), this.traderFee.denominator);\n\n    const ownerFee = JSBI.equal(this.ownerFee.numerator, ZERO)\n      ? ZERO\n      : JSBI.divide(JSBI.multiply(inputTradeAmount, this.ownerFee.numerator), this.ownerFee.denominator);\n\n    return JSBI.add(tradingFee, ownerFee);\n  }\n\n  private getExpectedOutputAmount(inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    return this.getOutputAmount(inputTradeAmount, inputIndex, outputIndex);\n  }\n\n  private getExpectedOutputAmountWithNoSlippage(inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    if (JSBI.equal(this.tokenAmounts[inputIndex], ZERO)) {\n      return this.tokenAmounts[outputIndex];\n    }\n\n    let expectedOutputAmountWithNoSlippage = JSBI.divide(\n      JSBI.multiply(inputTradeAmount, this.tokenAmounts[outputIndex]),\n      this.tokenAmounts[inputIndex],\n    );\n\n    if (this.feesOnInput) {\n      return expectedOutputAmountWithNoSlippage;\n    } else {\n      return this.getAmountLessFees(expectedOutputAmountWithNoSlippage);\n    }\n  }\n\n  private getMinimumOutputAmount(expectedOutputAmountJSBI: JSBI, slippageTolerance: Fraction): JSBI {\n    return JSBI.divide(\n      JSBI.multiply(\n        expectedOutputAmountJSBI,\n        JSBI.subtract(slippageTolerance.denominator, slippageTolerance.numerator),\n      ),\n      slippageTolerance.denominator,\n    );\n  }\n\n  private getAmountLessFees(tradeAmount: JSBI): JSBI {\n    return JSBI.subtract(tradeAmount, this.getFees(tradeAmount));\n  }\n\n  private getOutputAmount(inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    const [poolInputAmount, poolOutputAmount] = [this.tokenAmounts[inputIndex], this.tokenAmounts[outputIndex]];\n\n    const invariant = this.getInvariant();\n\n    const [newPoolOutputAmount] = ceilingDivision(invariant, JSBI.add(poolInputAmount, inputTradeAmount));\n\n    return JSBI.subtract(poolOutputAmount, newPoolOutputAmount);\n  }\n\n  getInvariant() {\n    return JSBI.multiply(this.tokenAmounts[0], this.tokenAmounts[1]);\n  }\n}\n","import JSBI from 'jsbi';\n\nexport class Fraction {\n  constructor(public numerator: JSBI, public denominator: JSBI) {}\n}\n"],"names":["ZERO","JSBI","BigInt","ONE","TWO","abs","number","GE","unaryMinus","sumArray","numbers","reduce","prev","curr","add","mulArray","multiply","ceilingDivision","dividend","divisor","quotient","divide","equal","remainder","greaterThan","toDecimal","input","shift","Decimal","toString","div","pow","Curve","numberOfCurrencies","amplificationFactor","tokenAmounts","targetPrices","exchange","inputIndex","outputIndex","amount","minusOne","xp","this","dx","x","y","computeY","dy","subtract","computeBaseY","d","computeD","nn","exponentiate","sum","product","k","b","c","numerator","denominator","inputFactor","Math","log10","toNumber","outputFactor","factor","mul","floor","newTotalAmount","xx","splice","ann","yPrev","dPrev","dP","map","tokenAmount","index","_this","Stable","amp","traderFee","curve","length","inputTradeAmount","slippageTolerance","outputAmountWithoutFees","getOutputAmount","fees","getFees","expectedOutputAmount","priceImpact","getPriceImpact","minOutputAmount","getMinimumOutputAmount","inputTradeAmountJSBI","expectedOutputAmountJSBI","noSlippageOutputAmount","getOutputAmountWithNoSlippage","sub","TokenSwapStable","ownerFee","getExpectedOutputAmount","getExpectedOutputAmountWithNoSlippage","tradingFee","inputTradeAmountLessFees","getInputAmountLessFees","TokenSwapConstantProduct","feesOnInput","newInputTradeAmount","getAmountLessFees","expectedOutputAmountWithNoSlippage","tradeAmount","poolInputAmount","poolOutputAmount","getInvariant"],"mappings":"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"}