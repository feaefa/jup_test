"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultipleConnectionBroadcaster = exports.SingleConnectionBroadcaster = void 0;
const tslib_1 = require("tslib");
const _1 = require(".");
const simulateTransactionWithCommitment_1 = require("./utils/simulateTransactionWithCommitment");
/**
 * Broadcasts transactions to a single connection.
 */
class SingleConnectionBroadcaster {
    constructor(sendConnection, opts = _1.DEFAULT_PROVIDER_OPTIONS) {
        this.sendConnection = sendConnection;
        this.opts = opts;
    }
    getRecentBlockhash(commitment = "processed") {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const result = yield this.sendConnection.getRecentBlockhash(commitment);
            return result.blockhash;
        });
    }
    /**
     * Broadcasts a signed transaction.
     *
     * @param tx
     * @param confirm
     * @param opts
     * @returns
     */
    broadcast(tx, _a = this.opts) {
        var { printLogs = true } = _a, opts = (0, tslib_1.__rest)(_a, ["printLogs"]);
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (tx.signatures.length === 0) {
                throw new Error("Transaction must be signed before broadcasting.");
            }
            const rawTx = tx.serialize();
            if (printLogs) {
                return new _1.PendingTransaction(this.sendConnection, yield this.sendConnection.sendRawTransaction(rawTx, opts));
            }
            return yield (0, _1.suppressConsoleErrorAsync)(() => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                // hide the logs of TX errors if printLogs = false
                return new _1.PendingTransaction(this.sendConnection, yield this.sendConnection.sendRawTransaction(rawTx, opts));
            }));
        });
    }
    /**
     * Simulates a transaction with a commitment.
     * @param tx
     * @param commitment
     * @returns
     */
    simulate(tx, { commitment = "processed", verifySigners = true, } = {
        commitment: "processed",
        verifySigners: true,
    }) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (verifySigners && tx.signatures.length === 0) {
                throw new Error("Transaction must be signed before simulating.");
            }
            return yield (0, simulateTransactionWithCommitment_1.simulateTransactionWithCommitment)(this.sendConnection, tx, commitment);
        });
    }
}
exports.SingleConnectionBroadcaster = SingleConnectionBroadcaster;
/**
 * Broadcasts transactions to multiple connections simultaneously.
 */
class MultipleConnectionBroadcaster {
    constructor(connections, opts = _1.DEFAULT_PROVIDER_OPTIONS) {
        this.connections = connections;
        this.opts = opts;
    }
    getRecentBlockhash(commitment) {
        var _a;
        if (commitment === void 0) { commitment = (_a = this.opts.commitment) !== null && _a !== void 0 ? _a : "processed"; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const result = yield Promise.any(this.connections.map((conn) => conn.getRecentBlockhash(commitment)));
            return result.blockhash;
        });
    }
    _sendRawTransaction(encoded, options) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return yield Promise.any(this.connections.map((connection) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                return new _1.PendingTransaction(connection, yield connection.sendRawTransaction(encoded, options));
            })));
        });
    }
    /**
     * Broadcasts a signed transaction.
     *
     * @param tx
     * @param confirm
     * @param opts
     * @returns
     */
    broadcast(tx, _a = this.opts) {
        var { printLogs = true } = _a, opts = (0, tslib_1.__rest)(_a, ["printLogs"]);
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (tx.signatures.length === 0) {
                throw new Error("Transaction must be signed before broadcasting.");
            }
            const rawTx = tx.serialize();
            if (printLogs) {
                return yield this._sendRawTransaction(rawTx, opts);
            }
            return yield (0, _1.suppressConsoleErrorAsync)(() => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                // hide the logs of TX errors if printLogs = false
                return yield this._sendRawTransaction(rawTx, opts);
            }));
        });
    }
    /**
     * Simulates a transaction with a commitment.
     * @param tx
     * @param commitment
     * @returns
     */
    simulate(tx, { commitment = "processed", verifySigners = true, } = {
        commitment: "processed",
        verifySigners: true,
    }) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (verifySigners && tx.signatures.length === 0) {
                throw new Error("Transaction must be signed before simulating.");
            }
            return yield Promise.any(this.connections.map((connection) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                return yield (0, simulateTransactionWithCommitment_1.simulateTransactionWithCommitment)(connection, tx, commitment);
            })));
        });
    }
}
exports.MultipleConnectionBroadcaster = MultipleConnectionBroadcaster;
//# sourceMappingURL=broadcaster.js.map