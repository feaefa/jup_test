import { __awaiter, __rest } from "tslib";
import promiseRetry from "promise-retry";
import { TransactionReceipt } from "../transaction";
/**
 * Transaction which may or may not be confirmed.
 */
export class PendingTransaction {
    constructor(connection, signature) {
        this.connection = connection;
        this.signature = signature;
        this._receipt = null;
    }
    /**
     * Gets the transaction receipt, if it has already been fetched.
     *
     * You probably want the async version of this function, `wait`.
     */
    get receipt() {
        return this._receipt;
    }
    /**
     * Waits for the confirmation of the transaction, via polling.
     * @returns
     */
    wait(_a = {}) {
        var { commitment = "confirmed", useWebsocket = false } = _a, retryOpts = __rest(_a, ["commitment", "useWebsocket"]);
        return __awaiter(this, void 0, void 0, function* () {
            if (this._receipt) {
                return this._receipt;
            }
            if (useWebsocket) {
                yield this.awaitSignatureConfirmation(commitment);
                return yield this.pollForReceipt({ commitment });
            }
            return yield this.pollForReceipt(Object.assign({ commitment }, retryOpts));
        });
    }
    /**
     * Fetches the TransactionReceipt via polling.
     * @returns
     */
    pollForReceipt(_a = {}) {
        var { commitment = "confirmed" } = _a, retryOpts = __rest(_a, ["commitment"]);
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = yield promiseRetry((retry) => __awaiter(this, void 0, void 0, function* () {
                const result = yield this.connection.getTransaction(this.signature, {
                    commitment,
                });
                if (!result) {
                    retry(new Error("Error fetching transaction"));
                    return;
                }
                return new TransactionReceipt(this.signature, result);
            }), Object.assign({ retries: 5, minTimeout: 500 }, retryOpts));
            if (!receipt) {
                throw new Error("transaction could not be confirmed");
            }
            this._receipt = receipt;
            return receipt;
        });
    }
    /**
     * Awaits the confirmation of the transaction, via onSignature subscription.
     * @returns
     */
    awaitSignatureConfirmation(commitment = "confirmed") {
        return __awaiter(this, void 0, void 0, function* () {
            const { value } = yield this.connection.confirmTransaction(this.signature, commitment);
            if (value.err) {
                throw value.err;
            }
            return this.signature;
        });
    }
}
//# sourceMappingURL=PendingTransaction.js.map