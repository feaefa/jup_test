/**
 * This file is a port of serum-common, which was built for web3.js 0.x.
 */
import { __awaiter } from "tslib";
import { Token as SPLToken, TOKEN_PROGRAM_ID } from "@solana/spl-token";
import { Keypair, PublicKey, SystemProgram, Transaction, } from "@solana/web3.js";
import { deserializeAccount, deserializeMint, MintLayout, Token } from ".";
export * as token from "./token";
export const SPL_SHARED_MEMORY_ID = new PublicKey("shmem4EWT2sPdVGvTZCzXXRAURL9G5vpPxNwSeKhHUL");
export function createMint(provider, authority, decimals) {
    return __awaiter(this, void 0, void 0, function* () {
        if (authority === undefined) {
            authority = provider.wallet.publicKey;
        }
        const mint = Keypair.generate();
        const instructions = yield createMintInstructions(provider, authority, mint.publicKey, decimals);
        const tx = new Transaction();
        tx.add(...instructions);
        yield provider.send(tx, [mint]);
        return mint.publicKey;
    });
}
/**
 * Creates a Token.
 *
 * @param provider
 * @param authority The mint authority.
 * @param decimals Number of decimals.
 * @returns
 */
export function createToken(provider, authority, decimals = 6) {
    return __awaiter(this, void 0, void 0, function* () {
        return Token.fromMint(yield createMint(provider, authority, decimals), decimals);
    });
}
export function createMintInstructions(provider, authority, mint, decimals = 6) {
    return __awaiter(this, void 0, void 0, function* () {
        const instructions = [
            SystemProgram.createAccount({
                fromPubkey: provider.wallet.publicKey,
                newAccountPubkey: mint,
                space: MintLayout.span,
                lamports: yield provider.connection.getMinimumBalanceForRentExemption(MintLayout.span),
                programId: TOKEN_PROGRAM_ID,
            }),
            SPLToken.createInitMintInstruction(TOKEN_PROGRAM_ID, mint, decimals, authority, null),
        ];
        return instructions;
    });
}
export function createMintAndVault(provider, amount, owner, decimals) {
    return __awaiter(this, void 0, void 0, function* () {
        if (owner === undefined) {
            owner = provider.wallet.publicKey;
        }
        const mint = Keypair.generate();
        const vault = Keypair.generate();
        const tx = new Transaction();
        tx.add(...(yield createMintInstructions(provider, provider.wallet.publicKey, mint.publicKey, decimals)), SystemProgram.createAccount({
            fromPubkey: provider.wallet.publicKey,
            newAccountPubkey: vault.publicKey,
            space: 165,
            lamports: yield provider.connection.getMinimumBalanceForRentExemption(165),
            programId: TOKEN_PROGRAM_ID,
        }), SPLToken.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint.publicKey, vault.publicKey, owner), SPLToken.createMintToInstruction(TOKEN_PROGRAM_ID, mint.publicKey, vault.publicKey, provider.wallet.publicKey, [], amount));
        yield provider.send(tx, [mint, vault]);
        return [mint.publicKey, vault.publicKey];
    });
}
export function createTokenAccountInstrs(provider, newAccountPubkey, mint, owner, lamports) {
    return __awaiter(this, void 0, void 0, function* () {
        if (lamports === undefined) {
            lamports = yield provider.connection.getMinimumBalanceForRentExemption(165);
        }
        return [
            SystemProgram.createAccount({
                fromPubkey: provider.wallet.publicKey,
                newAccountPubkey,
                space: 165,
                lamports,
                programId: TOKEN_PROGRAM_ID,
            }),
            SPLToken.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, newAccountPubkey, owner),
        ];
    });
}
export function createAccountRentExempt(provider, programId, size) {
    return __awaiter(this, void 0, void 0, function* () {
        const acc = Keypair.generate();
        const tx = new Transaction();
        tx.add(SystemProgram.createAccount({
            fromPubkey: provider.wallet.publicKey,
            newAccountPubkey: acc.publicKey,
            space: size,
            lamports: yield provider.connection.getMinimumBalanceForRentExemption(size),
            programId,
        }));
        yield provider.send(tx, [acc]);
        return acc;
    });
}
export function getMintInfo(provider, addr) {
    return __awaiter(this, void 0, void 0, function* () {
        const depositorAccInfo = yield provider.getAccountInfo(addr);
        if (depositorAccInfo === null) {
            throw new Error("Failed to find token mint account");
        }
        return deserializeMint(depositorAccInfo.accountInfo.data);
    });
}
export function getTokenAccount(provider, addr) {
    return __awaiter(this, void 0, void 0, function* () {
        const depositorAccInfo = yield provider.getAccountInfo(addr);
        if (depositorAccInfo === null) {
            throw new Error("Failed to find token account");
        }
        return deserializeAccount(depositorAccInfo.accountInfo.data);
    });
}
export function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
//# sourceMappingURL=common.js.map