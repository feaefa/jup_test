import { __awaiter } from "tslib";
import { TOKEN_PROGRAM_ID } from "@saberhq/token-utils";
import { PublicKey } from "@solana/web3.js";
import { SWAP_PROGRAM_ID } from "./constants";
import * as instructions from "./instructions";
import { decodeSwap } from "./state";
import { StableSwapLayout } from "./state/layout";
import { loadProgramAccount } from "./util/account";
export class StableSwap {
    /**
     * Constructor for new StableSwap client object
     * @param connection
     * @param config
     * @param state
     */
    constructor(config, state) {
        this.config = config;
        this.state = state;
    }
    /**
     * Get the minimum balance for the token swap account to be rent exempt
     *
     * @return Number of lamports required
     */
    static getMinBalanceRentForExemptStableSwap(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield connection.getMinimumBalanceForRentExemption(StableSwapLayout.span);
        });
    }
    /**
     * Load an onchain StableSwap program.
     *
     * @param connection The connection to use
     * @param swapAccount The public key of the account to load
     * @param programID Address of the onchain StableSwap program
     */
    static load(connection, swapAccount, programID = SWAP_PROGRAM_ID) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield loadProgramAccount(connection, swapAccount, programID);
            const [authority] = yield findSwapAuthorityKey(swapAccount, programID);
            return StableSwap.loadWithData(swapAccount, data, authority, programID);
        });
    }
    /**
     * Loads an onchain StableSwap program from an exchange.
     *
     * @param connection
     * @param exchange
     * @returns
     */
    static loadFromExchange(connection, exchange) {
        return __awaiter(this, void 0, void 0, function* () {
            return StableSwap.load(connection, exchange.swapAccount, exchange.programID);
        });
    }
    /**
     * Loads a StableSwap instance with data.
     *
     * @param programID The program ID.
     * @param swapAccount The address of the swap.
     * @param swapAccountData The data of the swapAccount.
     * @param authority The swap's authority.
     * @returns
     */
    static loadWithData(swapAccount, swapAccountData, authority, programID = SWAP_PROGRAM_ID) {
        try {
            const stableSwapData = StableSwapLayout.decode(swapAccountData);
            if (!stableSwapData.isInitialized) {
                throw new Error(`Invalid token swap state`);
            }
            const state = decodeSwap(swapAccountData);
            return new StableSwap({
                swapAccount: swapAccount,
                swapProgramID: programID,
                tokenProgramID: TOKEN_PROGRAM_ID,
                authority,
            }, state);
        }
        catch (e) {
            throw Error(e);
        }
    }
    /**
     * Swap token A for token B
     * @param userSource
     * @param poolSource
     * @param poolDestination
     * @param userDestination
     * @param amountIn
     * @param minimumAmountOut
     */
    swap(args) {
        const adminDestination = args.poolDestination.equals(this.state.tokenA.reserve)
            ? this.state.tokenA.adminFeeAccount
            : this.state.tokenB.adminFeeAccount;
        return instructions.swapInstruction(Object.assign(Object.assign({ config: this.config }, args), { adminDestination }));
    }
    /**
     * Deposit tokens into the pool.
     */
    deposit(args) {
        return instructions.depositInstruction(Object.assign({ config: this.config, tokenAccountA: this.state.tokenA.reserve, tokenAccountB: this.state.tokenB.reserve, poolTokenMint: this.state.poolTokenMint }, args));
    }
    /**
     * Withdraw tokens from the pool
     */
    withdraw(args) {
        return instructions.withdrawInstruction(Object.assign({ config: this.config, poolMint: this.state.poolTokenMint, tokenAccountA: this.state.tokenA.reserve, tokenAccountB: this.state.tokenB.reserve, adminFeeAccountA: this.state.tokenA.adminFeeAccount, adminFeeAccountB: this.state.tokenB.adminFeeAccount }, args));
    }
    /**
     * Withdraw tokens from the pool
     */
    withdrawOne(args) {
        const [quoteTokenAccount, adminDestinationAccount] = args.baseTokenAccount.equals(this.state.tokenA.reserve)
            ? [this.state.tokenB.reserve, this.state.tokenA.adminFeeAccount]
            : [this.state.tokenA.reserve, this.state.tokenB.adminFeeAccount];
        return instructions.withdrawOneInstruction(Object.assign({ config: this.config, poolMint: this.state.poolTokenMint, quoteTokenAccount,
            adminDestinationAccount }, args));
    }
}
/**
 * Finds the swap authority address that is used to sign transactions on behalf of the swap.
 *
 * @param swapAccount
 * @param swapProgramID
 * @returns
 */
export const findSwapAuthorityKey = (swapAccount, swapProgramID = SWAP_PROGRAM_ID) => PublicKey.findProgramAddress([swapAccount.toBuffer()], swapProgramID);
//# sourceMappingURL=stable-swap.js.map